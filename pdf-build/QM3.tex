%% Generated by Sphinx.
\def\sphinxdocclass{jupyterBook}
\documentclass[letterpaper,table,10pt,english]{jupyterBook}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]



\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Frontmatter}}

\usepackage{sphinxmessages}


\nonstopmode   % 23/03/23 added to skip current Qutip build issues, but should be careful with this, and fix properly! See https://tex.stackexchange.com/questions/140845/how-can-i-ignore-latex-error-while-compiling
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{multirow}
% make phantomsection empty inside figures, see https://sphinxcontrib-bibtex.readthedocs.io/en/latest/usage.html#latex-backend-fails-with-citations-in-figure-captions
\usepackage{etoolbox}
% \AtBeginEnvironment{figure}{\renewcommand{\phantomsection}{}}  % Doesn't fix - old version?
\AtBeginEnvironment{figure}{\pretocmd{\hyperlink}{\protect}{}{}}  % WORKING From https://github.com/mcmtroffaes/sphinxcontrib-bibtex/issues/276#issuecomment-1102154800, see also https://github.com/executablebooks/jupyter-book/issues/1710#issuecomment-1331323071
%
% ****** MORE MATHS RENDER TESTS, all failing.
% Trying to fix `\bar{\varUpsilon}` gives `! Internal error: bad native font flag in `map_char_to_glyph'`
% WORK AROUND, use \bar{\varUpsilon_{}} instead.
% ** Fix hat issues, from https://tex.stackexchange.com/a/70498 - FAILS
% \def\acc@hat{\mbox{\raisebox{-1.27ex}[0ex][0ex]{\^{}}}}
% \renewcommand*\hat[1]{\placeaccent{\acc@hat}{#1}}
% ** Testing more maths stuff, from https://tex.stackexchange.com/questions/578375/mathcal-incompatible-with-unicode-math
% \usepackage{unicode-math}
% \setmathfont{XITS Math}[Scale = MatchUppercase ]
% \setmathfont{Latin Modern Math}[range = {cal,bfcal},Scale = MatchUppercase ]
% ** Similar from https://tex.stackexchange.com/questions/227033/why-cant-i-use-my-font-with-unicode-math
% \usepackage{unicode-math}
% \setmathfont{Latin Modern Math}
% \usepackage{mathspec}
% \setmathfont(Latin,Digits,Greek){Latin Modern Sans}
% \setmathrm{Latin Modern Sans}
% ** Per https://github.com/wspr/unicode-math/issues/400 
% \usepackage[mathbf=sym]{unicode-math}
% ** Per https://tex.stackexchange.com/questions/159785/caveats-of-newtxmath-and-fontspec-together
% \usepackage[no-math]{fontspec}
% \usepackage[libertine]{newtxmath}


        % Start of preamble defined in sphinx-jupyterbook-latex %
         \usepackage[Latin,Greek]{ucharclasses}
        \usepackage{unicode-math}
        % fixing title of the toc
        \addto\captionsenglish{\renewcommand{\contentsname}{Contents}}
        \hypersetup{
            pdfencoding=auto,
            psdextra
        }
        % End of preamble defined in sphinx-jupyterbook-latex %
        

\title{Quantum Metrology with Photoelectrons Vol. 3 *Analysis methodologies*}
\date{Mar 29, 2023}
\release{}
\author{Paul Hockett}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{intro::doc}}


\sphinxAtStartPar
Quantum Metrology with Photoelectrons Volume 3: \sphinxstyleemphasis{Analysis
methodologies}, an open source executable book. This repository contains the source documents (mainly Jupyter Notebooks in Python) and notes for the book, as of Jan 2022 writing is in progress, and the \sphinxhref{https://phockett.github.io/Quantum-Metrology-with-Photoelectrons-Vol3/}{current HTML build can be found online}. The book is due to be finished in 2023, and will be published by IOP Press \sphinxhyphen{} see below for more details.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\Large Series abstract}
\end{DUlineblock}

\sphinxAtStartPar
Photoionization is an interferometric process, in which multiple paths can contribute to the final continuum photoelectron wavefunction. At the simplest level, interferences between different final angular momentum states are manifest in the energy and angle resolved photoelectron spectra: metrology schemes making use of these interferograms are thus phase\sphinxhyphen{}sensitive, and provide a powerful route to detailed understanding of photoionization. In these cases, the continuum wavefunction (and underlying scattering dynamics) can be characterised. At a more complex level, such measurements can also provide a powerful probe for other processes of interest, leading to a more general class of quantum metrology built on phase\sphinxhyphen{}sensitive photoelectron imaging.  Since the turn of the century, the increasing availability of photoelectron imaging experiments, along with the increasing sophistication of experimental techniques, and the availability of computational resources for analysis and numerics, has allowed for significant developments in such photoelectron metrology.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large About the books}
\end{DUlineblock}

\sphinxAtStartPar
\sphinxincludegraphics{{mock_covers_2vol_020318}.png}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Volume I covers the core physics of photoionization, including a range of computational examples. The material is presented as both reference and tutorial, and should appeal to readers of all levels. ISBN 978\sphinxhyphen{}1\sphinxhyphen{}6817\sphinxhyphen{}4684\sphinxhyphen{}5, \sphinxurl{http://iopscience.iop.org/book/978-1-6817-4684-5} (IOP Press, 2018)

\item {} 
\sphinxAtStartPar
Volume II explores applications, and the development of quantum metrology schemes based on photoelectron measurements. The material is more technical, and will appeal more to the specialist reader. ISBN 978\sphinxhyphen{}1\sphinxhyphen{}6817\sphinxhyphen{}4688\sphinxhyphen{}3, \sphinxurl{http://iopscience.iop.org/book/978-1-6817-4688-3} (IOP Press, 2018)

\end{itemize}

\sphinxAtStartPar
Additional online resources for Vols. I \& II can be found on \sphinxhref{https://osf.io/q2v3g/wiki/home/}{OSF} and \sphinxhref{https://github.com/phockett/Quantum-Metrology-with-Photoelectrons}{Github}.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Volume III in the series will continue this exploration, with a focus on numerical analysis techniques, forging a closer link between experimental and theoretical results, and making the methodologies discussed directly accessible via new software. The book is due for publication by IOP due in 2023; this volume is also open\sphinxhyphen{}source, with a live HTML version at \sphinxurl{https://phockett.github.io/Quantum-Metrology-with-Photoelectrons-Vol3/} and source available at \sphinxurl{https://github.com/phockett/Quantum-Metrology-with-Photoelectrons-Vol3}.

\end{itemize}

\sphinxAtStartPar
For some additional details and motivations (including topical video), see \sphinxhref{https://phockett.github.io/ePSdata/about.html\#Motivation}{the ePSdata project}.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Technical details}
\end{DUlineblock}

\sphinxAtStartPar
This repository contains:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{doc\sphinxhyphen{}source}}: the source documents (mainly Jupyter Notebooks in Python)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{notes}}: additional notes for the book,

\item {} 
\sphinxAtStartPar
the \sphinxcode{\sphinxupquote{gh\sphinxhyphen{}pages}} branch contains the current HTML build, also available at \sphinxurl{https://phockett.github.io/Quantum-Metrology-with-Photoelectrons-Vol3/}

\end{itemize}

\sphinxAtStartPar
The project has been setup to use the \sphinxhref{https://jupyterbook.org/}{Jupyter Book} build\sphinxhyphen{}chain (which uses Sphinx on the back\sphinxhyphen{}end) to generate HTML and Latex outputs for publication from source Jupyter notebooks \& markdown files.

\sphinxAtStartPar
The work \sphinxstyleemphasis{within} the book will make use of the \sphinxhref{https://pemtk.readthedocs.io/en/latest/about.html}{Photoelectron Metrology Toolkit} platform for working with experimental \& theoretical data.

\sphinxAtStartPar
\sphinxincludegraphics{{ccdcf3feb912fb992ab79da89d86a2521bfe1c21}.png}

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Running code examples}
\end{DUlineblock}

\sphinxAtStartPar
Each Jupyter notebook (\sphinxcode{\sphinxupquote{*.ipynb}}) can be treated as a stand\sphinxhyphen{}alone computational document. These can be run/used/modified independently with an appropriately setup python environment (details to follow).

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Building the book}
\end{DUlineblock}

\sphinxAtStartPar
The full book can also be built from source:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Clone this repository

\item {} 
\sphinxAtStartPar
Run \sphinxcode{\sphinxupquote{pip install \sphinxhyphen{}r requirements.txt}} (it is recommended you do this within a virtual environment)

\item {} 
\sphinxAtStartPar
(Optional) Edit the books source files located in the \sphinxcode{\sphinxupquote{doc\sphinxhyphen{}source/}} directory

\item {} 
\sphinxAtStartPar
Run \sphinxcode{\sphinxupquote{jupyter\sphinxhyphen{}book clean doc\sphinxhyphen{}source/}} to remove any existing builds

\item {} 
\sphinxAtStartPar
For an HTML build:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Run \sphinxcode{\sphinxupquote{jupyter\sphinxhyphen{}book build doc\sphinxhyphen{}source/}}

\item {} 
\sphinxAtStartPar
A fully\sphinxhyphen{}rendered HTML version of the book will be built in \sphinxcode{\sphinxupquote{doc\sphinxhyphen{}source/\_build/html/}}.

\end{itemize}

\item {} 
\sphinxAtStartPar
For a LaTex \& PDF build:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Run \sphinxcode{\sphinxupquote{jupyter\sphinxhyphen{}book build doc\sphinxhyphen{}source/ \sphinxhyphen{}\sphinxhyphen{}builder pdflatex}}

\item {} 
\sphinxAtStartPar
A fully\sphinxhyphen{}rendered HTML version of the book will be built in \sphinxcode{\sphinxupquote{doc\sphinxhyphen{}source/\_build/latex/}}.

\end{itemize}

\end{enumerate}

\sphinxAtStartPar
See \sphinxurl{https://jupyterbook.org/basics/building/index.html} for more information.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Credits}
\end{DUlineblock}

\sphinxAtStartPar
This project is created using the open source \sphinxhref{https://jupyterbook.org/}{Jupyter Book project} and the \sphinxhref{https://github.com/executablebooks/cookiecutter-jupyter-book}{executablebooks/cookiecutter\sphinxhyphen{}jupyter\sphinxhyphen{}book template}.

\sphinxAtStartPar
To add: build env \& main software packages (see automation for this…)

\sphinxAtStartPar
\sphinxincludegraphics{{logo}.png}

\sphinxstepscope


\part{Frontmatter}

\sphinxstepscope


\chapter{Overview}
\label{\detokenize{frontmatter/overview_270122:overview}}\label{\detokenize{frontmatter/overview_270122::doc}}

\section{General overview}
\label{\detokenize{frontmatter/overview_270122:general-overview}}
\sphinxAtStartPar
Vol. 3. will focus on analysis techniques for quantum metrology with photoelectrons, including:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Interpreting experimental data.

\item {} 
\sphinxAtStartPar
Extraction/reconstruction/determination of quantum mechanical properties (matrix elements, wavefunctions, density matrices) from experimental data.

\item {} 
\sphinxAtStartPar
Comparison of experimental and theoretical data.

\item {} 
\sphinxAtStartPar
New analysis methodologies \& techniques.

\item {} 
\sphinxAtStartPar
Introduction to newly\sphinxhyphen{}developed software platform (see below).

\end{itemize}


\section{Provisional contents}
\label{\detokenize{frontmatter/overview_270122:provisional-contents}}

\subsection{Part 1: theory \& software}
\label{\detokenize{frontmatter/overview_270122:part-1-theory-software}}
\sphinxAtStartPar
General review \& update of the topic, including recent theory developments.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Introduction

\sphinxAtStartPar
a.  Topic overview.

\sphinxAtStartPar
b.  Context of vol. 3 (following vols. 1 \& 2).

\sphinxAtStartPar
c.  Aims: Vol. 3 in the series will continue the exploration of quantum metrology with photoelectrons, with a focus on numerical analysis techniques, forging a closer link between experimental and theoretical results, and making the methodologies discussed directly accessible via a new software platform/ecosystem.

\item {} 
\sphinxAtStartPar
Quantum metrology software platform/ecosystem overview

\sphinxAtStartPar
a.  Introduction to python packages for simulation, data analysis, and open\sphinxhyphen{}data.

\sphinxAtStartPar
b.  Photoelectron metrology toolkit (PEMtk) package/platform for experimental data processing \& analysis. (See \sphinxhref{https://pemtk.readthedocs.io}{\sphinxstyleemphasis{pemtk.readthedocs.io}}.)

\sphinxAtStartPar
c.  ePSproc package for theory \& simulation. (See \sphinxhref{https://epsproc.readthedocs.io}{\sphinxstyleemphasis{epsproc.readthedocs.io}}.)

\sphinxAtStartPar
d.  ePSdata platform for data/results library (see \sphinxhref{https://phockett.github.io/ePSdata/about.html\#Motivation}{\sphinxstyleemphasis{ePSdata motivations}}).

\item {} 
\sphinxAtStartPar
General method development: geometric tensor treatment of
photoionization, fitting \& matrix\sphinxhyphen{}inversion techniques

\sphinxAtStartPar
a.  Theory development overview \sphinxhyphen{} tensor methods (e.g. \sphinxhref{https:/epsproc.readthedocs.io/en/latest/methodsgeometric\_method\_dev\_pt3\_AFBLM\_090620\_010920\_dev\_bk100920.html}{\sphinxstyleemphasis{ePSproc tensor methods}})

\sphinxAtStartPar
b.  Direct molecular frame reconstruction via matrix\sphinxhyphen{}inversion methods (see Gregory, Margaret, Paul Hockett, Albert Stolow, and Varun Makhija. “Towards Molecular Frame Photoelectron Angular Distributions in Polyatomic Molecules from Lab Frame Coherent Rotational Wavepacket Evolution.” \sphinxstyleemphasis{Journal of Physics B: Atomic, Molecular and Optical Physics} 54, no. 14 (July 2021): 145601.\sphinxhref{https://doi.org/10.1088/1361-6455/ac135f}{\sphinxstyleemphasis{DOI: 10.1088/1361\sphinxhyphen{}6455/ac135f}}.)

\item {} 
\sphinxAtStartPar
Numerical implementation \& analysis platform tools

\sphinxAtStartPar
a.  Tensor methods implementation in ePSproc/PEMtk.

\sphinxAtStartPar
b.  Information content analysis (inc. basis\sphinxhyphen{}set exploration, e.g. \sphinxhref{https://pemtk.readthedocs.io/en/latest/fitting/PEMtk\_fitting\_basis-set\_demo\_050621\_full.html}{\sphinxstyleemphasis{PEMtk fitting demo}}), see also vol. 2, sect. 12.1.

\sphinxAtStartPar
c.  Density matrix analysis. (e.g. \sphinxhref{https://epsproc.readthedocs.io/en/dev/methods/density\_mat\_notes\_demo\_300821.html}{\sphinxstyleemphasis{ePSproc density matrix method dev notes}})

\sphinxAtStartPar
d.  Generalised bootstrapping implementation in PEMtk (see vol. 2, sects. 11.3 \& 12.3)

\end{enumerate}


\subsection{Part 2: numerical examples}
\label{\detokenize{frontmatter/overview_270122:part-2-numerical-examples}}
\sphinxAtStartPar
Open\sphinxhyphen{}source worked examples using the new software platform.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Quantum metrology example: generalised bootstrapping for a homonuclear diatomic scattering system (N2)*

\sphinxAtStartPar
a.  Experimental data overview \& simulation.

\sphinxAtStartPar
b.  Matrix element extraction (bootstrap protocol, see vol. 2, sects. 11.3 \& 12.3) \& statistical analysis.

\sphinxAtStartPar
c.  Direct molecular frame reconstruction via matrix\sphinxhyphen{}inversion methods.

\sphinxAtStartPar
d.  Comparison of methods.

\sphinxAtStartPar
e.  Information content/quantum information analysis. (See vol. 2, sect. 12.1.)

\item {} 
\sphinxAtStartPar
Quantum metrology example: generalised bootstrapping for a heteronuclear scattering system (CO)*

\sphinxAtStartPar
a.  Experimental data overview \& simulation.

\sphinxAtStartPar
b.  Matrix element extraction (bootstrap protocol, see vol. 2, sects. 11.3 \& 12.3) \& statistical analysis.

\sphinxAtStartPar
c.  Direct molecular frame reconstruction via matrix\sphinxhyphen{}inversion methods.

\sphinxAtStartPar
d.  Comparison of methods.

\sphinxAtStartPar
e.  Information content/quantum information analysis. (See vol. 2,
sect. 12.1.)

\item {} 
\sphinxAtStartPar
Quantum metrology example: generalised bootstrapping and
matrix\sphinxhyphen{}inversion methods for a complex/general asymmetric top
scattering system (C2H4 (ethylene))*

\sphinxAtStartPar
a.  Experimental data overview \& simulation.

\sphinxAtStartPar
b.  Matrix element extraction (bootstrap protocol, see vol. 2,
sects. 11.3 \& 12.3) \& statistical analysis.

\sphinxAtStartPar
c.  Direct molecular frame reconstruction via matrix\sphinxhyphen{}inversion
methods.

\sphinxAtStartPar
d.  Comparison of methods.

\sphinxAtStartPar
e.  Information content/quantum information analysis.

\item {} 
\sphinxAtStartPar
Future directions \& outlook

\item {} 
\sphinxAtStartPar
Summary \& conclusions

\end{enumerate}

\sphinxAtStartPar
* Exact choice of “simple” and “complex” systems may change, but should
include a homonuclear diatomic and/or heteronuclear diatomic, and
symmetric and asymmetric top polyatomic systems. May also include an
atomic example.

\sphinxstepscope


\part{Theory \& software}

\sphinxstepscope


\chapter{Introduction}
\label{\detokenize{part1/main_intro_051122:introduction}}\label{\detokenize{part1/main_intro_051122:chpt-intro}}\label{\detokenize{part1/main_intro_051122::doc}}
\sphinxAtStartPar
The overall aim of \sphinxstyleemphasis{Quantum Metrology with Photoelectrons Vol. 3} is to expand, explore, and illustrate, new computational developments in quantum metrology with photoelectrons: specifically, the application of new python\sphinxhyphen{}based tools to tackle problems in matrix element retrieval. The book itself is written as a set of Jupyter Notebooks, hence all the material herein is available directly to readers, and can be run locally to further explore the topic interactively, and provide a foundation which can be adapted to apply the methodology to new problems.

\sphinxAtStartPar
Whilst this volume aims to provide a self\sphinxhyphen{}contained text, and computational examples which may be used without extensive background knowledge, a brief introduction to the core physics and some recent extensions is also presented herein (Sect. XX BELOW). The unfamiliar reader is referred to \sphinxstyleemphasis{Quantum Metrology} Vol. 1 {[}\hyperlink{cite.backmatter/bibliography:id569}{1}{]} for a more detailed introduction to the physics, and as a more general gateway to the literature. Following the topical introduction, the remainder of Part I introduces the main computational and software tools (\hyperref[\detokenize{part1/platform_intro_071122:chpt-platformintro}]{Chapter \ref{\detokenize{part1/platform_intro_071122:chpt-platformintro}}}), recent theory developments (\hyperref[\detokenize{part1/theory_101122:chpt-theory}]{Chapter \ref{\detokenize{part1/theory_101122:chpt-theory}}}), and concludes with a general overview for approaching matrix element retrieval numerically.

\sphinxAtStartPar
Part II details the application of these tools to a few specific cases, starting with a (relatively) simple homonuclear diatomic example, then escalating in complexity to a the most general polyatomic asymmetric top case.


\section{Topical introduction: from quantum metrology to a generalised bootstrapping protocol}
\label{\detokenize{part1/main_intro_051122:topical-introduction-from-quantum-metrology-to-a-generalised-bootstrapping-protocol}}\label{\detokenize{part1/main_intro_051122:sec-topical-intro}}
\sphinxAtStartPar
There are two core topics at the heart of this work, specifically photoelectron spectroscopy (and associated experimental, theoretical and analysis methodologies) and quantum metrology in general. To briefly (re)introduce these topics, and contextually frame the work discussed herein, some brief comments from \sphinxstyleemphasis{Quantum Metrology} Vol. 1 {[}\hyperlink{cite.backmatter/bibliography:id569}{1}{]} are reproduced below; the reader is referred to the introductory chapters of \sphinxstyleemphasis{Quantum Metrology} Vol. 1 {[}\hyperlink{cite.backmatter/bibliography:id569}{1}{]} for a lengthier treatment, and \sphinxhref{https://vimeo.com/223603377}{an introductory video to \sphinxstyleemphasis{Phase\sphinxhyphen{}sensitive Photoelectron Metrology} can be found online}.


\subsection{Quantum metrology with photoelectrons}
\label{\detokenize{part1/main_intro_051122:quantum-metrology-with-photoelectrons}}
\sphinxAtStartPar
To set the general context, consider quantum metrology in general…
\begin{quote}

\sphinxAtStartPar
Quantum metrology can be loosely defined as any class of experiment which provides detailed information on quantum mechanical properties (phases, coherences, entanglement etc) of a system. To stay with the spirit of modern metrology, this definition can further be refined to measurements which provide high\sphinxhyphen{}resolution quantum information; a clear contemporary example is therefore experimental methodologies which provide full quantum state reconstruction (e.g. quantum tomography), and/or make use of quantum mechanical properties as a tool for measurement (e.g. atom interferometry). Traditional high\sphinxhyphen{}resolution spectroscopies may also fit within this definition in some cases, although in the majority of cases high\sphinxhyphen{}resolution spectroscopic measurements provide transition line\sphinxhyphen{}strengths and energies, but lack sufficient information for a full determination or reconstruction of the underlying quantum state.

\sphinxAtStartPar
{[}…{]}

\sphinxAtStartPar
…at what point does a measurement of a quantum mechanical system become quantum metrology? A pragmatic view on this is that the complete quantum state of the system must be capable of \sphinxstyleemphasis{unique definition from the experimental measurement(s)}. This is pragmatic in the sense that it leaves the door open for both \sphinxstyleemphasis{inferred} and \sphinxstyleemphasis{direct} reconstruction techniques. In the former case, the experimental data informs the theory and analysis, but is not directly ‘analysed’ or ‘inverted’ to provide or reconstruct the full quantum information; in the latter case one obtains the desired quantum mechanical information from the measurement in a more ‘direct’ fashion (which may, admittedly, still remain as a rather convoluted process, depending on the level of theoretical input required). Traditional spectroscopies again provide a touchstone here \sphinxhyphen{} high\sphinxhyphen{}resolution spectroscopy measurements can be compared with models or ab initio computations to provide quantum mechanical details of a system, but typically do not directly provide this information from a set of measurements alone. In this sense they fit a pragmatic definition of quantum metrology, but not a more specific definition of quantum metrology as a (somewhat) direct empirical technique.

\sphinxAtStartPar
{[}…{]}

\sphinxAtStartPar
In summary, while quantum metrology can come in many flavours, at heart it might be considered as any set of measurements (and associated analysis methodologies) which provide detailed (quantitative) quantum mechanical information on a given system of interest \sphinxhyphen{} ideally with little or no restriction on the complexity of the system \sphinxhyphen{} and it is discussed in this spirit herein.

\begin{flushright}
---\sphinxstyleemphasis{Quantum Metrology} Vol. 1 {[}\hyperlink{cite.backmatter/bibliography:id569}{1}{]}, Chpt. 1
\end{flushright}
\end{quote}

\sphinxAtStartPar
And, for the specific case of photoionization…
\begin{quote}

\sphinxAtStartPar
… both \sphinxstyleemphasis{ab initio} methods and \sphinxstyleemphasis{high\sphinxhyphen{}dimensionality measurements} (combined with detailed \sphinxstyleemphasis{analysis methodologies}) can nonetheless provide detailed information on the photoionization dynamics. Although the simple analogy with Young’s double\sphinxhyphen{}slit {[}i.e. basic two\sphinxhyphen{}path interferometry{]} fails, the resulting photoelectron flux, measured spatially, remains, in essence, a self\sphinxhyphen{}referencing angular interferogram of the continuum wavefunction. In a more abstract sense, the basic interferometer paradigm can be extended to the general ‘photoionization interferometer’, one just has to keep in mind that there are now potentially many, many channels. In the most basic sense, the energy and angle resolved interferograms \sphinxhyphen{} the photoelectron flux as a function of energy and angle \(I(E,\theta,\phi)\) \sphinxhyphen{} which may be measured, are nothing more than an interferometric measurement sensitive to the relative phases of the different angular momentum components.

\sphinxAtStartPar
{[}…{]}

\sphinxAtStartPar
In the photoionization community, the angular interferograms (which will usually be considered at a single energy \(E\)) are photoelectron angular distributions ({\hyperref[\detokenize{backmatter/glossary:term-PADs}]{\sphinxtermref{\DUrole{xref,std,std-term}{PADs}}}}), and have long been used as a means to learn about the process of photoionization. In this context, {\hyperref[\detokenize{backmatter/glossary:term-PADs}]{\sphinxtermref{\DUrole{xref,std,std-term}{PADs}}}} measured for a range of experimental parameters can provide a dataset with sufficient information content to determine the magnitudes and phases of the photoelectron wavefunction, hence the photoionization dynamics may be reconstructed from the measurements in favourable cases. This class of measurement is traditionally termed a \sphinxstyleemphasis{complete photoionization experiment}, although the exact nature of the completeness may vary. The phase\sphinxhyphen{}sensitivity of photoelectron interferograms have also been used in complementary fashions in other contexts, including as a means to probe the phase\sphinxhyphen{}shift induced by a specific prepared pathway, and control in multipath schemes, and in many other regimes.

\sphinxAtStartPar
{[}…{]}

\sphinxAtStartPar
… the combination of a phase\sphinxhyphen{}sensitive quantum mechanical observable \sphinxhyphen{} photoelectron interferograms \sphinxhyphen{} with modern experimental and computational techniques provides the tools required for a full quantum metrology based on this class of measurement. Following the above discussion and definitions, a full metrology technique is one which allows both the \sphinxstyleemphasis{intrinsic} and \sphinxstyleemphasis{extrinsic/dynamic} quantum mechanical properties of the system under study to be obtained/reconstructed from a measurement, or set of measurements. In the simplest case, one might seek to understand just the intrinsic photoionization dynamics of a scattering system (e.g. the magnitudes and phases of the various pathways {[}…{]}), while in more complex cases the intrinsic properties are part of a probe process for additional properties or dynamics of the system {[}…{]}. In all cases, the key is measurement (and possibly control) with a high information\sphinxhyphen{}content technique, and a detailed understanding of the processes involved.

\begin{flushright}
---\sphinxstyleemphasis{Quantum Metrology} Vol. 1 {[}\hyperlink{cite.backmatter/bibliography:id569}{1}{]}, Chpt. 1
\end{flushright}
\end{quote}


\subsection{Generalised geometric metrology protocols}
\label{\detokenize{part1/main_intro_051122:generalised-geometric-metrology-protocols}}
\sphinxAtStartPar
In order to develop a quantitative form of photoelectron spectroscopy, hence analyse photoelectron interferograms in the context of quantum metrology in general, a number of techniques have previously been investigated (see \sphinxstyleemphasis{Quantum Metrology} Vols. 1 \& 2 {[}\hyperlink{cite.backmatter/bibliography:id569}{1}, \hyperlink{cite.backmatter/bibliography:id570}{2}{]}). In general, any applicable technique involves the manipulation or control of parameters which affect the observables in analytically\sphinxhyphen{}defined (or otherwise well\sphinxhyphen{}characterised) ways; measurements over a set of suitable experimental or control parameters then provide the high information\sphinxhyphen{}content dataset required for a full characterisation of the system at hand. Typically, “geometric” (angular\sphinxhyphen{}momentum) properties of the system provide a suitable set of control parameters, and a number of experimental methodologies with different flavours of these parameters have been demonstrated (see \sphinxstyleemphasis{Quantum Metrology} Vol. 2 {[}\hyperlink{cite.backmatter/bibliography:id570}{2}{]}). The main, outstanding, issue with previous techniques was the system\sphinxhyphen{}specific nature of many of the applications: ideally, one would like to make use of a generalised protocol, which is independent of the particulars of the system under study, hence does not require, for example, specific spectroscopic properties to be known and/or be experimentally accessible.

\sphinxAtStartPar
The main aim of the work in the current volume is the further development, deployment and demonstrations of, such a scheme.

\sphinxAtStartPar
The focus is on one specific \sphinxstyleemphasis{high information\sphinxhyphen{}content} technique: the \sphinxstyleemphasis{generalised bootstrapping} protocol, which makes use of experiments using rotational wavepackets as a (geometric) control dimension, and time\sphinxhyphen{}resolved photoelectron measurements as a high\sphinxhyphen{}dimensionality, phase\sphinxhyphen{}sensitive observable; the combination of these measurements with a quantitative analysis methodology provides a (relatively) general route to a full quantum metrology with photoelectrons (a.k.a. complete photoionization experiments). A brief introduction to the technique is given below, with theoretical and numerical techniques and demonstrations forming the remainder of this book; interested readers can find a longer topical introduction in \sphinxstyleemphasis{Quantum Metrology} Vol. 2 {[}\hyperlink{cite.backmatter/bibliography:id570}{2}{]} (in particular Chpt. 11), and see also Ref. {[}\hyperlink{cite.backmatter/bibliography:id649}{3}{]} for an experimental demonstration, and Ref. {[}{]} for a recent review in the context of molecular frame reconstruction.

\sphinxAtStartPar
As defined in \sphinxstyleemphasis{Quantum Metrology} Vol. 2 {[}\hyperlink{cite.backmatter/bibliography:id570}{2}{]}:
\begin{quote}

\sphinxAtStartPar
For the analysis of the data {[}time\sphinxhyphen{}resolved photoelectron images from a rotationally\sphinxhyphen{}excited system{]}, a ‘bootstrapping’ fitting approach was developed. This methodology {[}…is illustrated in figure 8.3, and…{]} is comprised of two stages (potentially split into multiple steps) which allow for the separation of the two sets of unknowns (rotational and ionization dynamics), and provides a way to gradually bootstrap to the complete {\hyperref[\detokenize{backmatter/glossary:term-MF}]{\sphinxtermref{\DUrole{xref,std,std-term}{MF}}}} results via stages of analysis of increasing complexity. The nature of the fitting at each stage also provides a flexible methodology which can be used to carefully sample the solution hyperspace in order to ensure unique results, and fit with variable information content (experimental measurements) based on computational time and desired precision, based on a similar Monte\sphinxhyphen{}Carlo sampling manner to the methodologies already discussed {[}…{]}. In all cases, the underlying physics provides stringent limits on the form of the fitting functions, hence the fitting procedure at each stage is expected to be somewhat reliable by construction. Further analysis of the results, including comparison with experimental parameters, additional data not used in the analysis, and \sphinxstyleemphasis{ab initio} calculations all provide additional means of cross\sphinxhyphen{}checking and verifying the extracted physical parameters.

\sphinxAtStartPar
In terms of information content, the bootstrapping procedure gradually increases both the experimental information content \sphinxhyphen{} the number of geometric configurations of the photoionization interferometer \sphinxhyphen{} and the level of physical information included (hence fitted/extracted) in the analysis. In the first step, {\hyperref[\detokenize{backmatter/glossary:term-ADMs}]{\sphinxtermref{\DUrole{xref,std,std-term}{ADMs}}}} {[}i.e. molecular alignment properties{]} are determined without the need for accurate treatment of the ionization probe {[}7{]}; in the second step this information is used as part of the calculation to determine the ionization dynamics. In the sub\sphinxhyphen{}steps to determine the ionization dynamics, the experimental information content included in the analysis is gradually increased: the initial coarse steps in this procedure provide a base\sphinxhyphen{}line high information content, without the necessity for many temporal points, via the selection of highly distinct molecular axis distributions, while latter sub\sphinxhyphen{}steps allow for fine\sphinxhyphen{}tuning of the data by gradually coupling additional time\sphinxhyphen{}steps into the analysis.

\begin{flushright}
---\sphinxstyleemphasis{Quantum Metrology} Vol. 2 {[}\hyperlink{cite.backmatter/bibliography:id570}{2}{]}, Chpt. 11
\end{flushright}
\end{quote}

\sphinxAtStartPar
The protocol as presented relies on certain steps to be experimentally realisable, and theoretically calculable:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Molecular alignment. Experimentally, this can be induced in any system with a strong (typically \(>10^{12}\)\textasciitilde{}Wcm\(^{-2}\)), short (few hundred femtosecond timescale or shorter) infra\sphinxhyphen{}red laser pulse, which (impulsively) creates a rotational wavepacket in the system. The exact nature of the wavepacket is laser pulse(s) and system dependent, but the technique is general.

\item {} 
\sphinxAtStartPar
Time\sphinxhyphen{}resolved photoelectron measurements. Experimentally, this requires \sphinxhyphen{} at minumum \sphinxhyphen{} a pump\sphinxhyphen{}probe type configuration, with the alignment pulse as the pump, and a time\sphinxhyphen{}delayed ionization pulse. This is a typical experimental configuration in many ultrafast laser labs, with pulses typically in the atto\sphinxhyphen{} or femto\sphinxhyphen{}second regime. Measurements may be made by any angle\sphinxhyphen{}resolved technique; photoelectron imaging is currently the most accessible and widespread method.

\item {} 
\sphinxAtStartPar
Data analysis. This provides the bridge from high information\sphinxhyphen{}content measurements to a full quantum metrology (system characterisation). For the generalised bootstrapping approach this requires:
a. In order to characterise the rotational wavepacket created, alignment calculations of the system must be possible \sphinxhyphen{} such computations are increasingly tractable, if not already (somewhat) routine for a number of groups. These calculations are required in order to determine the rotational wavepacket quantitatively, and in order to determine the corresponding {\hyperref[\detokenize{backmatter/glossary:term-ADMs}]{\sphinxtermref{\DUrole{xref,std,std-term}{ADMs}}}} from/for the experiment.
b. To characterise the \sphinxstyleemphasis{intrinsic} photoionization dynamics, a set of appropriate geometric basis functions must be computed, and combined with a sufficiently large dataset to enable extraction of the photoionization matrix elements via a fitting procedure.
c. (Optional) In cases with \sphinxstyleemphasis{extrinsic} dynamics, these may further be analysed once the \sphinxstyleemphasis{intrinsic} dynamics have been characterised (or as part of that characterisation); this may, however, remain qualitative or semi\sphinxhyphen{}quantitative, depending on the system dynamics and complexity.

\item {} 
\sphinxAtStartPar
(Optional) \sphinxstyleemphasis{Ab initio} computations may also be performed to compare with any or all of the previous steps; comparison with step 3 is particularly powerful, since one can compare fundamental quantum mechanical properties, as opposed to comparison of measured and simulated observables which may be integrated over many degrees of freedom of the system.

\end{enumerate}

\sphinxAtStartPar
As detailed in the following section (\hyperref[\detokenize{part1/main_intro_051122:sec-intro-context}]{Sect.\@ \ref{\detokenize{part1/main_intro_051122:sec-intro-context}}}), the main aims herein are the development of the methodology and toolkit to address the data analysis requirement (step 3), and to test this methodology for a range of example cases.


\section{Context \& aims for Vol. 3}
\label{\detokenize{part1/main_intro_051122:context-aims-for-vol-3}}\label{\detokenize{part1/main_intro_051122:sec-intro-context}}

\subsection{Scientific aims}
\label{\detokenize{part1/main_intro_051122:scientific-aims}}
\sphinxAtStartPar
The work in the current volume primarily addresses recent developments towards a generalised bootstrapping protocol (i.e. the analysis of the data time\sphinxhyphen{}resolved photoelectron images from a rotationally\sphinxhyphen{}excited system), as previously outlined in \sphinxstyleemphasis{Quantum Metrology} Vol. 2 {[}\hyperlink{cite.backmatter/bibliography:id570}{2}{]} Sect. 12.3; in particular the new \sphinxhref{https://github.com/phockett/PEMtk}{Photoelectron Metrology Toolkit} {[}\hyperlink{cite.backmatter/bibliography:id574}{4}{]} has been built with the aim of making the protocol easy to use and apply to any given problem (as distinct from a bespoke/per\sphinxhyphen{}experiment analysis methodology and/or non\sphinxhyphen{}open\sphinxhyphen{}source codebase).

\sphinxAtStartPar
Part I herein includes a full precis of the new codebase, along with the theory and numerics implemented towards this end; Part II provides multiple demonstrations of the new codebase, including the use of the toolkit to investigate more complex systems beyond the simple homonuclear diatomic case demonstrated to date.

\sphinxAtStartPar
Although the analysis herein focuses on the rotational wavepacket case, the techniques and codebase developed are equally applicable to \sphinxstyleemphasis{any methodology or protocol making use of geometric properties as a variable}, and are built with all such problems in mind \sphinxhyphen{} although minor modifications or extensions may be required for specific cases. Examples include other cases discussed in \sphinxstyleemphasis{Quantum Metrology} Vols. 1 \& 2 {[}\hyperlink{cite.backmatter/bibliography:id569}{1}, \hyperlink{cite.backmatter/bibliography:id570}{2}{]}, e.g. use of shaped laser pulses, use of narrow\sphinxhyphen{}band, state\sphinxhyphen{}selected rotational excitation; in all cases the fitting/retrieval of matrix elements is carried out in the same manner, and the only changes required to the methodology are the choice of control variable and the corresponding input experimental or theoretical parameters \sphinxhyphen{} this is discussed further in Chpt. XX.


\subsection{Technical context and notes}
\label{\detokenize{part1/main_intro_051122:technical-context-and-notes}}
\sphinxAtStartPar
As noted previously, Vol. 3 is somewhat distinct from the previous volumes in the series; although involving computational elements, \sphinxstyleemphasis{Quantum Metrology} Vols. 1 \& 2 {[}\hyperlink{cite.backmatter/bibliography:id569}{1}, \hyperlink{cite.backmatter/bibliography:id570}{2}{]} \% Vols. 1 \& 2 {[}\hyperlink{cite.backmatter/bibliography:id569}{1}, \hyperlink{cite.backmatter/bibliography:id570}{2}{]}
are more traditional publications. The material presented in this volume aims to continue the exploration of quantum metrology with photoelectrons, with a focus on numerical analysis techniques, forging a closer link between experimental and theoretical results, and making the methodologies discussed directly accessible via a new software platform/ecosystem, \sphinxhref{https://github.com/phockett/PEMtk}{Photoelectron Metrology Toolkit} {[}\hyperlink{cite.backmatter/bibliography:id574}{4}{]}. \%, introduced in more detail in \hyperref[\detokenize{part1/platform_intro_071122:chpt-platformintro}]{Chapter \ref{\detokenize{part1/platform_intro_071122:chpt-platformintro}}}.
In order to fulfill this aim, Vol. 3 is a computational/computable document, with code directly available to readers to facilitate code transparency and reuse. This can be broken down as follows:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
The book itself is written as a set of Jupyter Notebooks.%
\begin{footnote}[1]\sphinxAtStartFootnote
For more information on the \sphinxhref{https://jupyter.org}{Jupyter Project and ecosystem}, see \sphinxhref{https://jupyter.org}{jupyter.org} and Refs. {[}\hyperlink{cite.backmatter/bibliography:id688}{6}, \hyperlink{cite.backmatter/bibliography:id608}{7}, \hyperlink{cite.backmatter/bibliography:id533}{8}{]}.)
%
\end{footnote}
\begin{itemize}
\item {} 
\sphinxAtStartPar
These are \sphinxcode{\sphinxupquote{.ipynb}} files, usually running a python kernel, each of which is designed such that it can be modified and used independently.

\item {} 
\sphinxAtStartPar
The full book is compiled from these sections using the Jupyter Book project platform,%
\begin{footnote}[2]\sphinxAtStartFootnote
For more information see \sphinxhref{https://jupyterbook.org}{jupyterbook.org} and Refs. {[}\hyperlink{cite.backmatter/bibliography:id596}{9}, \hyperlink{cite.backmatter/bibliography:id470}{10}{]}.
%
\end{footnote} which includes build tools and specifications for the specific flavour of Markdown (MyST) used for the written text.

\item {} 
\sphinxAtStartPar
The book source code is available via a Github repository, \sphinxhref{https://github.com/phockett/Quantum-Metrology-with-Photoelectrons-Vol3}{\sphinxstyleemphasis{Quantum Metrology} Vol. 3 (Github repo)}, which includes all the notebooks (in the \sphinxcode{\sphinxupquote{doc\sphinxhyphen{}source}} directory), as well as installation and build notes for building the book itself.

\item {} 
\sphinxAtStartPar
An HTML version is also available at \sphinxhref{https://phockett.github.io/Quantum-Metrology-with-Photoelectrons-Vol3/part1/main\_intro\_051122.html}{\sphinxstyleemphasis{Quantum Metrology} Vol. 3 (HTML version)}, which includes interactive figures.

\end{itemize}

\item {} 
\sphinxAtStartPar
The code examples \sphinxstyleemphasis{within} the book make use the new \sphinxhref{https://github.com/phockett/PEMtk}{Photoelectron Metrology Toolkit} {[}\hyperlink{cite.backmatter/bibliography:id574}{4}{]}.
\begin{itemize}
\item {} 
\sphinxAtStartPar
In order to run code examples, a specific python environment (with various additional python packages) is required.

\item {} 
\sphinxAtStartPar
A full introduction to the relevant software tool\sphinxhyphen{}chain, including installation instructions for the codes used \sphinxstyleemphasis{within} the book, can be found in \hyperref[\detokenize{part1/platform_intro_071122:chpt-platformintro}]{Chapter \ref{\detokenize{part1/platform_intro_071122:chpt-platformintro}}:} {\hyperref[\detokenize{part1/platform_intro_071122:chpt-platformintro}]{\sphinxcrossref{\DUrole{std,std-ref}{Quantum metrology software platform/ecosystem overview}}}}.

\item {} 
\sphinxAtStartPar
For a quick and easy installation, including all requirements, a Docker build  of the platform can also be used, see \hyperref[\detokenize{part1/platform_intro_071122:sect-platform-docker}]{Sect.\@ \ref{\detokenize{part1/platform_intro_071122:sect-platform-docker}}:} {\hyperref[\detokenize{part1/platform_intro_071122:sect-platform-docker}]{\sphinxcrossref{\DUrole{std,std-ref}{Docker deployments}}}}.  \% \sphinxhref{https://github.com/phockett/open-photoionization-docker-stacks}{Open Photoionization Docker Stacks} {[}\hyperlink{cite.backmatter/bibliography:id577}{5}{]}).

\item {} 
\sphinxAtStartPar
Once configured, any code examples from the book can be executed locally by the user/reader, and modified as desired.

\end{itemize}

\item {} 
\sphinxAtStartPar
The book can be regarded as, essentially, a manual and introduction to the \sphinxhref{https://github.com/phockett/PEMtk}{Photoelectron Metrology Toolkit} {[}\hyperlink{cite.backmatter/bibliography:id574}{4}{]}, as well as a foundation for those wishing to use (and potentially extend) the platform.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Part I covers all required background material, including details of the theory and numerical methods implemented.

\item {} 
\sphinxAtStartPar
Part II contains various examples of usage for a range of problems, and possible extensions.

\item {} 
\sphinxAtStartPar
Since no specific knowledge of the underlying physics should be required to use the software tools, they will hopefully also provide a suitable platform for new researchers wishing to learn about photoionization in general.

\item {} 
\sphinxAtStartPar
It is, of course, also hoped that established researchers in the field will find the tools useful, and readily adaptable, to related problems of interest.

\end{itemize}

\end{enumerate}

\sphinxAtStartPar
Finally, it is of note that whilst readers unfamiliar with the Jupyter and Python ecosystem may find that there is somewhat of a barrier to entry for making use of the platform, it is one that may be worth surmounting given the ubiquity of these tools, and general usefulness in modern scientific/data\sphinxhyphen{}science workflows; readers already making use of these tools in their work should have no difficultly, and the platform adheres to standard practice wherever possible.


\subsection{Open science, open source software and reproducibility}
\label{\detokenize{part1/main_intro_051122:open-science-open-source-software-and-reproducibility}}

\bigskip\hrule\bigskip


\sphinxstepscope


\chapter{Quantum metrology software platform/ecosystem overview}
\label{\detokenize{part1/platform_intro_071122:quantum-metrology-software-platform-ecosystem-overview}}\label{\detokenize{part1/platform_intro_071122:chpt-platformintro}}\label{\detokenize{part1/platform_intro_071122::doc}}
\sphinxAtStartPar
STUB

\sphinxAtStartPar
In recent years, a unified Python codebase/ecosystem/platform has been in development to tackle various aspects of photoionization problems, including \sphinxstyleemphasis{ab initio} computations and experimental data handling, and (generalised) matrix element retrieval methods. The eponymous \sphinxstyleemphasis{Quantum Metrology with Photoelectrons} platform is introduced here, and is used for the analysis herein. The main aim of the platform is to provide a unifying data platform, and analysis routines, for photoelectron metrology, including new methods and tools, as well as a unifying bridge between these and existing tools. \hyperref[\detokenize{part1/platform_intro_071122:qm-platform-diag}]{Fig.\@ \ref{\detokenize{part1/platform_intro_071122:qm-platform-diag}}} provides a general overview of some of the main tools and tasks/layers.

\sphinxAtStartPar
As of late 2022, the new parts of the platform \sphinxhyphen{} primarily the \sphinxhref{https://github.com/phockett/PEMtk}{Photoelectron Metrology Toolkit} {[}\hyperlink{cite.backmatter/bibliography:id574}{4}{]} library \sphinxhyphen{} implement general data handling (although not a full experimental analysis toolchain), matrix element handling and retrieval, which will be the main topic of this volume.
In the future, it is hoped that the platform will be extended to other theoretical and experimental methods, including full experimental data handling.


\section{Analysis components}
\label{\detokenize{part1/platform_intro_071122:analysis-components}}\label{\detokenize{part1/platform_intro_071122:sect-platform-analysis}}
\sphinxAtStartPar
The two main components of the platform for analysis tasks, as used herein, are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The \sphinxhref{https://github.com/phockett/PEMtk}{Photoelectron Metrology Toolkit} {[}\hyperlink{cite.backmatter/bibliography:id574}{4}{]} (PEMtk) codebase aims to provide various general data handling routines for photoionization problems. At the time of writing, simulation of observables and fitting routines are implemented, along with some basic utility functions.
Much of this is detailed herein, and more technical details and ongoing documentation case be found in the \sphinxhref{https://pemtk.readthedocs.io}{PEMtk documentation} {[}\hyperlink{cite.backmatter/bibliography:id573}{11}{]}.

\item {} 
\sphinxAtStartPar
The \sphinxhref{https://epsproc.readthedocs.io}{ePSproc codebase} {[}\hyperlink{cite.backmatter/bibliography:id561}{12}, \hyperlink{cite.backmatter/bibliography:id508}{13}, \hyperlink{cite.backmatter/bibliography:id506}{14}{]} aims to provide methods for post\sphinxhyphen{}processing with \sphinxstyleemphasis{ab initio} radial dipole matrix
elements from \sphinxhref{https://epolyscat.droppages.com/}{ePolyScat (ePS)} {[}\hyperlink{cite.backmatter/bibliography:id640}{15}, \hyperlink{cite.backmatter/bibliography:id527}{16}, \hyperlink{cite.backmatter/bibliography:id671}{17}, \hyperlink{cite.backmatter/bibliography:id643}{18}{]}, or equivalent matrix elements from other sources (dedicated support for R\sphinxhyphen{}matrix results from \sphinxhref{https://gitlab.com/Uk-amor/RMT/rmt}{the RMT suite} {[}\hyperlink{cite.backmatter/bibliography:id450}{19}, \hyperlink{cite.backmatter/bibliography:id715}{20}{]} is in development).
The core functionality includes the computation of AF and MF observables. Manual computation without known matrix elements is also possible, e.g. for investigating
limiting cases, or data analysis and fitting \sphinxhyphen{} hence these routines also provide the backend functionality for PEMtk fitting routines. Again more technical details can be found in the \sphinxhref{https://epsproc.readthedocs.io}{ePSproc documentation} {[}\hyperlink{cite.backmatter/bibliography:id506}{14}{]}.

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{QM_unified_schema_wrapped_280820_gv}.png}
\caption{Quantum metrology with photoelectrons ecosystem overview.}\label{\detokenize{part1/platform_intro_071122:qm-platform-diag}}\end{figure}


\section{Additional tools}
\label{\detokenize{part1/platform_intro_071122:additional-tools}}\label{\detokenize{part1/platform_intro_071122:sect-platform-othertools}}
\sphinxAtStartPar
Other tools listed in \hyperref[\detokenize{part1/platform_intro_071122:qm-platform-diag}]{Fig.\@ \ref{\detokenize{part1/platform_intro_071122:qm-platform-diag}}} include:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Quantum chemistry layer. The starting point for \sphinxstyleemphasis{ab initio} computations. Many tools are available, but for the examples herein, all computations made use of \sphinxhref{http://www.msg.ameslab.gov/gamess/}{Gamess (“The General Atomic and Molecular Electronic Structure System”)} {[}\hyperlink{cite.backmatter/bibliography:id522}{21}, \hyperlink{cite.backmatter/bibliography:id532}{22}{]} for electronic structure computations, and inputs to ePolyScat.
\begin{itemize}
\item {} 
\sphinxAtStartPar
For a python\sphinxhyphen{}based approach, various packages are available, e.g. \sphinxhref{https://pyscf.org}{PySCF}, \sphinxhref{https://pyquante.sourceforge.net/}{PyQuante}, \sphinxhref{https://psicode.org}{Psi} can be used for electronic structure calculation, although note that some \sphinxhref{https://github.com/phockett/ePSproc}{ePSproc} {[}\hyperlink{cite.backmatter/bibliography:id508}{13}{]} routines currently require Gamess files (specifically for visualisation of orbitals).

\item {} 
\sphinxAtStartPar
A range of other python tools are available, including \sphinxhref{https://cclib.github.io/}{cclib} for file handling and conversion, \sphinxhref{https://chemlab.readthedocs.io}{Chemlab} for molecule wavefunction visualisations, see further notes below.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://epolyscat.droppages.com/}{ePolyScat (ePS)} {[}\hyperlink{cite.backmatter/bibliography:id640}{15}, \hyperlink{cite.backmatter/bibliography:id527}{16}, \hyperlink{cite.backmatter/bibliography:id671}{17}, \hyperlink{cite.backmatter/bibliography:id643}{18}{]} is an open\sphinxhyphen{}source tool for numerical computation of electron\sphinxhyphen{}molecule scattering \& photoionization by Lucchese \& coworkers. All matrix elements used herein were obtained via ePS calculations. For more details see \sphinxhref{https://epolyscat.droppages.com/}{ePolyScat website and manual} {[}\hyperlink{cite.backmatter/bibliography:id643}{18}{]} and Refs. {[}\hyperlink{cite.backmatter/bibliography:id640}{15}, \hyperlink{cite.backmatter/bibliography:id527}{16}, \hyperlink{cite.backmatter/bibliography:id671}{17}{]}.

\item {} 
\sphinxAtStartPar
\sphinxhref{https://phockett.github.io/ePSdata/about.html}{ePSdata} {[}\hyperlink{cite.backmatter/bibliography:id571}{23}{]} is an open\sphinxhyphen{}data/open\sphinxhyphen{}science collection of ePS + ePSproc results.
\begin{itemize}
\item {} 
\sphinxAtStartPar
ePSdata collects ePS datasets, post\sphinxhyphen{}processed via ePSproc (Python) in \sphinxhref{https://jupyter.org}{Jupyter notebooks}, for a full open\sphinxhyphen{}data/open\sphinxhyphen{}science transparent pipeline.

\end{itemize}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Source notebooks are available on the \sphinxhref{https://github.com/phockett/ePSdata/}{ePSdata} {[}\hyperlink{cite.backmatter/bibliography:id571}{23}{]} \sphinxhref{https://github.com/phockett/ePSdata/}{Github project repository}, and notebooks + datasets via \sphinxhref{https://zenodo.org/search?page=1\&size=20\&q=hockett\&keywords=Data}{ePSdata Zenodo} {[}\hyperlink{cite.backmatter/bibliography:id572}{24}{]}. Each notebook + dataset is given a Zenodo DOI for full traceability, and notebooks are versioned on Github.

\item {} 
\sphinxAtStartPar
Note: ePSdata may also be linked or mirrored on the existing \sphinxhref{https://osf.io/psjxt/}{ePolyScat Collected Results OSF project}, but will effectively supercede those pages.

\item {} 
\sphinxAtStartPar
All results are released under \sphinxhref{https://creativecommons.org/licenses/by-nc-sa/4.0/}{Creative Commons Attribution\sphinxhyphen{}NonCommercial\sphinxhyphen{}ShareAlike 4.0 (CC BY\sphinxhyphen{}NC\sphinxhyphen{}SA 4.0) license}, and are part of an ongoing \sphinxhref{http://femtolab.ca/?p=877}{Open Science initiative}.

\end{itemize}

\end{itemize}


\section{Python ecosystem (backends, libraries and packages)}
\label{\detokenize{part1/platform_intro_071122:python-ecosystem-backends-libraries-and-packages}}\label{\detokenize{part1/platform_intro_071122:sect-platform-pythonecosystem}}
\sphinxAtStartPar
The core analysis tools, which constitute the \sphinxhref{https://github.com/phockett/PEMtk}{Photoelectron Metrology Toolkit} {[}\hyperlink{cite.backmatter/bibliography:id574}{4}{]} platform, are themselves built with the aid of a range of open\sphinxhyphen{}source python packages/libraries which handle various backend functionality. Notably, they make use of the following key packages:
\begin{itemize}
\item {} 
\sphinxAtStartPar
General functionality makes use of the usual \sphinxcode{\sphinxupquote{Scientific Python}} stack, in particular:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Numpy}} for general numerical methods and data types.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pandas}} for statistical methods, and various tabulation and sorting tasks.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Scipy}} for some special functions and computational routines, particularly spherical harmonics and fitting routines (see below).

\end{itemize}

\item {} 
\sphinxAtStartPar
General tensor handling and manipulation makes use of the Xarray library {[}\hyperlink{cite.backmatter/bibliography:id586}{25}, \hyperlink{cite.backmatter/bibliography:id810}{26}{]}.

\item {} 
\sphinxAtStartPar
Angular momentum functions (Wigner D and 3js) are currently implemented directly, or via the Spherical Functions library {[}\hyperlink{cite.backmatter/bibliography:id448}{27}{]}, and have been tested for consistency with the definitions in Zare (for details see \sphinxhref{https://epsproc.readthedocs.io/en/latest/tests/Spherical\_function\_testing\_Aug\_2019.html}{the ePSproc docs} {[}\hyperlink{cite.backmatter/bibliography:id506}{14}{]}). The Spherical Functions library also uses \sphinxcode{\sphinxupquote{numpy\_quaternion}} which implements a quaternion datatype in Numpy.

\item {} 
\sphinxAtStartPar
Spherical harmonics are defined with the usual physics conventions: orthonormalised, and including the Condon\sphinxhyphen{}Shortley phase. Numerically they are implemented directly or via SciPy’s \sphinxcode{\sphinxupquote{sph\_harm}} function (see \sphinxhref{https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.sph\_harm.html}{the SciPy docs for details} {[}\hyperlink{cite.backmatter/bibliography:id730}{28}{]}. Further manipulation and conversion between different normalisations can be readily implemented with the SHtools library {[}\hyperlink{cite.backmatter/bibliography:id800}{29}, \hyperlink{cite.backmatter/bibliography:id740}{30}{]}.

\item {} 
\sphinxAtStartPar
Non\sphinxhyphen{}linear optimization (fitting) is handled via the \sphinxhref{https://lmfit.github.io/lmfit-py/index.html}{lmfit library}, which implements and/or wraps a range of non\sphinxhyphen{}linear fitting routines in Python {[}\hyperlink{cite.backmatter/bibliography:id635}{31}, \hyperlink{cite.backmatter/bibliography:id672}{32}{]}; for the Levenberg\sphinxhyphen{}Marquardt least\sphinxhyphen{}squares minimization method used herein this wraps \sphinxhref{https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.least\_squares.html}{Scipy’s \sphinxcode{\sphinxupquote{least\_squares}} functionality}, which therefore constituted the core minimization routine {[}\hyperlink{cite.backmatter/bibliography:id730}{28}{]} for the demonstration cases.

\item {} 
\sphinxAtStartPar
Symmetry functionality, specifically computing symmetrized harmonics \(X_{hl}^{\Gamma\mu*}(\theta,\phi)\) (see \eqref{equation:part1/theory_observables_intro_211122:eq:AF-PAD-general}), makes use of \sphinxcode{\sphinxupquote{libmsym}} {[}\hyperlink{cite.backmatter/bibliography:id593}{33}, \hyperlink{cite.backmatter/bibliography:id594}{34}{]} (symmetry coefficients) and \sphinxcode{\sphinxupquote{SHtools}} {[}\hyperlink{cite.backmatter/bibliography:id800}{29}, \hyperlink{cite.backmatter/bibliography:id740}{30}{]} (general spherical harmonic handling and conversion).

\end{itemize}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Some specialist (optional) tools also make use of additional libraries, although these are not required for basic use; in particular:
\begin{itemize}
\item {} 
\sphinxAtStartPar
For 3D orbital visualizations with \sphinxhref{https://github.com/phockett/ePSproc}{ePSproc} {[}\hyperlink{cite.backmatter/bibliography:id508}{13}{]}: \sphinxhref{https://docs.pyvista.org/}{pyvista} for 3D plotting (which itself is built on VTK), \sphinxhref{https://cclib.github.io/}{cclib} for electronic structure file handling and conversion, and methods based on \sphinxhref{https://chemlab.readthedocs.io}{Chemlab} for molecule wavefunction (orbital) computation from electronic structure files are all used on the backend.

\item {} 
\sphinxAtStartPar
For general plotting a range of tools are used, or can be used, including \sphinxhref{https://matplotlib.org/}{\sphinxcode{\sphinxupquote{Matplotlib}}} (basic plotting, including \sphinxcode{\sphinxupquote{Xarray}} plotters), \sphinxhref{https://holoviews.org/}{\sphinxcode{\sphinxupquote{Holoviews}}} (data handling and interactive plotting, wraps various backends), \sphinxhref{https://bokeh.org/}{\sphinxcode{\sphinxupquote{Bokeh}}} (implemented via Holoviews), \sphinxhref{https://plotly.com/}{\sphinxcode{\sphinxupquote{Plotly}}} (mainly used for spherical polar plotting), and \sphinxhref{https://seaborn.pydata.org/}{\sphinxcode{\sphinxupquote{Seaborn}}} (for statistical and some specialist plots).

\item {} 
\sphinxAtStartPar
\sphinxhref{https://numba.pydata.org/}{\sphinxcode{\sphinxupquote{Numba}}} is used for numerical acceleration in some routines, although remains mainly experimental in \sphinxcode{\sphinxupquote{ePSproc}} at the time of writing (an exception to this is the Spherical Functions library, which does make full use of Numba acceleration).

\end{itemize}

\end{itemize}

\sphinxAtStartPar
Further comments, including conventions and numerical examples, can be found in Chpt. XX.


\section{Docker deployments}
\label{\detokenize{part1/platform_intro_071122:docker-deployments}}\label{\detokenize{part1/platform_intro_071122:sect-platform-docker}}
\sphinxAtStartPar
A Docker\sphinxhyphen{}based distribution of various codes for tackling
photoionization problems is also available from the \sphinxhref{https://github.com/phockett/open-photoionization-docker-stacks}{Open Photoionization Docker Stacks} {[}\hyperlink{cite.backmatter/bibliography:id577}{5}{]}
project, which aims to make a range of these tools more accessible to
interested researchers, and fully cross\sphinxhyphen{}platform/portable. The project currently includes Docker builds for \sphinxcode{\sphinxupquote{ePS}}, \sphinxcode{\sphinxupquote{ePSproc}} and \sphinxcode{\sphinxupquote{PEMtk}}.


\section{General discussion}
\label{\detokenize{part1/platform_intro_071122:general-discussion}}\label{\detokenize{part1/platform_intro_071122:sect-platform-general}}
\sphinxAtStartPar
Note that, at the time of writing, rotational wavepacket simulation is
not yet implemented in the PEMtk suite, and these must be obtained via
other codes. An intial build of the \sphinxcode{\sphinxupquote{limapack}} suite for rotational wavepacket simulations is currently part of the \sphinxhref{https://github.com/phockett/open-photoionization-docker-stacks}{Open Photoionization Docker Stacks} {[}\hyperlink{cite.backmatter/bibliography:id577}{5}{]}, but has yet to be tested.

\sphinxstepscope


\chapter{Theory}
\label{\detokenize{part1/theory_101122:theory}}\label{\detokenize{part1/theory_101122:chpt-theory}}\label{\detokenize{part1/theory_101122::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{part1/theory_observables_intro_211122::doc}]{\sphinxcrossref{Observables: photoelectron flux in the LF and MF}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{part1/theory_photoionization_dynamics_191122::doc}]{\sphinxcrossref{Photoionization dynamics}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{part1/theory_tensor_formalism_201122::doc}]{\sphinxcrossref{Tensor formulation of photoionization}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{part1/theory_density_matrices_310123::doc}]{\sphinxcrossref{Density matrix representation}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{part1/theory_info_content_221122::doc}]{\sphinxcrossref{Information content \& sensitivity}}}

\end{itemize}

\sphinxstepscope


\section{Observables: photoelectron flux in the LF and MF}
\label{\detokenize{part1/theory_observables_intro_211122:observables-photoelectron-flux-in-the-lf-and-mf}}\label{\detokenize{part1/theory_observables_intro_211122:sect-theory-observables}}\label{\detokenize{part1/theory_observables_intro_211122::doc}}
\sphinxAtStartPar
The observables of interest \sphinxhyphen{} the photoelectron flux as a function of energy, ejection angle, and time \sphinxhyphen{} can be written quite generally as expansions in radial and angular basis functions. Various types and definitions are given in this section, including worked numerical examples.


\subsection{Spherical harmonics}
\label{\detokenize{part1/theory_observables_intro_211122:spherical-harmonics}}
\sphinxAtStartPar
The photoelectron flux as a function of energy, ejection angle, and time, can be written generally as an expansion in spherical harmonics:
\begin{equation}\label{equation:part1/theory_observables_intro_211122:eq:AF-PAD-general}
\begin{split}
\begin{align}
\bar{I}(\epsilon,t,\theta,\phi)=\sum_{L=0}^{2n}\sum_{M=-L}^{L}\bar{\beta}_{L,M}(\epsilon,t)Y_{L,M}(\theta,\phi)
\end{align}
\end{split}
\end{equation}
\sphinxAtStartPar
Here the flux in the laboratory frame ({\hyperref[\detokenize{backmatter/glossary:term-LF}]{\sphinxtermref{\DUrole{xref,std,std-term}{LF}}}}) or aligned frame ({\hyperref[\detokenize{backmatter/glossary:term-AF}]{\sphinxtermref{\DUrole{xref,std,std-term}{AF}}}}) is denoted \(\bar{I}(\epsilon,t,\theta,\phi)\), with the bar signifying ensemble averaging, and the molecular frame flux by \(I(\epsilon,t,\theta,\phi)\). Similarly, the expansion parameters \(\bar{\beta}_{L,M}(\epsilon,t)\) include a bar for the LF/AF case. These observables are generally termed photoelectron angular distributions ({\hyperref[\detokenize{backmatter/glossary:term-PADs}]{\sphinxtermref{\DUrole{xref,std,std-term}{PADs}}}}), often with a prefix denoting the reference frame, e.g. LFPADs, MFPADs, and the associated expansion parameters \(\bar{\beta}_{L,M}(\epsilon,t)\) are generically termed {\hyperref[\detokenize{backmatter/glossary:term-anisotropy-paramters}]{\sphinxtermref{\DUrole{xref,std,std-term}{anisotropy paramters}}}}. The polar coordinate system \((\theta,\phi)\) is referenced to
an experimentally\sphinxhyphen{}defined axis in the {\hyperref[\detokenize{backmatter/glossary:term-LF}]{\sphinxtermref{\DUrole{xref,std,std-term}{LF}}}}/{\hyperref[\detokenize{backmatter/glossary:term-AF}]{\sphinxtermref{\DUrole{xref,std,std-term}{AF}}}} case (usually defined by the laser polarization), and the molecular symmetry axis in the {\hyperref[\detokenize{backmatter/glossary:term-MF}]{\sphinxtermref{\DUrole{xref,std,std-term}{MF}}}}. Some arbitrary examples are given in \hyperref[\detokenize{part1/theory_observables_intro_211122:fig-pads-example}]{Fig.\@ \ref{\detokenize{part1/theory_observables_intro_211122:fig-pads-example}}}, which illustrates both a range of distributions of increasing complexity, and some basic code to set \(\beta_{L,M}\) parameters and visualise them; the values used as tabulated in  \hyperref[\detokenize{part1/theory_observables_intro_211122:blm-tab}]{Fig.\@ \ref{\detokenize{part1/theory_observables_intro_211122:blm-tab}}}.

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-output}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Plot some distributions from specified BLMs}

\PYG{c+c1}{\PYGZsh{} Set specific LM coeffs by list with setBLMs, items are [l,m,value]}
\PYG{k+kn}{from} \PYG{n+nn}{epsproc}\PYG{n+nn}{.}\PYG{n+nn}{sphCalc} \PYG{k+kn}{import} \PYG{n}{setBLMs}

\PYG{c+c1}{\PYGZsh{} BLM = setBLMs([[0,0,1],[1,1,1],[2,2,1]])}
\PYG{c+c1}{\PYGZsh{} BLM = setBLMs([[0,0,1,1,1],[1,1,1,0.5,0.2],[2,2,1,1,0.2]])   \PYGZsh{} Note different index}
\PYG{c+c1}{\PYGZsh{} BLM = setBLMs([[0,0,1,1,1,1],[1,1,0,0.5,0.8,1],[2,0,1,0.5,0,0],}
\PYG{c+c1}{\PYGZsh{}                [4,2,0,0,0,0.5],[4,\PYGZhy{}2,0,0,0,0.5]])}
\PYG{c+c1}{\PYGZsh{} BLM = setBLMs([[0,0,1,1,1,1,1,1],[1,1,0,0.5,0.8,1,1,1.5],[1,\PYGZhy{}1,0,0.5,0.8,1,1,1.5],[2,0,1,0.5,0,0,0.5,1],}
\PYG{c+c1}{\PYGZsh{}                [4,2,0,0,0,0.5,0.8,1],[4,\PYGZhy{}2,0,0,0,0.5,0.8,\PYGZhy{}1]])}
\PYG{n}{BLM} \PYG{o}{=} \PYG{n}{setBLMs}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
               \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mf}{0.8}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mf}{0.8}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
               \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
               \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mf}{0.8}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.8}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Quick tabulation with Pandas}
\PYG{n}{BLM}\PYG{o}{.}\PYG{n}{to\PYGZus{}pandas}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-output}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Set the backend to \PYGZsq{}pl\PYGZsq{} for an interactive surface plot with Plotly}
\PYG{c+c1}{\PYGZsh{} NOTE PL FIG RETURN BROKEN FOR THIS CASE (ePSproc v1.3.1), so run sphSumPlotX too.}
\PYG{n}{rc} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} Explict layout setting}
\PYG{n}{dataPlot}\PYG{p}{,} \PYG{n}{figObj} \PYG{o}{=} \PYG{n}{ep}\PYG{o}{.}\PYG{n}{sphFromBLMPlot}\PYG{p}{(}\PYG{n}{BLM}\PYG{p}{,} \PYG{n}{facetDim}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{plotFlag} \PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{backend} \PYG{o}{=} \PYG{n}{plotBackend}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{figObj} \PYG{o}{=} \PYG{n}{ep}\PYG{o}{.}\PYG{n}{sphSumPlotX}\PYG{p}{(}\PYG{n}{dataPlot}\PYG{p}{,}\PYG{n}{facetDim}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{plotFlag} \PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{backend} \PYG{o}{=} \PYG{n}{plotBackend}\PYG{p}{,} \PYG{n}{rc}\PYG{o}{=}\PYG{n}{rc}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{\PYGZsh{} And GLUE for display later with caption}
\PYG{c+c1}{\PYGZsh{} from myst\PYGZus{}nb import glue}
\PYG{c+c1}{\PYGZsh{} glue(\PYGZdq{}padExamplePlot\PYGZdq{}, figObj[0], display=False);}
\PYG{c+c1}{\PYGZsh{} Glue with Plotly wrapper.}
\PYG{c+c1}{\PYGZsh{} gluePlotly(\PYGZdq{}padExamplePlot\PYGZdq{}, figObj[0])   \PYGZsh{} Working in Render test notebook, but not here? Issue with subplots?}

\PYG{c+c1}{\PYGZsh{} Test in separate cell...}
\PYG{c+c1}{\PYGZsh{} gluePlotly(\PYGZdq{}padExamplePlot\PYGZdq{}, figObj[0])   \PYGZsh{} Working in Render test notebook, but not here? Issue with subplots?}

\PYG{c+c1}{\PYGZsh{} With additional layout settings \PYGZhy{} defaults give cropped subplots?}
\PYG{n}{gluePlotly}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{padExamplePlot}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{figObj}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{}.update\PYGZus{}layout(height=1400, width=1400))}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{535e89ab48f6d074d745a025de12dfbd1aa042b542393a240115022aa923122a}.png}
\caption{Examples of angular distributions (expansions in spherical harmonics \(Y_{L,M}\)), for a range of cases indexed by \(t\). Note that up\sphinxhyphen{}down asymmetry is associated with odd\sphinxhyphen{}\(l\) contributions (e.g. \(t=1,2\)), breaking of cylindrical symmetry with \(m\neq0\) terms (all \(t>0\)), and asymmetries in the (x,y) plane (skew/directionality) with different \(\pm m\) terms (magnitude or phase, e.g. \(t=2,3,4\)). Higher\sphinxhyphen{}order \(L,M\) terms have more nodes, and lead to more complex angular structures, as shown in the lower row (\(t=3,4,5\)).}\label{\detokenize{part1/theory_observables_intro_211122:fig-pads-example}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart
\begin{equation*}
\begin{split}\begin{tabular}{llrrrr}
\toprule
  & t &    0 &    1 &    2 &    3 \\
l & m &      &      &      &      \\
\midrule
0 &  0 &  1.0 &  1.0 &  1.0 &  1.0 \\
1 &  0 &  0.0 &  0.5 &  0.8 &  1.0 \\
2 &  0 &  1.0 &  0.5 &  0.0 &  0.0 \\
4 & -2 &  0.0 &  0.0 &  0.0 &  0.5 \\
  &  2 &  0.0 &  0.0 &  0.0 &  0.5 \\
\bottomrule
\end{tabular}\end{split}
\end{equation*}\caption{Values used for the plots in \hyperref[\detokenize{part1/theory_observables_intro_211122:fig-pads-example}]{Fig.\@ \ref{\detokenize{part1/theory_observables_intro_211122:fig-pads-example}}}.}\label{\detokenize{part1/theory_observables_intro_211122:blm-tab}}\end{figure}

\sphinxAtStartPar
In general, the spherical harmonic rank and order \((L,M)\) of Eq. \eqref{equation:part1/theory_observables_intro_211122:eq:AF-PAD-general} are constrained by experimental factors in the {\hyperref[\detokenize{backmatter/glossary:term-LF}]{\sphinxtermref{\DUrole{xref,std,std-term}{LF}}}} or {\hyperref[\detokenize{backmatter/glossary:term-AF}]{\sphinxtermref{\DUrole{xref,std,std-term}{AF}}}}, and \(n\) is effectively limited by the molecular alignment (which is correlated with the photon\sphinxhyphen{}order for gas phase experiments, or conservation of angular momentum in the {\hyperref[\detokenize{backmatter/glossary:term-LF}]{\sphinxtermref{\DUrole{xref,std,std-term}{LF}}}} more generally {[}\hyperlink{cite.backmatter/bibliography:id814}{35}{]}), but in the {\hyperref[\detokenize{backmatter/glossary:term-MF}]{\sphinxtermref{\DUrole{xref,std,std-term}{MF}}}} is defined by the maximum continuum angular momentum \(n=l_{max}\) imparted by the scattering event {[}\hyperlink{cite.backmatter/bibliography:id485}{36}{]} (note lower\sphinxhyphen{}case \(l\) here refers specifically to the continuum photoelectron wavefunction, see Eq. \eqref{equation:part1/theory_photoionization_dynamics_191122:eq:elwf}).

\sphinxAtStartPar
For basic cases these limits may be low: for instance, a simple 1\sphinxhyphen{}photon photoionization event (\(n=1\)) from an isotropic ensemble (zero net ensemble angular momentum) defines \(L_{max}=2\); for cylindrically symmetric cases (i.e. \(D_{\infty h}\) symmetry) \(M=0\) only. For {\hyperref[\detokenize{backmatter/glossary:term-MF}]{\sphinxtermref{\DUrole{xref,std,std-term}{MF}}}} cases, \(l_{max}=4\) is often given as a reasonable rule\sphinxhyphen{}of\sphinxhyphen{}thumb for the continuum \sphinxhyphen{} hence \(L_{max}=8\) \sphinxhyphen{} although in practice higher\sphinxhyphen{}\(l\) may be populated. Some realistic example cases are discussed later (\sphinxstylestrong{PART II}), see also ref. {[}\hyperlink{cite.backmatter/bibliography:id569}{1}{]} for more discussion and complex examples.

\sphinxAtStartPar
In general, these observables may also be dependent on various other parameters; in Eq. \eqref{equation:part1/theory_observables_intro_211122:eq:AF-PAD-general} two such parameters, \((\epsilon,t)\), are included, as the usual variables of interest. Usually \(\epsilon\) denotes the photoelectron energy, and \(t\) is used in the case of time\sphinxhyphen{}dependent (usually pump\sphinxhyphen{}probe) measurements. As discussed below (\hyperref[\detokenize{part1/theory_photoionization_dynamics_191122:sec-dynamics-intro}]{Sect.\@ \ref{\detokenize{part1/theory_photoionization_dynamics_191122:sec-dynamics-intro}}}), the origin of such dependencies may be complicated but, in general, the associated photoionization matrix elements are energy\sphinxhyphen{}dependent, and time\sphinxhyphen{}dependence may also appear for a number of intrinsic or extrinsic (experimental) reasons, e.g. electronic or nuclear dynamics, rotational (alignment) dynamics, electric field dynamics etc. In many cases only one particular aspect may be of interest, so \(t\) can be used as a generic label to index changes as per \hyperref[\detokenize{part1/theory_observables_intro_211122:fig-pads-example}]{Fig.\@ \ref{\detokenize{part1/theory_observables_intro_211122:fig-pads-example}}}.


\subsection{Symmetrized harmonics}
\label{\detokenize{part1/theory_observables_intro_211122:symmetrized-harmonics}}\label{\detokenize{part1/theory_observables_intro_211122:sec-theory-sym-harm-into}}
\sphinxAtStartPar
Symmetrized (or generalised) harmonics, which essentially provide correctly symmetrized expansions of spherical harmonics (\(Y_{LM}\)) functions for a given irreducible representation, \(\Gamma\), of the molecular point\sphinxhyphen{}group can be defined by linear combinations of spherical harmonics (Refs. {[}\hyperlink{cite.backmatter/bibliography:id421}{37}, \hyperlink{cite.backmatter/bibliography:id422}{38}, \hyperlink{cite.backmatter/bibliography:id459}{39}{]} as below):
\begin{equation}\label{equation:part1/theory_observables_intro_211122:eq:symHarm-defn}
\begin{split}
X_{hl}^{\Gamma\mu*}(\theta,\phi)=\sum_{\lambda}b_{hl\lambda}^{\Gamma\mu}Y_{l,\lambda}(\theta,\phi)
\end{split}
\end{equation}
\sphinxAtStartPar
where:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(\Gamma\) is an irreducible representation;

\item {} 
\sphinxAtStartPar
\((l, \lambda)\) define the usual spherical harmonic indices (rank, order), but note the use of \((l, \lambda)\) by convention, since these harmonics are usually referenced to the {\hyperref[\detokenize{backmatter/glossary:term-MF}]{\sphinxtermref{\DUrole{xref,std,std-term}{MF}}}};

\item {} 
\sphinxAtStartPar
\(b_{hl\lambda}^{\Gamma\mu}\) are symmetrization coefficients;

\item {} 
\sphinxAtStartPar
index \(\mu\) allows for indexing of degenerate components (note here the unfortunate convention that the label \(\mu\) is also used for photon projection terms in general, as per \hyperref[\detokenize{part1/theory_tensor_formalism_201122:sec-full-tensor-expansion}]{Sect.\@ \ref{\detokenize{part1/theory_tensor_formalism_201122:sec-full-tensor-expansion}}} \sphinxhyphen{} in ambiguous cases the symmetrization term will instead be labelled as \(\mu_X\), although in many cases may actually be redundant and safely dropped from the symmetrization coefficients);

\item {} 
\sphinxAtStartPar
\(h\) indexes cases where multiple components are required with all other quantum numbers identical.

\end{itemize}

\sphinxAtStartPar
Analogously to Eq. \eqref{equation:part1/theory_observables_intro_211122:eq:AF-PAD-general}, a general expansion of an observable in the symmetrized harmonic basis set can then be defined as:
\begin{equation}\label{equation:part1/theory_observables_intro_211122:eq:AF-PAD-general-symHarm}
\begin{split}
\bar{I}^{\Gamma}(\epsilon,t,\theta,\phi) = \sum_{\Gamma\mu hl}\bar{\beta}_{hl}^{\Gamma\mu}(\epsilon,t)X_{hl}^{\Gamma\mu*}(\theta,\phi)
\end{split}
\end{equation}
\sphinxAtStartPar
Alternatively, by substitution into Eq. \eqref{equation:part1/theory_observables_intro_211122:eq:AF-PAD-general}, and assigning \(l=L\) and \(\lambda=M\), a general symmetrized expansion may also be defined as:
\begin{equation}\label{equation:part1/theory_observables_intro_211122:eq:AF-PAD-general-symHarm-subs}
\begin{split}
\begin{align}
\bar{I}(\epsilon,t,\theta,\phi)=\sum_{\Gamma\mu h}\sum_{L=0}^{2n}\sum_{M=-L}^{L}b_{hLM}^{\Gamma\mu}\bar{\beta}_{L,M}(\epsilon,t)Y_{L,M}(\theta,\phi)
\end{align}
\end{split}
\end{equation}
\sphinxAtStartPar
However, in many cases the symmetrization coefficients are subsumed into the \(\beta_{L,M}\) terms (or underlying matrix elements); in this case a simplified symmetrized expansion can be defined as:
\begin{equation}\label{equation:part1/theory_observables_intro_211122:eq:AF-PAD-general-sym-betas}
\begin{split}
\begin{align}
\bar{I}^{\Gamma}(\epsilon,t,\theta,\phi)=\sum_{L=0}^{2n}\sum_{M=-L}^{L}\bar{\beta}^{\Gamma}_{L,M}(\epsilon,t)Y_{L,M}(\theta,\phi)
\end{align}
\end{split}
\end{equation}
\sphinxAtStartPar
Where the expansion is defined for a given symmetry and irreducible representation with the shorthand \(\Gamma\); in many systems a single label may be sufficient here, since allowed \((L,M)\) terms will be defined uniquely by irreducible representation, although multiple quantum numbers may be required for unique definition in the most general cases as per Eq. \eqref{equation:part1/theory_observables_intro_211122:eq:symHarm-defn} (e.g. for cases with degenerate components). Further details and usage in relation to channel functions are also discussed in \hyperref[\detokenize{part1/theory_tensor_formalism_201122:sec-tensor-formulation}]{Sect.\@ \ref{\detokenize{part1/theory_tensor_formalism_201122:sec-tensor-formulation}}} (see, in particular, Eq. \eqref{equation:part1/theory_tensor_formalism_201122:eqn:channel-fns} for a similar general case), and in relation to fitting for specific cases in \sphinxstylestrong{PART II}.

\sphinxAtStartPar
The exact form of these coefficients will depend on the point\sphinxhyphen{}group of the system, see, e.g. Refs. {[}\hyperlink{cite.backmatter/bibliography:id459}{39}, \hyperlink{cite.backmatter/bibliography:id696}{40}{]}. Numerical routines for the generation of symmetrized harmonics are implemented in \sphinxhref{https://github.com/phockett/PEMtk}{Photoelectron Metrology Toolkit} {[}\hyperlink{cite.backmatter/bibliography:id574}{4}{]}: point\sphinxhyphen{}groups, character table generation and symmetrization (computing \(b_{hl\lambda}^{\Gamma\mu}\) parameters) is handled by \sphinxhref{https://github.com/mcodev31/libmsym}{libmsym} {[}\hyperlink{cite.backmatter/bibliography:id593}{33}, \hyperlink{cite.backmatter/bibliography:id594}{34}{]}; additional handling also makes use of \sphinxhref{https://shtools.oca.eu}{pySHtools} {[}\hyperlink{cite.backmatter/bibliography:id800}{29}, \hyperlink{cite.backmatter/bibliography:id740}{30}{]}.

\sphinxAtStartPar
A brief numerical example is given below, for \DUrole{pasted-text}{Td} symmetry (\(l_{max}=\)\DUrole{pasted-text}{6}), and more details can be found in the \sphinxhref{https://pemtk.readthedocs.io}{PEMtk documentation} {[}\hyperlink{cite.backmatter/bibliography:id573}{11}{]}. In this case, full tabulations of the parameters lists all \(b_{hLM}^{\Gamma\mu}\) for each irreducible representation, and the corresponding PADs are illustrated in \hyperref[\detokenize{part1/theory_observables_intro_211122:fig-symharmpads-example}]{Fig.\@ \ref{\detokenize{part1/theory_observables_intro_211122:fig-symharmpads-example}}}.

\begin{sphinxShadowBox}
\sphinxstylesidebartitle{}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Full tabulations of the parameters available in HTML or notebook formats only.
\end{sphinxadmonition}
\end{sphinxShadowBox}

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-output}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Import class}
\PYG{k+kn}{from} \PYG{n+nn}{pemtk}\PYG{n+nn}{.}\PYG{n+nn}{sym}\PYG{n+nn}{.}\PYG{n+nn}{symHarm} \PYG{k+kn}{import} \PYG{n}{symHarm}

\PYG{c+c1}{\PYGZsh{} Compute hamronics for Td, lmax=4}
\PYG{n}{sym} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Td}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{lmax}\PYG{o}{=}\PYG{l+m+mi}{6}

\PYG{n}{symObj} \PYG{o}{=} \PYG{n}{symHarm}\PYG{p}{(}\PYG{n}{sym}\PYG{p}{,}\PYG{n}{lmax}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Character tables can be displayed \PYGZhy{} this will render directly in a notebook.}
\PYG{n}{symObj}\PYG{o}{.}\PYG{n}{printCharacterTable}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Glue items for later}
\PYG{n}{glue}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{symHarmPG}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{sym}\PYG{p}{,} \PYG{n}{display}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\PYG{n}{glue}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{symHarmLmax}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{lmax}\PYG{p}{,} \PYG{n}{display}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\PYG{n}{glue}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{charTab}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{symObj}\PYG{o}{.}\PYG{n}{printCharacterTable}\PYG{p}{(}\PYG{n}{returnPD}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}\PYG{p}{,} \PYG{n}{display}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} As above, but with PD object return and glue.}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{figure}[htbp]
\centering
\capstart
\begin{equation*}
\begin{split}\begin{tabular}{lllllll}
\toprule
   &   &    E &  C2\textasciicircum 1 &  S4\textasciicircum 1 &    σd &  C3\textasciicircum 1 \\
Character & dim &      &       &       &       &       \\
\midrule
A1 & 1 &  1.0 &   1.0 &   1.0 &   1.0 &   1.0 \\
A2 & 1 &  1.0 &   1.0 &  -1.0 &  -1.0 &   1.0 \\
E & 2 &  2.0 &   2.0 &   0.0 &   0.0 &  -1.0 \\
T1 & 3 &  3.0 &  -1.0 &   1.0 &  -1.0 &   0.0 \\
T2 & 3 &  3.0 &  -1.0 &  -1.0 &   1.0 &   0.0 \\
\bottomrule
\end{tabular}\end{split}
\end{equation*}\caption{Example character table for \DUrole{pasted-text}{Td} symmetry generated with the \sphinxhref{https://github.com/phockett/PEMtk}{Photoelectron Metrology Toolkit} {[}\hyperlink{cite.backmatter/bibliography:id574}{4}{]} wrapper for \sphinxhref{https://github.com/mcodev31/libmsym}{libmsym} {[}\hyperlink{cite.backmatter/bibliography:id593}{33}, \hyperlink{cite.backmatter/bibliography:id594}{34}{]}.}\label{\detokenize{part1/theory_observables_intro_211122:tab-chartable-example}}\end{figure}

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-output}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} The full set of expansion parameters can be tabulated}

\PYG{c+c1}{\PYGZsh{} pd.set\PYGZus{}option(\PYGZsq{}display.max\PYGZus{}rows\PYGZsq{}, 100)}

\PYG{n}{symObj}\PYG{o}{.}\PYG{n}{displayXlm}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Display values (note this defaults to REAL harmonics)}
\PYG{c+c1}{\PYGZsh{} symObj.displayXlm(YlmType=\PYGZsq{}comp\PYGZsq{})   \PYGZsh{} Display values for COMPLEX harmonic expansion.}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-output}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} To plot using ePSproc/PEMtk class, these values can be converted to ePSproc BLM data type...}

\PYG{c+c1}{\PYGZsh{} Run conversion \PYGZhy{} the default is to set the coeffs to the \PYGZsq{}BLM\PYGZsq{} data type}
\PYG{n}{symObj}\PYG{o}{.}\PYG{n}{toePSproc}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Set to new key in data class}
\PYG{n}{data}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{symHarm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

\PYG{k}{for} \PYG{n}{dataType} \PYG{o+ow}{in} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{BLM}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{:}  \PYG{c+c1}{\PYGZsh{}[\PYGZsq{}matE\PYGZsq{},\PYGZsq{}BLM\PYGZsq{}]:}
    \PYG{n}{data}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{symHarm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{dataType}\PYG{p}{]} \PYG{o}{=} \PYG{n}{symObj}\PYG{o}{.}\PYG{n}{coeffs}\PYG{p}{[}\PYG{n}{dataType}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b (comp)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} Select expansion in complex harmonics}
    \PYG{n}{data}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{symHarm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{dataType}\PYG{p}{]}\PYG{o}{.}\PYG{n}{attrs} \PYG{o}{=} \PYG{n}{symObj}\PYG{o}{.}\PYG{n}{coeffs}\PYG{p}{[}\PYG{n}{dataType}\PYG{p}{]}\PYG{o}{.}\PYG{n}{attrs}
    
\PYG{c+c1}{\PYGZsh{} Plot full harmonics expansions, plots by symmetry}
\PYG{c+c1}{\PYGZsh{} Note \PYGZsq{}squeeze=True\PYGZsq{} to force drop of singleton dims may be required.}
\PYG{c+c1}{\PYGZsh{} data.padPlot(keys=\PYGZsq{}symHarm\PYGZsq{},dataType=\PYGZsq{}BLM\PYGZsq{}, facetDims = [\PYGZsq{}Cont\PYGZsq{}], squeeze = True, backend=plotBackend)}

\PYG{n}{rc} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} Explict layout setting}
\PYG{n}{data}\PYG{o}{.}\PYG{n}{padPlot}\PYG{p}{(}\PYG{n}{keys}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{symHarm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{dataType}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{BLM}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{facetDims} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cont}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{squeeze} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{backend}\PYG{o}{=}\PYG{n}{plotBackend}\PYG{p}{,} \PYG{n}{rc} \PYG{o}{=} \PYG{n}{rc}\PYG{p}{,} \PYG{n}{plotFlag}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{returnFlag}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Working}
\PYG{n}{figObj} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{symHarm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{plots}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{BLM}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{polar}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} And GLUE for display later with caption}
\PYG{c+c1}{\PYGZsh{} from myst\PYGZus{}nb import glue}
\PYG{c+c1}{\PYGZsh{} glue(\PYGZdq{}padExamplePlot2\PYGZdq{}, figObj, display=False);}
\PYG{n}{gluePlotly}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{symHarmPADs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{figObj}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{2761c00d3b9766092516663fd674aed92f287503c4cbe62eda3ded917e537df3}.png}
\caption{Examples of angular distributions from expansions in symmetrized harmonics \(X_{hl}^{\Gamma\mu*}(\theta,\phi)\), for all irreducible representations in \DUrole{pasted-text}{Td} symmetry (\(l_{max}=\)\DUrole{pasted-text}{6}). (Note \(A_2\) only has components for \(l\geq 6\).)}\label{\detokenize{part1/theory_observables_intro_211122:fig-symharmpads-example}}
\begin{sphinxlegend}\end{sphinxlegend}
\end{figure}


\subsection{Real harmonics}
\label{\detokenize{part1/theory_observables_intro_211122:real-harmonics}}

\subsection{Legendre polynomials}
\label{\detokenize{part1/theory_observables_intro_211122:legendre-polynomials}}
\sphinxstepscope


\section{Photoionization dynamics}
\label{\detokenize{part1/theory_photoionization_dynamics_191122:photoionization-dynamics}}\label{\detokenize{part1/theory_photoionization_dynamics_191122:sec-dynamics-intro}}\label{\detokenize{part1/theory_photoionization_dynamics_191122::doc}}
\sphinxAtStartPar
The core physics of photoionization has been covered extensively in the literature, and only a very brief overview is provided here with sufficient detail to introduce the metrology/reconstruction/retrieval problem; the reader is referred to Vol. 1 {[}\hyperlink{cite.backmatter/bibliography:id569}{1}{]} (and refs. therein) for further details and general discussion.

\sphinxAtStartPar
Photoionization can be described by the coupling of an initial state of the system to a particular final state (photoion(s) plus free photoelectron(s)), coupled by an electric field/photon. Very generically, this can be written as a matrix element \(\langle\Psi_i|\hat{\Gamma}(\boldsymbol{\mathbf{E}})|\Psi_f\rangle\), where \(\hat{\Gamma}(\boldsymbol{\mathbf{E}})\) defines the light\sphinxhyphen{}matter coupling operator (depending on the electric field \(\boldsymbol{\mathbf{E}}\)), and \(\Psi_i\), \(\Psi_f\) the total wavefunctions of the initial and final states respectively.

\sphinxAtStartPar
There are many flavours of this fundamental light\sphinxhyphen{}matter interaction, depending on system and coupling. For metrology, the focus is currently on the simplest case of single\sphinxhyphen{}photon absorption, in the weak field (or purturbative), dipolar regime, resulting in a single photoelectron. (For more discussion of various approximations in photoionzation, see Refs. {[}\hyperlink{cite.backmatter/bibliography:id736}{41}, \hyperlink{cite.backmatter/bibliography:id735}{42}{]}.) In this case the core physics is well defined, and tractable (albeit non\sphinxhyphen{}trivial), via the separation of matrix elements into radial (energy) and angular\sphinxhyphen{}momentum (geometric) terms pertaining to couplings between various elements of the problem; the retrieval of such matrix elements is a well\sphinxhyphen{}defined problem, making use of analytic terms in combination with fitting methodologies as explored herein. Again, more extensive background and discussion can be found in \sphinxstyleemphasis{Quantum Metrology} Vol. 1 {[}\hyperlink{cite.backmatter/bibliography:id569}{1}{]}, and references therein. \% {[}TODO: Add some more refs here?{]}

\sphinxAtStartPar
The basic case also provides a strong foundation for extension into more complex light\sphinxhyphen{}matter interactions, in particular cases with shaped laser\sphinxhyphen{}fields (i.e. a time\sphinxhyphen{}dependent coupling \(\hat{\Gamma}(\boldsymbol{\mathbf{E,t}})\)) and multi\sphinxhyphen{}photon processes (which require multiple matrix elements, and/or different approximations). Note, however, that non\sphinxhyphen{}perturbative (strong field) light\sphinxhyphen{}matter interactions are, typically, not amenable to description in a separable picture in this manner. In such cases the laser field, molecular and continuum properties are strongly coupled, and are typically treated numerically in a fully time\sphinxhyphen{}dependent manner (although some separation of terms may work in some cases, depending on the system and interaction(s) at hand).

\sphinxAtStartPar
Underlying the photoelecton observables is the photoelectron continuum state \(\left|\mathbf{k}\right>\), prepared via photoionization. The photoelectron momentum vector is denoted generally by
\(\boldsymbol{\mathbf{k}}=k\mathbf{\hat{k}}\), in the molecular frame ({\hyperref[\detokenize{backmatter/glossary:term-MF}]{\sphinxtermref{\DUrole{xref,std,std-term}{MF}}}}). The ionization matrix elements associated with this transition provide the set of quantum amplitudes completely defining the final continuum scattering state,
\begin{equation}\label{equation:part1/theory_photoionization_dynamics_191122:eq:continuum-state-vec}
\begin{split}\left|\Psi_f\right> = \sum{\int{\left|\Psi_{+};\bf{k}\right>\left<\Psi_{+};\mathbf{k}|\Psi_f\right> d\bf{k}}},
\end{split}
\end{equation}
\sphinxAtStartPar
where the sum is over states of the molecular ion \(\left|\Psi_{+}\right>\). The number of ionic states accessed depends on the nature of the ionizing pulse and interaction. For the dipolar case,
\begin{equation}\label{equation:part1/theory_photoionization_dynamics_191122:eq:def-dipole-operator}
\begin{split}\hat{\Gamma}(\boldsymbol{\mathbf{E}}) = \hat{\boldsymbol{\mu}}.\boldsymbol{\mathbf{E}}\end{split}
\end{equation}
\sphinxAtStartPar
Hence,
\begin{equation}\label{equation:part1/theory_photoionization_dynamics_191122:eq:matE-dipole}
\begin{split}\left<\Psi_{+};\mathbf{k}|\Psi_f\right> =\langle\Psi_{+};\,\mathbf{k}|\hat{\boldsymbol{\mu}}.\boldsymbol{\mathbf{E}}|\Psi_{i}\rangle
\end{split}
\end{equation}
\sphinxAtStartPar
Where the notation implies a perturbative photoionization event from an initial state \(i\) to a particular ion plus electron state following absorption of a photon \(h\nu\), \(|\Psi_{i}\rangle+h\nu{\rightarrow}|\Psi_{+};\boldsymbol{\mathbf{k}}\rangle\), and \(\hat{\mu}.\boldsymbol{\mathbf{E}}\) is the usual dipole interaction term {[}\hyperlink{cite.backmatter/bibliography:id690}{43}{]}, which includes a sum over all electrons \(s\) defined in position space as \(\mathbf{r_{s}}\):
\begin{equation}\label{equation:part1/theory_photoionization_dynamics_191122:eq:dipole-operator}
\begin{split}\hat{\mu}=-e\sum_{s}\mathbf{r_{s}}
\end{split}
\end{equation}
\sphinxAtStartPar
The position space photoelectron wavefunction is typically expressed in
the “partial wave” basis, expanded as (asymptotic) continuum
eignstates of orbital angular momentum, with angular momentum components
\((l,m)\) (note lower case notation for the partial wave components, distinct from upper\sphinxhyphen{}case for the similar terms \((L,M)\) in the observables),
\begin{equation}\label{equation:part1/theory_photoionization_dynamics_191122:eq:elwf}
\begin{split}\Psi_\mathbf{k}(\boldsymbol{r})\equiv\left<\boldsymbol{r}|\mathbf{k}\right> = \sum_{lm}Y_{lm}(\mathbf{\hat{k}})\psi_{lm}(\boldsymbol{r},k)
\end{split}
\end{equation}
\sphinxAtStartPar
where \(\boldsymbol{r}\) are MF electronic coordinates and
\(Y_{lm}(\mathbf{\hat{k}})\) are the spherical harmonics.

\sphinxAtStartPar
Similarly, the ionization dipole matrix elements can be separated
generally into radial (energy\sphinxhyphen{}dependent or ‘dynamical’ terms) and
geometric (angular momentum) parts (this separation is essentially the
Wigner\sphinxhyphen{}Eckart Theorem, see Ref. {[}\hyperlink{cite.backmatter/bibliography:id824}{44}{]} for general discussion),
and written generally as (using notation similar to {[}\hyperlink{cite.backmatter/bibliography:id694}{45}{]}):
\begin{equation}\label{equation:part1/theory_photoionization_dynamics_191122:eq:r-kllam}
\begin{split}\langle\Psi_{+};\,\mathbf{k}|\hat{\boldsymbol{\mu}}.\boldsymbol{\mathbf{E}}|\Psi_{i}\rangle = \sum_{lm}\gamma_{l,m}\mathbf{r}_{k,l,m}
\end{split}
\end{equation}
\sphinxAtStartPar
Provided that the geometric part of the matrix elements \(\gamma_{l,m}\) \sphinxhyphen{}
which includes the geometric rotations into the LF arising from the dot
product in Eq. \eqref{equation:part1/theory_photoionization_dynamics_191122:eq:r-kllam} and other angular\sphinxhyphen{}momentum coupling terms \sphinxhyphen{} are
know, knowledge of the so\sphinxhyphen{}called radial (or reduced) dipole matrix
elements, at a given \(k\) thus equates to a full description of the
system dynamics (and, hence, the observables).

\sphinxAtStartPar
For the simplest treatment, the radial matrix element can be
approximated as a 1\sphinxhyphen{}electron integral involving the initial electronic
state (orbital), and final continuum photoelectron wavefunction:
\begin{equation}\label{equation:part1/theory_photoionization_dynamics_191122:eq:r-kllam-integral}
\begin{split}\mathbf{r}_{k,l,m}=\int\psi_{lm}(\boldsymbol{r},k)\boldsymbol{r}\Psi_{i}(\boldsymbol{r})d\boldsymbol{r}
\end{split}
\end{equation}
\sphinxAtStartPar
As noted above, the geometric terms \(\gamma_{l,m}\) are analytical
functions which can be computed for a given case \sphinxhyphen{} minimally requiring
knowledge of the molecular symmetry and polarization geometry, although
other factors may also play a role (see \hyperref[\detokenize{part1/theory_tensor_formalism_201122:sec-full-tensor-expansion}]{Sect.\@ \ref{\detokenize{part1/theory_tensor_formalism_201122:sec-full-tensor-expansion}}} for details).

\sphinxAtStartPar
The photoelectron angular distribution (PAD) at a given \((\epsilon,t)\)
can then be determined by the squared projection of
\(\left|\Psi_f\right>\) onto a specific state
\(\left|\Psi_{+};\bf{k}\right>\); very generally this can be written in terms of the energy and angle\sphinxhyphen{}resolved observable, which arises as the coherent square:
\begin{equation}\label{equation:part1/theory_photoionization_dynamics_191122:eq:matE-sq-general}
\begin{split}
I(\epsilon,\theta,\phi)=\langle\Psi_{f}|\Psi_{f}\rangle
\end{split}
\end{equation}
\sphinxAtStartPar
Expansion in terms of the components of the matrix elements as detailed above then yields a separation into radial and angular components (see \sphinxstyleemphasis{Quantum Metrology} Vol. 1 {[}\hyperlink{cite.backmatter/bibliography:id569}{1}{]}, Sect. 2.1 for a full derivation), which can be written (at a single energy) as (following Eq. 2.45 of \sphinxstyleemphasis{Quantum Metrology} Vol. 1 {[}\hyperlink{cite.backmatter/bibliography:id569}{1}{]}):
\begin{equation}\label{equation:part1/theory_photoionization_dynamics_191122:eq:I-reduced-LF-2_45-vol1}
\begin{split}
I(\theta,\phi;\,k)=\sum_{ll'}\sum_{\lambda\lambda'}\sum_{mm'}\gamma_{\alpha\alpha_{+}l\lambda ml'\lambda'm'}\boldsymbol{r}_{kl\lambda}\boldsymbol{r}_{kl'\lambda'}e^{i(\eta_{l\lambda}(k)-\eta_{l'\lambda'}(k))}Y_{lm}(\hat{k})Y_{l'm'}^{*}(\hat{k})
\end{split}
\end{equation}
\sphinxAtStartPar
In this form \(\alpha\) denotes all other quantum numbers required to define the initial state, and \(\alpha_{+}\) the final state of the molecular ion. The radial matrix elements \(\boldsymbol{r}_{kl\lambda}\), denote an integral over the radial part of the wavefunctions, in this case labelled by the {\hyperref[\detokenize{backmatter/glossary:term-MF}]{\sphinxtermref{\DUrole{xref,std,std-term}{MF}}}} quantum numbers, and the associated scattering phase is given by \(\eta_{l\lambda}(k)\) (i.e. the matrix elements are written in magnitude\sphinxhyphen{}phase form, rather than complex form).The \(\gamma\) terms denotes a general set of geometric paramters arising from the coherent square.  A tensor form is also given herein, see \hyperref[\detokenize{part1/theory_tensor_formalism_201122:sec-full-tensor-expansion}]{Sect.\@ \ref{\detokenize{part1/theory_tensor_formalism_201122:sec-full-tensor-expansion}}}, including a full breakdown of these terms and numerical implementation. Comparison with Eq. \eqref{equation:part1/theory_observables_intro_211122:eq:AF-PAD-general} then indicates that the amplitudes
in Eq. \eqref{equation:part1/theory_photoionization_dynamics_191122:eq:r-kllam} also determine the observable anisotropy
parameters \(\beta_{L,M}(\epsilon,t)\) (Eqn.
\eqref{equation:part1/theory_observables_intro_211122:eq:AF-PAD-general}), which basically collect all the terms in Eq. \eqref{equation:part1/theory_photoionization_dynamics_191122:eq:I-reduced-LF-2_45-vol1} and the product over spherical harmonics, into a result set of \((L,M)\). (Note that the photoelectron energy
\(\epsilon\) and momentum \(k\) are used somewhat interchangeably herein,
with the former usually preferred in reference to observables.)

\sphinxAtStartPar
Note, also, that in the treatment above there is no time\sphinxhyphen{}dependence
incorporated in the notation; however, a time\sphinxhyphen{}dependent treatment
readily follows, and may be incorporated either as explicit
time\sphinxhyphen{}dependent modulations in the expansion of the wavefunctions for a
given case, or implicitly in the radial matrix elements. Examples of the
former include, e.g. a rotational or vibrational wavepacket, or a
time\sphinxhyphen{}dependent laser field. The rotational wavepacket case is discussed
herein (see \hyperref[\detokenize{part1/theory_tensor_formalism_201122:sec-full-tensor-expansion}]{Sect.\@ \ref{\detokenize{part1/theory_tensor_formalism_201122:sec-full-tensor-expansion}}}). The radial matrix elements are
a sensitive function of molecular geometry and electronic configuration
in general, hence may be considered to be responsive to molecular
dynamics, although they are formally time\sphinxhyphen{}independent in a
Born\sphinxhyphen{}Oppenheimer basis \sphinxhyphen{} for further general discussion and examples see
Ref. {[}\hyperlink{cite.backmatter/bibliography:id809}{46}{]} and \sphinxstyleemphasis{Quantum Metrology} Vol. 1 {[}\hyperlink{cite.backmatter/bibliography:id569}{1}{]}; discussions of more
complex cases with electronic and nuclear dynamics can be found in Refs.
{[}\hyperlink{cite.backmatter/bibliography:id735}{42}, \hyperlink{cite.backmatter/bibliography:id424}{47}, \hyperlink{cite.backmatter/bibliography:id758}{48}, \hyperlink{cite.backmatter/bibliography:id756}{49}{]}.

\sphinxAtStartPar
Typically, for reconstruction experiments, a given measurement will be
selected to simplify this as much as possible by, e.g., populating only
a single ionic state (or states for which the corresponding observables
are experimentally energetically\sphinxhyphen{}resolvable), and with a bandwidth
\(d\bf{k}\) which is small enough such that the matrix elements can be
assumed constant over the observation window. Importantly, the angle\sphinxhyphen{}resolved observables are
sensitive to the magnitudes and (relative) phases of these matrix
elements \sphinxhyphen{} as emphasised in the magnitude\sphinxhyphen{}phase form of Eq. \eqref{equation:part1/theory_photoionization_dynamics_191122:eq:I-reduced-LF-2_45-vol1} \sphinxhyphen{} and can be considered as angular interferograms.

\sphinxstepscope


\section{Tensor formulation of photoionization}
\label{\detokenize{part1/theory_tensor_formalism_201122:tensor-formulation-of-photoionization}}\label{\detokenize{part1/theory_tensor_formalism_201122:sec-tensor-formulation}}\label{\detokenize{part1/theory_tensor_formalism_201122::doc}}
\sphinxAtStartPar
A number of authors have treated MFPADs and related problems {[}REFS{]}; herein, a geometric tensor based formalism is developed, which is close in spirit to the treatments given by Underwood and co\sphinxhyphen{}workers {[}\hyperlink{cite.backmatter/bibliography:id756}{49}, \hyperlink{cite.backmatter/bibliography:id698}{50}, \hyperlink{cite.backmatter/bibliography:id785}{51}{]}, but further separates various sets of physical parameters into dedicated tensors; this allows for a unified theoretical and numerical treatment, where the latter computes properties as tensor variables which can be further manipulated and investigated. Furthermore, the tensors can readily be converted to a density matrix representation {[}\hyperlink{cite.backmatter/bibliography:id824}{44}, \hyperlink{cite.backmatter/bibliography:id444}{52}{]}, which is more natural for some quantities, and also emphasizes the link to quantum state tomography and other quantum information techniques. Much of the theoretical background, as well as application to aspects of the current problem, can be found in the textbooks of Blum {[}\hyperlink{cite.backmatter/bibliography:id444}{52}{]}
and Zare {[}\hyperlink{cite.backmatter/bibliography:id824}{44}{]}.

\sphinxAtStartPar
Within this treatment, the observables can be defined in a series of simplified forms, emphasizing the quantities of interest for a given problem. Some details are defined in the following subsections,


\subsection{Channel functions}
\label{\detokenize{part1/theory_tensor_formalism_201122:channel-functions}}\label{\detokenize{part1/theory_tensor_formalism_201122:sec-channel-funcs}}
\sphinxAtStartPar
A simple form of the equations (cf. the general form of Eq. \eqref{equation:part1/theory_photoionization_dynamics_191122:eq:I-reduced-LF-2_45-vol1}, see also \sphinxstyleemphasis{Quantum Metrology} Vol. 2 {[}\hyperlink{cite.backmatter/bibliography:id570}{2}{]} Chpt. 12), amenable to fitting and numerical implementation, is to write the observables in terms of “channel functions”, which define the ionization continuum for a given case and set of parameters \(u\) (e.g. defined for the MF, or defined for a specific experimental configuration),
\begin{equation}\label{equation:part1/theory_tensor_formalism_201122:eqn:channel-fns}
\begin{split}\beta_{L,M}^{u}=\sum_{\zeta,\zeta'}\varUpsilon_{L,M}^{u,\zeta\zeta'}\mathbb{I}^{\zeta\zeta'}\end{split}
\end{equation}
\sphinxAtStartPar
Where \(\zeta,\zeta'\) collect all the required quantum numbers, and
define all (coherent) pairs of components. The term
\(\mathbb{I}^{\zeta\zeta'}\) denotes the coherent square of the ionization
matrix elements:
\begin{equation}\label{equation:part1/theory_tensor_formalism_201122:eqn:I-zeta}
\begin{split}\mathbb{I}^{\zeta,\zeta}=I^{\zeta}(\epsilon)I^{\zeta'*}(\epsilon)
\end{split}
\end{equation}
\sphinxAtStartPar
This is effectively a convolution equation (cf. refs. {[}\hyperlink{cite.backmatter/bibliography:id698}{50}, \hyperlink{cite.backmatter/bibliography:id535}{53}{]}) with channel functions \(\varUpsilon_{L,M}^{u,\zeta\zeta'}\), for a given “experiment” \(u\), summed over all terms \(\zeta,\zeta'\). Aside from the change in notation (which is here chosen to match the formalism of Refs. {[}\hyperlink{cite.backmatter/bibliography:id640}{15}, \hyperlink{cite.backmatter/bibliography:id527}{16}, \hyperlink{cite.backmatter/bibliography:id671}{17}{]}),

\sphinxAtStartPar
these matrix elements are essentially identical to the simplified (radial) forms
\(\mathbf{r}_{k,l,m}\) defined in Eqn. \eqref{equation:part1/theory_photoionization_dynamics_191122:eq:r-kllam}, in the case where \(\zeta=k,l,m\). Note, also, that the matrix elements used herein are usually assumed to be symmetrized (unless explicitly stated), i.e. expanded in spherical harmonics per Eq. \eqref{equation:part1/theory_observables_intro_211122:eq:symHarm-defn} with any additional terms \(b_{hl\lambda}^{\Gamma\mu}\) incorporated into the value of the matrix elements.

\sphinxAtStartPar
These complex matrix elements can also be equivalently defined in a magnitude, phase
form:
\begin{equation}\label{equation:part1/theory_tensor_formalism_201122:eqn:I-zeta-mag-phase}
\begin{split}I^{\zeta}(\epsilon)\equiv\mathbf{r}_{\zeta}\equiv r_{\zeta}e^{i\phi_{\zeta}}\end{split}
\end{equation}
\sphinxAtStartPar
This tensorial form is numerically implemented in the \sphinxhref{https://github.com/phockett/ePSproc}{ePSproc} {[}\hyperlink{cite.backmatter/bibliography:id508}{13}{]} codebase, and is in contradistinction to standard numerical routines in which the requisite terms are usually computed from vectorial and/or nested summations, which can be somewhat opaque to
detailed interpretation, and typically implement the full computation of the observables in one monolithic computational routine. The \sphinxhref{https://github.com/phockett/PEMtk}{Photoelectron Metrology Toolkit} {[}\hyperlink{cite.backmatter/bibliography:id574}{4}{]} codebase implements matrix element retrieval based on the tensor formalism, with pre\sphinxhyphen{}computation of all the geometric tensor components (channel functions) prior to a fitting protocol for matrix element analysis, essentially a fit to Eqn. \eqref{equation:part1/theory_tensor_formalism_201122:eqn:channel-fns}, with terms \(I^{\zeta}(\epsilon)\) as the unknowns (in magnitude, phase form per \eqref{equation:part1/theory_tensor_formalism_201122:eqn:I-zeta-mag-phase}). The main computational cost of a tensor\sphinxhyphen{}based approach is that more RAM is required to store the full set of tensor variables; however, the method is computationally efficient since it is inherently parallel (as compared to a traditional, serial loop\sphinxhyphen{}based solution), hence may lead to significantly faster evaluation of observables. Furthermore, the method allows for the computational routines to match the formalism quite closely, and investigation of the properties of the channel functions for a given problem in general terms, as well as for specific experimental cases.


\subsection{Full tensor expansion}
\label{\detokenize{part1/theory_tensor_formalism_201122:full-tensor-expansion}}\label{\detokenize{part1/theory_tensor_formalism_201122:sec-full-tensor-expansion}}
\sphinxAtStartPar
In more detail, the channel functions \(\varUpsilon_{L,M}^{u,\zeta\zeta'}\) can be given as a set of tensors, defining each aspect of the problem. The following equations illustrate this for the {\hyperref[\detokenize{backmatter/glossary:term-MF}]{\sphinxtermref{\DUrole{xref,std,std-term}{MF}}}} and {\hyperref[\detokenize{backmatter/glossary:term-LF}]{\sphinxtermref{\DUrole{xref,std,std-term}{LF}}}}/{\hyperref[\detokenize{backmatter/glossary:term-AF}]{\sphinxtermref{\DUrole{xref,std,std-term}{AF}}}} cases, fully expanding the general form of Eq. \eqref{equation:part1/theory_tensor_formalism_201122:eqn:channel-fns} in terms of the relevant tensors. Further details and numerical examples are given in the following sub\sphinxhyphen{}sections.

\sphinxAtStartPar
For the MF:
\begin{equation}\label{equation:part1/theory_tensor_formalism_201122:eq:BLM-tensor-MF}
\begin{split}\begin{aligned}
\beta_{L,-M}^{\mu_{i},\mu_{f}}(\epsilon) & = & (-1)^{M}\sum_{P,R',R}{[P]^{\frac{1}{2}}}{E_{P-R}(\hat{e};\mu_{0})}\\
 & \times &\sum_{l,m,\mu}\sum_{l',m',\mu'}(-1)^{(\mu'-\mu_{0})}{\Lambda_{R',R}(R_{\hat{n}};\mu,P,R,R')B_{L,-M}(l,l',m,m')}\\
 & \times & I_{l,m,\mu}^{p_{i}\mu_{i},p_{f}\mu_{f}}(\epsilon)I_{l',m',\mu'}^{p_{i}\mu_{i},p_{f}\mu_{f}*}(\epsilon)\end{aligned}\end{split}
\end{equation}
\sphinxAtStartPar
And the LF/AF as:
\begin{equation}\label{equation:part1/theory_tensor_formalism_201122:eq:BLM-tensor-AF}
\begin{split}\begin{aligned}
\bar{\beta}_{L,-M}^{\mu_{i},\mu_{f}}(E,t) & = & (-1)^{M}\sum_{P,R',R}{[P]^{\frac{1}{2}}}{E_{P-R}(\hat{e};\mu_{0})}\\
 & \times &\sum_{l,m,\mu}\sum_{l',m',\mu'}(-1)^{(\mu'-\mu_{0})}{\bar{\Lambda}_{R'}(\mu,P,R')B_{L,S-R'}(l,l',m,m')}\\
 & \times &I_{l,m,\mu}^{p_{i}\mu_{i},p_{f}\mu_{f}}(\epsilon)I_{l',m',\mu'}^{p_{i}\mu_{i},p_{f}\mu_{f}*}(\epsilon)\sum_{K,Q,S}\Delta_{L,M}(K,Q,S)A_{Q,S}^{K}(t)\end{aligned}\end{split}
\end{equation}
\sphinxAtStartPar
In both cases a set of geometric tensor terms are required,

\sphinxAtStartPar
these terms provide details of:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\({E_{P-R}(\hat{e};\mu_{0})}\): polarization geometry \& coupling with
the electric field.

\item {} 
\sphinxAtStartPar
\(B_{L,M}(l,l',m,m')\): geometric coupling of the partial waves into the \(\beta_{L,M}\) terms (spherical tensors). Note for the {\hyperref[\detokenize{backmatter/glossary:term-AF}]{\sphinxtermref{\DUrole{xref,std,std-term}{AF}}}} case the terms may be reindexed by \(M=S-R'\), which allows for the projection dependence on the {\hyperref[\detokenize{backmatter/glossary:term-ADMs}]{\sphinxtermref{\DUrole{xref,std,std-term}{ADMs}}}} (see below).

\item {} 
\sphinxAtStartPar
\(\Lambda_{R',R}(R_{\hat{n}};\mu,P,R,R')\), \(\bar{\Lambda}_{R'}(\mu,P,R')\): frame couplings and rotations (note slightly different terms for {\hyperref[\detokenize{backmatter/glossary:term-MF}]{\sphinxtermref{\DUrole{xref,std,std-term}{MF}}}} and {\hyperref[\detokenize{backmatter/glossary:term-AF}]{\sphinxtermref{\DUrole{xref,std,std-term}{AF}}}}).

\item {} 
\sphinxAtStartPar
\(\Delta_{L,M}(K,Q,S)\): alignment frame coupling ({\hyperref[\detokenize{backmatter/glossary:term-AF}]{\sphinxtermref{\DUrole{xref,std,std-term}{AF}}}} only).

\item {} 
\sphinxAtStartPar
\(A_{Q,S}^{K}(t)\): ensemble alignment described as a set of {\hyperref[\detokenize{backmatter/glossary:term-Axis-distribution-moments}]{\sphinxtermref{\DUrole{xref,std,std-term}{axis distribution moments}}}} ({\hyperref[\detokenize{backmatter/glossary:term-ADMs}]{\sphinxtermref{\DUrole{xref,std,std-term}{ADMs}}}}, {\hyperref[\detokenize{backmatter/glossary:term-AF}]{\sphinxtermref{\DUrole{xref,std,std-term}{AF}}}} only).

\item {} 
\sphinxAtStartPar
Square\sphinxhyphen{}brackets indicate degeneracy terms, e.g. \([P]^{\frac{1}{2}} = (2P+1)^{\frac{1}{2}}\).

\end{itemize}

\sphinxAtStartPar
And \(I_{l,m,\mu}^{p_{i}\mu_{i},p_{f}\mu_{f}}(\epsilon)\) are the (radial)
dipole ionization matrix elements, as a function of energy \(\epsilon\).
These matrix elements are essentially identical to the simplified forms
\(r_{k,l,m}\) defined in Eqn. \eqref{equation:part1/theory_photoionization_dynamics_191122:eq:r-kllam}, except with additional indices to label
symmetry and polarization components defined by a set of partial\sphinxhyphen{}waves
\(\{l,m\}\), for polarization component \(\mu\) (denoting the photon angular
momentum components) and channels (symmetries) labelled by initial and
final state indexes \((p_{i}\mu_{i},p_{f}\mu_{f})\). The notation here
follows that used by \sphinxhref{https://epolyscat.droppages.com/}{ePolyScat (ePS)} {[}\hyperlink{cite.backmatter/bibliography:id640}{15}, \hyperlink{cite.backmatter/bibliography:id527}{16}, \hyperlink{cite.backmatter/bibliography:id671}{17}, \hyperlink{cite.backmatter/bibliography:id643}{18}{]}, and these matrix elements again represent the quantities to be obtained numerically from data analysis, or from an \sphinxhref{https://epsproc.readthedocs.io/en/latest/ePS\_ePSproc\_tutorial/ePS\_tutorial\_080520.html\#Theoretical-background}{ePolyScat (or similar) calculation}.

\sphinxAtStartPar
Following the tensor components detailed above, the full form of the channel functions of Eq. \eqref{equation:part1/theory_tensor_formalism_201122:eqn:channel-fns} for the {\hyperref[\detokenize{backmatter/glossary:term-AF}]{\sphinxtermref{\DUrole{xref,std,std-term}{AF}}}} and {\hyperref[\detokenize{backmatter/glossary:term-MF}]{\sphinxtermref{\DUrole{xref,std,std-term}{MF}}}} can be written as:
\begin{equation}\label{equation:part1/theory_tensor_formalism_201122:eq:channelFunc-MF-defn}
\begin{split}
\begin{aligned}
\varUpsilon_{L,M}^{u,\zeta\zeta'} & = & (-1)^{M}{[P]^{\frac{1}{2}}}E_{P-R}(\hat{e};\mu_{0})(-1)^{(\mu'-\mu_{0})}\Lambda_{R',R}(R_{\hat{n}};\mu,P,R,R')\\
 & \times & B_{L,-M}(l,l',m,m')\end{aligned}
\end{split}
\end{equation}\begin{equation}\label{equation:part1/theory_tensor_formalism_201122:eq:channelFunc-AF-defn}
\begin{split}
\begin{aligned}
\bar{\varUpsilon_{}}_{L,M}^{u,\zeta\zeta'} & = & (-1)^{M}[P]^{\frac{1}{2}}E_{P-R}(\hat{e};\mu_{0})(-1)^{(\mu'-\mu_{0})}\bar{\Lambda}_{R'}(\mu,P,R')\\
 & \times & B_{L,S-R'}(l,l',m,m')\Delta_{L,M}(K,Q,S)A_{Q,S}^{K}(t)\end{aligned}
\end{split}
\end{equation}
\sphinxAtStartPar
Note that, in this case as given, time\sphinxhyphen{}dependence arises purely from the
\(A_{Q,S}^{K}(t)\) terms in the AF case, and the electric field term
currently describes only the photon angular momentum coupling, although
can in principle also describe time\sphinxhyphen{}dependent/shaped fields. Similarly,
a time\sphinxhyphen{}dependent initial state (e.g. a vibrational wavepacket) could
also describe a time\sphinxhyphen{}dependent MF case.

\sphinxAtStartPar
It should be emphasized, however, that the underlying physical
quantities are essentially identical in all the theoretical approaches,
with a set of coupled angular\sphinxhyphen{}momenta defining the geometrical part of
the photoionization problem, despite these differences in the details of
the theory and notation.

\sphinxAtStartPar
The various tensors defined above are implemented as functions in the \sphinxhref{https://epsproc.readthedocs.io}{ePSproc codebase} {[}\hyperlink{cite.backmatter/bibliography:id561}{12}, \hyperlink{cite.backmatter/bibliography:id508}{13}, \hyperlink{cite.backmatter/bibliography:id506}{14}{]}, and further wrapped for fitting cases in the \sphinxhref{https://github.com/phockett/PEMtk}{Photoelectron Metrology Toolkit} {[}\hyperlink{cite.backmatter/bibliography:id574}{4}{]}. In the remainder of this section, numerical examples using these codes are illustrated and explored. Full computational details can be found in the \sphinxhref{https://epsproc.readthedocs.io}{ePSproc documentation} {[}\hyperlink{cite.backmatter/bibliography:id506}{14}{]}, including \sphinxhref{https://epsproc.readthedocs.io/en/latest/methods/geometric\_method\_dev\_260220\_090420\_tidy.html}{extended discussion of each tensor} and complete function references in the \sphinxhref{https://epsproc.readthedocs.io/en/latest/modules/epsproc.geomFunc.geomCalc.html}{geomCalc submodule documentation}.


\subsection{Numerical aside: symmetry\sphinxhyphen{}defined channel functions}
\label{\detokenize{part1/theory_tensor_formalism_201122:numerical-aside-symmetry-defined-channel-functions}}
\sphinxAtStartPar
In the following sub\sphinxhyphen{}sections, each component is defined in detail, including numerical examples. For illustration purposes, the numerical example uses a minimal set of assumptions, and is defined initially purely by symmetry, although further terms may be required for some of the geometric terms and are discussed where required.

\sphinxAtStartPar
For this example, the \(D_{2h}\) point group is used, representing a fairly general case of a planar asymmetric top system, e.g. ethylene (\(C_2H_4\)). Note that, in this case, the symmetrization coefficients (\(b_{hl\lambda}^{\Gamma\mu}\), see \eqref{equation:part1/theory_observables_intro_211122:eq:symHarm-defn}) have the property that \(\mu=0\) only, and the \(h\) index is redundant, since it maps uniquely to \(l\) \sphinxhyphen{} see \hyperref[\detokenize{part1/theory_tensor_formalism_201122:tab-d2hxlm}]{Fig.\@ \ref{\detokenize{part1/theory_tensor_formalism_201122:tab-d2hxlm}}} \sphinxhyphen{} so these indexes can be dropped. Note, also, the unfortunate convention that the label \(\mu\) is used for multiple indexes; to avoid ambiguity this term is remapped to \(\mu_X\) in the numerics below. However, in this case, since \(\mu\) can be dropped from the symmetrization coefficients, there is actually no ambiguity in later usage.

\begin{sphinxShadowBox}
\sphinxstylesidebartitle{}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Full tabulations of the parameters available in HTML or notebook formats only.
\end{sphinxadmonition}
\end{sphinxShadowBox}

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-output}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Setup symmetry\PYGZhy{}defined matrix elements using PEMtk}

\PYG{c+c1}{\PYGZsh{} Import class}
\PYG{k+kn}{from} \PYG{n+nn}{pemtk}\PYG{n+nn}{.}\PYG{n+nn}{sym}\PYG{n+nn}{.}\PYG{n+nn}{symHarm} \PYG{k+kn}{import} \PYG{n}{symHarm}

\PYG{c+c1}{\PYGZsh{} Compute hamronics for Td, lmax=4}
\PYG{n}{sym} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{D2h}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{lmax}\PYG{o}{=}\PYG{l+m+mi}{4}

\PYG{n}{lmaxPlot} \PYG{o}{=} \PYG{l+m+mi}{2}  \PYG{c+c1}{\PYGZsh{} Set lmaxPlot for subselection on plots later.}

\PYG{c+c1}{\PYGZsh{} Glue items for later}
\PYG{n}{glue}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{symHarmPGmatE}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{sym}\PYG{p}{,} \PYG{n}{display}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\PYG{n}{glue}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{symHarmLmaxmatE}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{lmax}\PYG{p}{,} \PYG{n}{display}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\PYG{n}{glue}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{symHarmBasislmaxPlot}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{lmaxPlot}\PYG{p}{,} \PYG{n}{display}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} TODO: consider different labelling here, can set at init e.g. dims = [\PYGZsq{}C\PYGZsq{}, \PYGZsq{}h\PYGZsq{}, \PYGZsq{}muX\PYGZsq{}, \PYGZsq{}l\PYGZsq{}, \PYGZsq{}m\PYGZsq{}] \PYGZhy{} 25/11/22 code currently fails for mu mapping, remap below instead}
\PYG{n}{symObj} \PYG{o}{=} \PYG{n}{symHarm}\PYG{p}{(}\PYG{n}{sym}\PYG{p}{,}\PYG{n}{lmax}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} symObj = symHarm(sym,lmax,dims = [\PYGZsq{}Cont\PYGZsq{}, \PYGZsq{}h\PYGZsq{}, \PYGZsq{}muX\PYGZsq{}, \PYGZsq{}l\PYGZsq{}, \PYGZsq{}m\PYGZsq{}])}

\PYG{c+c1}{\PYGZsh{} To plot using ePSproc/PEMtk class, these values can be converted to ePSproc BLM data type...}

\PYG{c+c1}{\PYGZsh{} Run conversion \PYGZhy{} the default is to set the coeffs to the \PYGZsq{}BLM\PYGZsq{} data type}
\PYG{n}{dimMap} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cont}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mu}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{muX}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{symObj}\PYG{o}{.}\PYG{n}{toePSproc}\PYG{p}{(}\PYG{n}{dimMap}\PYG{o}{=}\PYG{n}{dimMap}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Run conversion with a different dimMap \PYGZam{} dataType}
\PYG{n}{dataType} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{matE}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{c+c1}{\PYGZsh{} symObj.toePSproc(dimMap = \PYGZob{}\PYGZsq{}C\PYGZsq{}:\PYGZsq{}Cont\PYGZsq{},\PYGZsq{}h\PYGZsq{}:\PYGZsq{}it\PYGZsq{}, \PYGZsq{}mu\PYGZsq{}:\PYGZsq{}muX\PYGZsq{}\PYGZcb{}, dataType=dataType)}
\PYG{n}{symObj}\PYG{o}{.}\PYG{n}{toePSproc}\PYG{p}{(}\PYG{n}{dimMap} \PYG{o}{=} \PYG{n}{dimMap}\PYG{p}{,} \PYG{n}{dataType}\PYG{o}{=}\PYG{n}{dataType}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} symObj.toePSproc(dimMap = \PYGZob{}\PYGZsq{}C\PYGZsq{}:\PYGZsq{}Cont\PYGZsq{},\PYGZsq{}h\PYGZsq{}:\PYGZsq{}it\PYGZsq{}\PYGZcb{}, dataType=dataType)   \PYGZsh{} Drop mu \PYGZgt{} muX mapping for now}
\PYG{c+c1}{\PYGZsh{} symObj.coeffs[dataType]}

\PYG{c+c1}{\PYGZsh{} Example using data class (setup in init script)}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{pemtkFit}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Set to new key in data class}
\PYG{n}{dataKey} \PYG{o}{=} \PYG{n}{sym}
\PYG{n}{data}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{dataKey}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

\PYG{k}{for} \PYG{n}{dataType} \PYG{o+ow}{in} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{matE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{BLM}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{:}
    \PYG{n}{data}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{dataKey}\PYG{p}{]}\PYG{p}{[}\PYG{n}{dataType}\PYG{p}{]} \PYG{o}{=} \PYG{n}{symObj}\PYG{o}{.}\PYG{n}{coeffs}\PYG{p}{[}\PYG{n}{dataType}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b (comp)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{muX}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Select expansion in complex harmonics, and sum redundant dims}
    \PYG{n}{data}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{dataKey}\PYG{p}{]}\PYG{p}{[}\PYG{n}{dataType}\PYG{p}{]}\PYG{o}{.}\PYG{n}{attrs} \PYG{o}{=} \PYG{n}{symObj}\PYG{o}{.}\PYG{n}{coeffs}\PYG{p}{[}\PYG{n}{dataType}\PYG{p}{]}\PYG{o}{.}\PYG{n}{attrs}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-output}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Display results (real harmonics)}
\PYG{n}{symObj}\PYG{o}{.}\PYG{n}{displayXlm}\PYG{p}{(}\PYG{n}{setCols}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{}, dropLevels=\PYGZsq{}mu\PYGZsq{})}

\PYG{c+c1}{\PYGZsh{} Glue version for JupyterBook output}
\PYG{n}{glue}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{D2hXlm}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{symObj}\PYG{o}{.}\PYG{n}{displayXlm}\PYG{p}{(}\PYG{n}{setCols}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{returnPD}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}\PYG{p}{,} \PYG{n}{display}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} As above, but with PD object return and glue.}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{figure}[htbp]
\centering
\capstart
\begin{equation*}
\begin{split}\begin{tabular}{llllllllll}
\toprule
    &   &   & {} & \multicolumn{6}{l}{b} \\
    &   &   & h &    0 &    1 &    2 &    3 &    4 &    5 \\
Character (\$\textbackslash Gamma\$) & PFIX (\$\textbackslash mu\$) & l & m &      &      &      &      &      &      \\
\midrule
A1g & 0 & 0 &  0 &  1.0 &      &      &      &      &      \\
    &   & 2 &  0 &      &  1.0 &      &      &      &      \\
    &   &   &  2 &      &      &  1.0 &      &      &      \\
    &   & 4 &  0 &      &      &      &  1.0 &      &      \\
    &   &   &  2 &      &      &      &      &  1.0 &      \\
    &   &   &  4 &      &      &      &      &      &  1.0 \\
A1u & 0 & 3 & -2 &  1.0 &      &      &      &      &      \\
B1g & 0 & 2 & -2 &  1.0 &      &      &      &      &      \\
    &   & 4 & -4 &      &  1.0 &      &      &      &      \\
    &   &   & -2 &      &      &  1.0 &      &      &      \\
B1u & 0 & 1 &  0 &  1.0 &      &      &      &      &      \\
    &   & 3 &  0 &      &  1.0 &      &      &      &      \\
    &   &   &  2 &      &      &  1.0 &      &      &      \\
B2g & 0 & 2 &  1 &  1.0 &      &      &      &      &      \\
    &   & 4 &  1 &      &  1.0 &      &      &      &      \\
    &   &   &  3 &      &      &  1.0 &      &      &      \\
B2u & 0 & 1 & -1 &  1.0 &      &      &      &      &      \\
    &   & 3 & -3 &      &  1.0 &      &      &      &      \\
    &   &   & -1 &      &      &  1.0 &      &      &      \\
B3g & 0 & 2 & -1 &  1.0 &      &      &      &      &      \\
    &   & 4 & -3 &      &  1.0 &      &      &      &      \\
    &   &   & -1 &      &      &  1.0 &      &      &      \\
B3u & 0 & 1 &  1 &  1.0 &      &      &      &      &      \\
    &   & 3 &  1 &      &  1.0 &      &      &      &      \\
    &   &   &  3 &      &      &  1.0 &      &      &      \\
\bottomrule
\end{tabular}\end{split}
\end{equation*}\caption{Symmetrized harmonics coefficients (\(b_{hl\lambda}^{\Gamma\mu}\), see \eqref{equation:part1/theory_observables_intro_211122:eq:symHarm-defn}) for \DUrole{pasted-text}{D2h} symmetry (\(l_{max}=\)\DUrole{pasted-text}{4}) generated with the \sphinxhref{https://github.com/phockett/PEMtk}{Photoelectron Metrology Toolkit} {[}\hyperlink{cite.backmatter/bibliography:id574}{4}{]} wrapper for \sphinxhref{https://github.com/mcodev31/libmsym}{libmsym} {[}\hyperlink{cite.backmatter/bibliography:id593}{33}, \hyperlink{cite.backmatter/bibliography:id594}{34}{]}. Note that, in this case, the coeffcients have the property that \(\mu=0\) only, and the \(h\) index is redundant (maps uniquely to \(l\)).}\label{\detokenize{part1/theory_tensor_formalism_201122:tab-d2hxlm}}\end{figure}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} ep.matEleSelector(data.data[dataKey][\PYGZsq{}matE\PYGZsq{}], thres = None, inds = \PYGZob{}\PYGZcb{}, dims = \PYGZsq{}Eke\PYGZsq{}, sq = True, drop = True)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Compute basis functions for given matrix elements}

\PYG{c+c1}{\PYGZsh{} Set data}
\PYG{n}{data}\PYG{o}{.}\PYG{n}{subKey} \PYG{o}{=} \PYG{n}{dataKey}

\PYG{c+c1}{\PYGZsh{} Using PEMtk \PYGZhy{} this only returns the product basis set as used for fitting}
\PYG{n}{BetaNormX}\PYG{p}{,} \PYG{n}{basisProduct} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{afblmMatEfit}\PYG{p}{(}\PYG{n}{selDims}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{sqThres}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Using ePSproc directly \PYGZhy{} this includes full basis return if specified}
\PYG{n}{BetaNormX2}\PYG{p}{,} \PYG{n}{basisFull} \PYG{o}{=} \PYG{n}{ep}\PYG{o}{.}\PYG{n}{geomFunc}\PYG{o}{.}\PYG{n}{afblmXprod}\PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{data}\PYG{o}{.}\PYG{n}{subKey}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{matE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{basisReturn} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Full}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{selDims}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{sqThres}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{}, BLMRenorm = BLMRenorm, **kwargs)}

\PYG{c+c1}{\PYGZsh{} The basis dictionary contains various numerical parameters, these are investigated below.}
\PYG{c+c1}{\PYGZsh{} See also the ePSproc docs at https://epsproc.readthedocs.io/en/latest/methods/geometric\PYGZus{}method\PYGZus{}dev\PYGZus{}260220\PYGZus{}090420\PYGZus{}tidy.html}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Product basis elements: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{basisProduct}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Full basis elements: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{basisFull}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Use full basis for following sections}
\PYG{n}{basis} \PYG{o}{=} \PYG{n}{basisFull}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Product basis elements: dict\PYGZus{}keys([\PYGZsq{}BLMtableResort\PYGZsq{}, \PYGZsq{}polProd\PYGZsq{}, \PYGZsq{}phaseConvention\PYGZsq{}, \PYGZsq{}BLMRenorm\PYGZsq{}])
Full basis elements: dict\PYGZus{}keys([\PYGZsq{}QNs\PYGZsq{}, \PYGZsq{}EPRX\PYGZsq{}, \PYGZsq{}lambdaTerm\PYGZsq{}, \PYGZsq{}BLMtable\PYGZsq{}, \PYGZsq{}BLMtableResort\PYGZsq{}, \PYGZsq{}AFterm\PYGZsq{}, \PYGZsq{}AKQS\PYGZsq{}, \PYGZsq{}polProd\PYGZsq{}, \PYGZsq{}phaseConvention\PYGZsq{}, \PYGZsq{}BLMRenorm\PYGZsq{}])
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Matrix element geometric coupling term \protect\(B_{L,M}\protect\)}
\label{\detokenize{part1/theory_tensor_formalism_201122:matrix-element-geometric-coupling-term-b-l-m}}\label{\detokenize{part1/theory_tensor_formalism_201122:sec-theory-blm-term}}
\sphinxAtStartPar
The coupling of the partial wave pairs, \(|l,m\rangle\) and \(|l',m'\rangle\), into the observable set of \(\{L,M\}\) is defined by a tensor contraction with two 3j terms.
\begin{equation}\label{equation:part1/theory_tensor_formalism_201122:eq:basis-BLM-defn}
\begin{split}
B_{L,M}=(-1)^{m}\left(\frac{(2l+1)(2l'+1)(2L+1)}{4\pi}\right)^{1/2}\left(\begin{array}{ccc}
l & l' & L\\
0 & 0 & 0
\end{array}\right)\left(\begin{array}{ccc}
l & l' & L\\
-m & m' & M
\end{array}\right)
\end{split}
\end{equation}
\sphinxAtStartPar
Note that this term is equivalent, effectively, to a triple integral over spherical harmonics (e.g. Eq. 3.119 in Zare {[}\hyperlink{cite.backmatter/bibliography:id824}{44}{]}):
\begin{equation*}
\begin{split}
\begin{aligned}
\intop_{0}^{2\pi}\intop_{0}^{\pi}Y_{J_{3}M_{3}}(\theta,\phi)Y_{J_{2}M_{2}}(\theta,\phi)Y_{J_{1}M_{1}}(\theta,\phi)\sin\theta d\theta d\phi & = & \left(\frac{(2J_{1}+1)(2J_{2}+1)(2J_{3}+1)}{4\pi}\right)^{1/2}\\
 & \times & \left(\begin{array}{ccc}
J_{1} & J_{2} & J_{3}\\
0 & 0 & 0
\end{array}\right)\left(\begin{array}{ccc}
J_{1} & J_{2} & J_{3}\\
M_{1} & M_{2} & M_{3}
\end{array}\right)
\end{aligned}
\end{split}
\end{equation*}
\sphinxAtStartPar
And a similar term appears in the contraction over a pair of harmonics into a resultant harmonic (e.g. Eqs. C.21, C.22 in Blum {[}\hyperlink{cite.backmatter/bibliography:id444}{52}{]}) \sphinxhyphen{} this is how the term arises in the derivation of the observables.
\begin{equation*}
\begin{split}
\begin{aligned}
Y_{J_{1}M_{1}}(\theta,\phi)Y_{J_{2}M_{2}}(\theta,\phi) & = & \sum_{J_{3}M_{3}}\left(\frac{(2J_{1}+1)(2J_{2}+1)(2J_{3}+1)}{4\pi}\right)^{1/2}\\
 & \times & \left(\begin{array}{ccc}
J_{1} & J_{2} & J_{3}\\
0 & 0 & 0
\end{array}\right)\left(\begin{array}{ccc}
J_{1} & J_{2} & J_{3}\\
M_{1} & M_{2} & M_{3}
\end{array}\right)Y_{J_{3}M_{3}}^{*}(\theta,\phi)
\end{aligned}
\end{split}
\end{equation*}
\sphinxAtStartPar
Note also some definitions use conjugate spherical harmonics, which can be converted as, e.g., Eq. C.21 in Blum {[}\hyperlink{cite.backmatter/bibliography:id444}{52}{]}:
\label{equation:part1/theory_tensor_formalism_201122:9f9ad0e8-538b-4af1-8f6e-ec42fbec837c}\begin{equation}
\beta_{L,M}^{\mu_{i},\mu_{f}}Y_{LM}^{*}(\theta_{\hat{k}},\phi_{\hat{k}})=\beta_{L,-M}^{\mu_{i},\mu_{f}}(-1)^{M}Y_{L,-M}(\theta_{\hat{k}},\phi_{\hat{k}})\label{eq:sph-conj-conv}
\end{equation}
\sphinxAtStartPar
In the current \sphinxhref{https://github.com/phockett/PEMtk}{Photoelectron Metrology Toolkit} {[}\hyperlink{cite.backmatter/bibliography:id574}{4}{]} codebase, the relevant basis item can be inspected as below, in order to illustrate the sensitivity of different \((L,M)\) terms to the matrix element products. Note for the {\hyperref[\detokenize{backmatter/glossary:term-AF}]{\sphinxtermref{\DUrole{xref,std,std-term}{AF}}}} case the terms may be reindexed by \(M=S-R'\) \sphinxhyphen{} this allows for all {\hyperref[\detokenize{backmatter/glossary:term-MF}]{\sphinxtermref{\DUrole{xref,std,std-term}{MF}}}} projections to contribute, rather than just a single specified polarization geometry. However, in many typical cases, this term is nonetheless restricted to only \(M=0\) components overall by other geometric factors (see below).

\sphinxAtStartPar
The code cells below illustrate this for the current example case, and \hyperref[\detokenize{part1/theory_tensor_formalism_201122:fig-blm-basis-d2h}]{Fig.\@ \ref{\detokenize{part1/theory_tensor_formalism_201122:fig-blm-basis-d2h}}} offers a general summary. In general, this is a convenient way to visualize the selection rules into the observable: for instance, only terms \(l=l'\) and \(m=-m'\) contribute to the overall photoionization cross\sphinxhyphen{}section term (\(L=0, M=0\)), and the maximum observable \(L_{max}=2l_{max}\). However, since these terms are fairly simply followed algebraically in this case, via the rules inherent in the \(3j\) product (Eq. \eqref{equation:part1/theory_tensor_formalism_201122:eq:basis-BLM-defn}), this is not particularly insightful (although useful pedagogically). These visualizations will become more useful when dealing with real sets of matrix elements, and specific polarization geometries, which will further modulate or restrict the \(B_{L,M}\) terms.

\sphinxAtStartPar
Numerically, various standard functions may be used to quickly gain deeper insight, for example min/max, averages etc. Such considerations may provide a quick sanity\sphinxhyphen{}check for a given case, and may prove useful when planning experiments to investigate particular aspects or channels of a given system. Other properties of the basis functions may also be interrogated numerically; for instance, correlation maps provide an alternative way to check which terms are strongly correlated or coupled, or will dominate a given aspect of the observable.

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-output}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Tabulate basis (use ep.multiDimXrToPD, or other? Should have wrappers...?)}

\PYG{n}{basisKey} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{BLMtableResort}\PYG{l+s+s1}{\PYGZsq{}}  \PYG{c+c1}{\PYGZsh{} Key for BLM basis set}

\PYG{c+c1}{\PYGZsh{} Reformat basis for display (optional)}
\PYG{n}{stackDims} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LM}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{L}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{M}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{\PYGZcb{}}
\PYG{n}{basisPlot} \PYG{o}{=} \PYG{n}{basis}\PYG{p}{[}\PYG{n}{basisKey}\PYG{p}{]}\PYG{o}{.}\PYG{n}{rename}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{S\PYGZhy{}Rp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{M}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{stack}\PYG{p}{(}\PYG{n}{stackDims}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Convert to Pandas}
\PYG{n}{pd}\PYG{p}{,} \PYG{n}{\PYGZus{}} \PYG{o}{=} \PYG{n}{ep}\PYG{o}{.}\PYG{n}{multiDimXrToPD}\PYG{p}{(}\PYG{n}{basisPlot}\PYG{p}{,} \PYG{n}{colDims}\PYG{o}{=}\PYG{n}{stackDims}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Summarise properties and tabulate via Pandas Describe}
\PYG{n}{pd}\PYG{o}{.}\PYG{n}{describe}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-output}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}*** Plot BLM terms for basis set \PYGZhy{} basic}
\PYG{n}{basisKey} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{BLMtableResort}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{c+c1}{\PYGZsh{} Basic plot}
\PYG{n}{ep}\PYG{o}{.}\PYG{n}{lmPlot}\PYG{p}{(}\PYG{n}{basisPlot}\PYG{p}{,} \PYG{n}{xDim}\PYG{o}{=}\PYG{n}{stackDims}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{\PYGZsh{} Basic plot with all terms}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-output}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}*** Plot BLM terms for basis set \PYGZhy{} Plot with some additional figure formatting options}

\PYG{c+c1}{\PYGZsh{} cmap=None   \PYGZsh{} cmap = None for default. \PYGZsq{}vlag\PYGZsq{} good?}
\PYG{c+c1}{\PYGZsh{} cmap = \PYGZsq{}vlag\PYGZsq{}}

\PYG{n}{labelRound} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{catLegend}\PYG{o}{=}\PYG{k+kc}{False}
\PYG{n}{titleString}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{titleDetails}\PYG{o}{=}\PYG{k+kc}{False}
\PYG{n}{labelCols} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} With global formatting args}
\PYG{c+c1}{\PYGZsh{} ep.lmPlot(basis[basisKey].where((basis[basisKey].l\PYGZlt{}=lmaxPlot) \PYGZam{} (basis[basisKey].lp\PYGZlt{}=lmaxPlot)).rename(\PYGZob{}\PYGZsq{}S\PYGZhy{}Rp\PYGZsq{}:\PYGZsq{}M\PYGZsq{}\PYGZcb{}).stack(\PYGZob{}\PYGZsq{}LM\PYGZsq{}:[\PYGZsq{}L\PYGZsq{},\PYGZsq{}M\PYGZsq{}]\PYGZcb{}), xDim=\PYGZob{}\PYGZsq{}LM\PYGZsq{}:[\PYGZsq{}L\PYGZsq{},\PYGZsq{}M\PYGZsq{}]\PYGZcb{},}
\PYG{c+c1}{\PYGZsh{}           cmap=cmap, labelRound = labelRound, catLegend=catLegend, titleString=titleString, titleDetails=titleDetails, labelCols = labelCols);}

\PYG{c+c1}{\PYGZsh{} With fig return \PYGZhy{} NEEDS WORK, displays but doesn\PYGZsq{}t return fig object?}
\PYG{c+c1}{\PYGZsh{} UPDATE 28/11/22: still displays, but now have glue() working correctly.}
\PYG{c+c1}{\PYGZsh{} daPlot, daPlotpd, legendList, gFig = ep.lmPlot(basis[basisKey].where((basis[basisKey].l\PYGZlt{}=lmaxPlot) \PYGZam{} (basis[basisKey].lp\PYGZlt{}=lmaxPlot)).rename(\PYGZob{}\PYGZsq{}S\PYGZhy{}Rp\PYGZsq{}:\PYGZsq{}M\PYGZsq{}\PYGZcb{}).stack(\PYGZob{}\PYGZsq{}LM\PYGZsq{}:[\PYGZsq{}L\PYGZsq{},\PYGZsq{}M\PYGZsq{}]\PYGZcb{}), xDim=\PYGZob{}\PYGZsq{}LM\PYGZsq{}:[\PYGZsq{}L\PYGZsq{},\PYGZsq{}M\PYGZsq{}]\PYGZcb{},}
\PYG{c+c1}{\PYGZsh{}           pType = \PYGZsq{}r\PYGZsq{}, cmap=cmap, labelRound = labelRound, catLegend=catLegend, titleString=titleString, titleDetails=titleDetails, labelCols = labelCols);}

\PYG{c+c1}{\PYGZsh{} 30/11/22 simplified version}
\PYG{n}{daPlot}\PYG{p}{,} \PYG{n}{daPlotpd}\PYG{p}{,} \PYG{n}{legendList}\PYG{p}{,} \PYG{n}{gFig} \PYG{o}{=} \PYG{n}{ep}\PYG{o}{.}\PYG{n}{lmPlot}\PYG{p}{(}\PYG{n}{basisPlot}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{p}{(}\PYG{n}{basisPlot}\PYG{o}{.}\PYG{n}{l}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{n}{lmaxPlot}\PYG{p}{)} \PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{basisPlot}\PYG{o}{.}\PYG{n}{lp}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{n}{lmaxPlot}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} 
                                               \PYG{n}{xDim}\PYG{o}{=}\PYG{n}{stackDims}\PYG{p}{,} \PYG{n}{pType} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{,} \PYG{n}{labelRound} \PYG{o}{=} \PYG{n}{labelRound}\PYG{p}{,} 
                                               \PYG{n}{catLegend}\PYG{o}{=}\PYG{n}{catLegend}\PYG{p}{,} \PYG{n}{titleString}\PYG{o}{=}\PYG{n}{titleString}\PYG{p}{,} \PYG{n}{titleDetails}\PYG{o}{=}\PYG{n}{titleDetails}\PYG{p}{,} 
                                               \PYG{n}{labelCols} \PYG{o}{=} \PYG{n}{labelCols}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{\PYGZsh{} For glue}
\PYG{n}{glue}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{lmPlot\PYGZus{}BLM\PYGZus{}basis\PYGZus{}D2h}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{gFig}\PYG{o}{.}\PYG{n}{fig}\PYG{p}{,} \PYG{n}{display}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{fc4c2a4c5a465295210c34432a0ec4a08f4018ce3f2e3488a442ae551a2e1443}.png}
\caption{Example \(B_{L,M}\) basis functions for \DUrole{pasted-text}{D2h} symmetry. Note figure is truncated to \(l_{max}=l'_{max}=\)\DUrole{pasted-text}{2} for clarity.}\label{\detokenize{part1/theory_tensor_formalism_201122:fig-blm-basis-d2h}}\end{figure}


\subsection{Electric field geometric coupling term \protect\({E_{P,R}(\hat{e};\mu_{0})}\protect\)}
\label{\detokenize{part1/theory_tensor_formalism_201122:electric-field-geometric-coupling-term-e-p-r-hat-e-mu-0}}\label{\detokenize{part1/theory_tensor_formalism_201122:sec-theory-epr-term}}
\sphinxAtStartPar
The coupling of two 1\sphinxhyphen{}photon terms (which arises in the square of the ionization matrix element as per Eq. \eqref{equation:part1/theory_photoionization_dynamics_191122:eq:I-reduced-LF-2_45-vol1}) can be written as a tensor contraction:
\label{equation:part1/theory_tensor_formalism_201122:7950fbac-75c3-4025-bc3c-c96738653264}\begin{equation}
E_{PR}(\hat{e})=[e\otimes e^{*}]_{R}^{P}=[P]^{\frac{1}{2}}\sum_{p}(-1)^{R}\left(\begin{array}{ccc}
1 & 1 & P\\
p & R-p & -R
\end{array}\right)e_{p}e_{R-p}^{*}\label{eq:EPR-defn-1}
\end{equation}
\sphinxAtStartPar
Where:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(e_{p}\) and \(e_{R-p}\) define the field strengths for the polarizations \(p\) and \(R-p\), which are coupled into the spherical tensor \(E_{PR}\);

\item {} 
\sphinxAtStartPar
square\sphinxhyphen{}brackets indicate degeneracy terms, e.g. \([P]^{\frac{1}{2}} = (2P+1)^{\frac{1}{2}}\);

\item {} 
\sphinxAtStartPar
the symbol \(\mu_{0}\) is conventionally used to denote the {\hyperref[\detokenize{backmatter/glossary:term-LF}]{\sphinxtermref{\DUrole{xref,std,std-term}{LF}}}} field projection definition, given in full as \((1,\mu_0)\) for the 1\sphinxhyphen{}photon case, \sphinxstylestrong{in general for the LF/AF case \(\mu_0=p\), while for the MF case all projection terms are allowed, and are usually labelled by \(\mu\) or \(q\).} TO FIX

\end{itemize}

\sphinxAtStartPar
(To derive this result, one can start from, e.g., Eq. 5.40 in Zare
\label{equation:part1/theory_tensor_formalism_201122:bd65d488-6285-40f6-8931-e283c287ef99}\begin{equation}
[A^{(1)}\otimes B^{(1)}]_{q}^{k}=\sum_{m}\langle1m,1q-m|kq\rangle A(1,m)B(1,q-m)
\end{equation}
\sphinxAtStartPar
Convert to \(3j\) form:
\label{equation:part1/theory_tensor_formalism_201122:f99eb4e8-73ba-4866-8c5d-ba9739df9c0d}\begin{equation}
[A^{(1)}\otimes B^{(1)}]_{q}^{k}=\sum_{m}(-1)^{q}[k]^{1/2}\left(\begin{array}{ccc}
1 & 1 & k\\
m & q-m & -q
\end{array}\right)A(1,m)B(1,q-m)
\end{equation}
\sphinxAtStartPar
And substitute in appropriate terms.)

\sphinxAtStartPar
As before, we can visualise these values…

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-output}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} For illustration, recompute EPR term for default case.}
\PYG{n}{EPRX} \PYG{o}{=} \PYG{n}{ep}\PYG{o}{.}\PYG{n}{geomCalc}\PYG{o}{.}\PYG{n}{EPR}\PYG{p}{(}\PYG{n}{form} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{xarray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Set parameters to restack the Xarray into (L,M) pairs}
\PYG{c+c1}{\PYGZsh{} plotDimsRed = [\PYGZsq{}l\PYGZsq{}, \PYGZsq{}p\PYGZsq{}, \PYGZsq{}lp\PYGZsq{}, \PYGZsq{}R\PYGZhy{}p\PYGZsq{}]}
\PYG{n}{plotDimsRed} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{p}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{R\PYGZhy{}p}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{xDim} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PR}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{P}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{R}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{\PYGZsh{} Plot with ep.lmPlot(), real values}
\PYG{n}{daPlot}\PYG{p}{,} \PYG{n}{daPlotpd}\PYG{p}{,} \PYG{n}{legendList}\PYG{p}{,} \PYG{n}{gFig} \PYG{o}{=} \PYG{n}{ep}\PYG{o}{.}\PYG{n}{lmPlot}\PYG{p}{(}\PYG{n}{EPRX}\PYG{p}{,} \PYG{n}{plotDims}\PYG{o}{=}\PYG{n}{plotDimsRed}\PYG{p}{,} \PYG{n}{xDim}\PYG{o}{=}\PYG{n}{xDim}\PYG{p}{,} \PYG{n}{pType} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Version summed over l,m}
\PYG{c+c1}{\PYGZsh{} daPlot, daPlotpd, legendList, gFig = ep.lmPlot(EPRX.unstack().sum([\PYGZsq{}l\PYGZsq{},\PYGZsq{}lp\PYGZsq{},\PYGZsq{}R\PYGZhy{}p\PYGZsq{}]), xDim=xDim, pType = \PYGZsq{}r\PYGZsq{})}

\PYG{c+c1}{\PYGZsh{} For glue}
\PYG{n}{glue}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{lmPlot\PYGZus{}EPR\PYGZus{}basis}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{gFig}\PYG{o}{.}\PYG{n}{fig}\PYG{p}{,} \PYG{n}{display}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{12c20e1faddfcdeb2fcf118a6201197aab8c94815198c641b92fbbc4186234ee}.png}
\caption{Example \(E_{P,R}\) basis functions. Note that for linearly polarised light \(p=R-p=0\) only, hence only the terms \(E_{0,0}\) and \(E_{2,0}\) are non\sphinxhyphen{}zero in this case. For non\sphinxhyphen{}linearly polarised cases many other terms are allowed.}\label{\detokenize{part1/theory_tensor_formalism_201122:fig-epr-basis}}\end{figure}


\subsection{Molecular frame projection term \protect\(\Lambda\protect\)}
\label{\detokenize{part1/theory_tensor_formalism_201122:molecular-frame-projection-term-lambda}}\label{\detokenize{part1/theory_tensor_formalism_201122:sec-theory-lambda-term}}
\sphinxAtStartPar
For the molecular frame case, the coupling between the {\hyperref[\detokenize{backmatter/glossary:term-LF}]{\sphinxtermref{\DUrole{xref,std,std-term}{LF}}}} and {\hyperref[\detokenize{backmatter/glossary:term-MF}]{\sphinxtermref{\DUrole{xref,std,std-term}{MF}}}} can be defined by a projection term, \(\Lambda_{R',R}(R_{\hat{n}})\):
\begin{equation}\label{equation:part1/theory_tensor_formalism_201122:eq:basis-lambda-MF-defn}
\begin{split}
\Lambda_{R',R}(R_{\hat{n}})=(-1)^{(R')}\left(\begin{array}{ccc}
1 & 1 & P\\
\mu & -\mu' & R'
\end{array}\right)D_{-R',-R}^{P}(R_{\hat{n}})
\end{split}
\end{equation}
\sphinxAtStartPar
This is similar to the \(E_{PR}\) term, and essentially rotates it into the {\hyperref[\detokenize{backmatter/glossary:term-MF}]{\sphinxtermref{\DUrole{xref,std,std-term}{MF}}}}, defining the projections of the polarization vector (photon angular momentum) \(\mu\) into the {\hyperref[\detokenize{backmatter/glossary:term-MF}]{\sphinxtermref{\DUrole{xref,std,std-term}{MF}}}} for a given molecular orientation (frame rotation) defined by \(R_{\hat{n}}\).

\sphinxAtStartPar
For the {\hyperref[\detokenize{backmatter/glossary:term-LF}]{\sphinxtermref{\DUrole{xref,std,std-term}{LF}}}}/{\hyperref[\detokenize{backmatter/glossary:term-AF}]{\sphinxtermref{\DUrole{xref,std,std-term}{AF}}}} case, the same term appears but in a simplified form:
\begin{equation}\label{equation:part1/theory_tensor_formalism_201122:eq:basis-lambda-LF-defn}
\begin{split}
\bar{\Lambda}_{R'}=(-1)^{(R')}\left(\begin{array}{ccc}
1 & 1 & P\\
\mu & -\mu' & R'
\end{array}\right)\equiv\Lambda_{R',R'}(R_{\hat{n}}=0)
\end{split}
\end{equation}
\sphinxAtStartPar
This form pertains since \sphinxhyphen{} in the {\hyperref[\detokenize{backmatter/glossary:term-LF}]{\sphinxtermref{\DUrole{xref,std,std-term}{LF}}}}/{\hyperref[\detokenize{backmatter/glossary:term-AF}]{\sphinxtermref{\DUrole{xref,std,std-term}{AF}}}} case \sphinxhyphen{} there is no specific frame transformation defined (i.e. there is no single molecular orientation defined in relation to the light polarization, rather a distribution as defined by the {\hyperref[\detokenize{backmatter/glossary:term-ADMs}]{\sphinxtermref{\DUrole{xref,std,std-term}{ADMs}}}}), but the total angular momentum coupling of the photon terms is still required in the equations.

\sphinxAtStartPar
Numerically, the function is calculated for a specified set of orientations, which default to the standard set of \((x,y,z)\) MF polarization cases. For the LF/AF case, this term is still used, but restricted to \(R_{\hat{n}} = (0,0,0) = z\), i.e. no frame rotation relative to the {\hyperref[\detokenize{backmatter/glossary:term-LF}]{\sphinxtermref{\DUrole{xref,std,std-term}{LF}}}} \(E_{PR}\) definition.

\sphinxAtStartPar
TODO: frame rotation illustration as well as term plots? Cf. QM1?


\subsection{Alignment tensor \protect\(\Delta_{L,M}(K,Q,S)\protect\)}
\label{\detokenize{part1/theory_tensor_formalism_201122:alignment-tensor-delta-l-m-k-q-s}}\label{\detokenize{part1/theory_tensor_formalism_201122:sec-theory-af-alignment-term}}
\sphinxAtStartPar
Finally, for the {\hyperref[\detokenize{backmatter/glossary:term-LF}]{\sphinxtermref{\DUrole{xref,std,std-term}{LF}}}}/{\hyperref[\detokenize{backmatter/glossary:term-AF}]{\sphinxtermref{\DUrole{xref,std,std-term}{AF}}}} case, the alignment tensor couples the molecular axis ensemble (defined as a set of {\hyperref[\detokenize{backmatter/glossary:term-ADMs}]{\sphinxtermref{\DUrole{xref,std,std-term}{ADMs}}}}) and the photoionization multipole terms into the final observable.
\begin{equation}\label{equation:part1/theory_tensor_formalism_201122:eq:basis-alignmentTensor-defn}
\begin{split}
\Delta_{L,M}(K,Q,S)=(2K+1)^{1/2}(-1)^{K+Q}\left(\begin{array}{ccc}
P & K & L\\
R & -Q & -M
\end{array}\right)\left(\begin{array}{ccc}
P & K & L\\
R' & -S & S-R'
\end{array}\right)
\end{split}
\end{equation}
\sphinxAtStartPar
In the full equations for the observable, this term appears in a summation with the {\hyperref[\detokenize{backmatter/glossary:term-ADMs}]{\sphinxtermref{\DUrole{xref,std,std-term}{ADMs}}}}, as:
\begin{equation}\label{equation:part1/theory_tensor_formalism_201122:eq:basis-aligmentTerm-defn}
\begin{split}
\tilde{\Delta}_{L,M}(t) = \sum_{K,Q,S}\Delta_{L,M}(K,Q,S)A_{Q,S}^{K}(t)
\end{split}
\end{equation}
\sphinxAtStartPar
This summed alignment term can be considered, essentially, as a (coherent) geometric averaging of the {\hyperref[\detokenize{backmatter/glossary:term-MF}]{\sphinxtermref{\DUrole{xref,std,std-term}{MF}}}} observable weighted by the axis distribution in the {\hyperref[\detokenize{backmatter/glossary:term-AF}]{\sphinxtermref{\DUrole{xref,std,std-term}{AF}}}} (for more on the axis averaging as a convolution, see Refs. {[}\hyperlink{cite.backmatter/bibliography:id569}{1}, \hyperlink{cite.backmatter/bibliography:id785}{51}{]}); equivalently, the averaging can be considered as a purely angular\sphinxhyphen{}momentum coupling effect, which accounts for all contributing moments of the various aspects of the system, and defines the allowed projections onto the final observables in the {\hyperref[\detokenize{backmatter/glossary:term-LF}]{\sphinxtermref{\DUrole{xref,std,std-term}{LF}}}}.

\sphinxAtStartPar
Mappings of these terms are investigated numerically below, for some examplar cases.


\subsubsection{Basic cases}
\label{\detokenize{part1/theory_tensor_formalism_201122:basic-cases}}\label{\detokenize{part1/theory_tensor_formalism_201122:sec-theory-af-alignment-term-basic}}
\sphinxAtStartPar
\hyperref[\detokenize{part1/theory_tensor_formalism_201122:fig-deltaterm000}]{Fig.\@ \ref{\detokenize{part1/theory_tensor_formalism_201122:fig-deltaterm000}}} illustrates the alignment tensor \(\Delta_{L,M}(K,Q,S)\) for some basic cases, and values are also tabulated in \hyperref[\detokenize{part1/theory_tensor_formalism_201122:tab-deltaterm000}]{Fig.\@ \ref{\detokenize{part1/theory_tensor_formalism_201122:tab-deltaterm000}}}. Note that for illustration purposes the term is subselected with \(K=0\), \(Q=0\), \(S=0\) and \(R'=0\); \(R\neq0\) terms are included to illustrate the elliptically\sphinxhyphen{}polarized case, which can give rise to non\sphinxhyphen{}zero \(M\) terms.

\sphinxAtStartPar
For the simplest case of an unaligned ensemble, this term is restricted to \(K=Q=S=0\), i.e. \(\Delta_{L,M}(0,0,0)\); for single\sphinxhyphen{}photon ionization with linearly\sphinxhyphen{}polarized light (\(p=0\), hence \(P=0,2\) and \(R=R'=0\)), this has non\sphinxhyphen{}zero values for \(L=0,2\) and \(M=0\) only. Typically, this simplest case is synonymous with standard {\hyperref[\detokenize{backmatter/glossary:term-LF}]{\sphinxtermref{\DUrole{xref,std,std-term}{LF}}}} results, and maintains cylindrical and up\sphinxhyphen{}down symmetry in the observable.

\sphinxAtStartPar
For circularly polarized light (\(p=\pm1\), hence \(P=0,1,2\) and \(R=R'=0\)), odd\sphinxhyphen{}\(L\) is allowed, signifying up/down symmetry breaking in the observable (where up/down pertains to the propagation direction of the light, conventionally the \(z\)\sphinxhyphen{}axis). For elliptically polarized light, mixing of terms with different \(p\) allows for non\sphinxhyphen{}zero \(R\) terms, hence non\sphinxhyphen{}zero \(M\) is allowed, signifying breaking of cylindrical symmetry in the observable.

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-output}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}*** Set range of ADMs for test as time\PYGZhy{}dependent values \PYGZhy{} single call}
\PYG{c+c1}{\PYGZsh{} AKQS = ep.setADMs(ADMs = [[0,0,0,1,1,1,1],}
\PYG{c+c1}{\PYGZsh{}                           [2,0,0,0,0.5,1,1],}
\PYG{c+c1}{\PYGZsh{}                           [4,0,0,0,0,0,0.3]])  \PYGZsh{}, t=[0,1,2])    \PYGZsh{} Nested list or np.array OK.}
\PYG{c+c1}{\PYGZsh{} AKQS = ep.setADMs(ADMs = np.array([[0,0,0,1,1],[2,0,0,0,0.5]]), t=[0,1])}

\PYG{c+c1}{\PYGZsh{}*** Alternative form with ADM inds separate}
\PYG{c+c1}{\PYGZsh{} ADMinds = np.array([[0,0,0],[2,0,0],[4,0,0]])}
\PYG{c+c1}{\PYGZsh{} AKQS = ep.setADMs(ADMs = np.stack((np.ones(4),np.linspace(0,1,4),np.linspace(0,0.2,4))),}
\PYG{c+c1}{\PYGZsh{}                   KQSLabels=ADMinds)}


\PYG{c+c1}{\PYGZsh{} For computation set ADMs and EPR term first.}
\PYG{c+c1}{\PYGZsh{} Note that delta term is independent of the absolute values of the ADMs(t), but does use this term to define limits on some quantum numbers.}

\PYG{c+c1}{\PYGZsh{}*** Neater version}
\PYG{c+c1}{\PYGZsh{} Set ADMs for increasing alignment...}
\PYG{n}{tPoints} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{inputADMs} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{n}{tPoints}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}     \PYG{c+c1}{\PYGZsh{} * np.sqrt(4*np.pi)],  \PYGZsh{} Optional multiplier for normalisation}
             \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{tPoints}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} 
             \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{n}{tPoints}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}
             \PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mf}{0.3}\PYG{p}{,}\PYG{n}{tPoints}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}
             \PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mf}{0.2}\PYG{p}{,}\PYG{n}{tPoints}\PYG{p}{)}\PYG{p}{]}\PYG{p}{]}

\PYG{n}{AKQS} \PYG{o}{=} \PYG{n}{ep}\PYG{o}{.}\PYG{n}{setADMs}\PYG{p}{(}\PYG{n}{ADMs} \PYG{o}{=} \PYG{n}{inputADMs}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} TODO WRAP TO CLASS (IF NOT ALREADY!)}


\PYG{c+c1}{\PYGZsh{}*** Plot ADMs}
\PYG{c+c1}{\PYGZsh{} daPlot, daPlotpd, legendList, gFig = ep.lmPlot(AKQS, xDim = \PYGZsq{}t\PYGZsq{}, pType = \PYGZsq{}r\PYGZsq{}, squeeze = False, thres=None, cmap=\PYGZsq{}vlag\PYGZsq{})  \PYGZsh{} Note squeeze = False required for 1D case (should add this to code!)}
\PYG{c+c1}{\PYGZsh{} daPlotpd}

\PYG{c+c1}{\PYGZsh{} Example alignment term, assuming all other terms allow/unity valued.}

\PYG{c+c1}{\PYGZsh{} Use default EPR term \PYGZhy{} note this computes for all pol states, p=[\PYGZhy{}1,0,1]}
\PYG{n}{EPR} \PYG{o}{=} \PYG{n}{ep}\PYG{o}{.}\PYG{n}{geomCalc}\PYG{o}{.}\PYG{n}{EPR}\PYG{p}{(}\PYG{n}{form}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{xarray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Compute alignment terms}
\PYG{n}{AFterm}\PYG{p}{,} \PYG{n}{DeltaTerm} \PYG{o}{=} \PYG{n}{ep}\PYG{o}{.}\PYG{n}{geomCalc}\PYG{o}{.}\PYG{n}{deltaLMKQS}\PYG{p}{(}\PYG{n}{EPR}\PYG{p}{,} \PYG{n}{AKQS}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}*** Plot Delta term with subselections}
\PYG{c+c1}{\PYGZsh{} xDim = \PYGZob{}\PYGZsq{}KQ\PYGZsq{}:[\PYGZsq{}K\PYGZsq{},\PYGZsq{}Q\PYGZsq{}]\PYGZcb{}}
\PYG{n}{xDim} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LM}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{L}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{M}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{\PYGZcb{}}
\PYG{n}{daPlot}\PYG{p}{,} \PYG{n}{daPlotpd}\PYG{p}{,} \PYG{n}{legendList}\PYG{p}{,} \PYG{n}{gFig} \PYG{o}{=} \PYG{n}{ep}\PYG{o}{.}\PYG{n}{lmPlot}\PYG{p}{(}\PYG{n}{DeltaTerm}\PYG{o}{.}\PYG{n}{sel}\PYG{p}{(}\PYG{n}{K}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{Q}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{S}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{Rp}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sel}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{S\PYGZhy{}Rp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{xDim} \PYG{o}{=} \PYG{n}{xDim}\PYG{p}{,} \PYG{n}{pType} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{squeeze} \PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{thres}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}, cmap=\PYGZsq{}vlag\PYGZsq{}) \PYGZsh{} , fillna=True)  \PYGZsh{} Note squeeze = False required for 1D case (should add this to code!)}
\PYG{c+c1}{\PYGZsh{} daPlotpd.fillna(\PYGZsq{}\PYGZsq{})}

\PYG{c+c1}{\PYGZsh{} Glue versions for JupyterBook output}
\PYG{n}{glue}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{deltaTerm000\PYGZhy{}lmPlot}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{gFig}\PYG{o}{.}\PYG{n}{fig}\PYG{p}{,} \PYG{n}{display}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\PYG{n}{glue}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{deltaTerm000\PYGZhy{}tab}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{daPlotpd}\PYG{o}{.}\PYG{n}{fillna}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{display}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} As above, but with PD object return and glue.}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{8617def9b4801c655e45ad191160b6afbf59b43d1800775e3840c455d08a3727}.png}
\caption{Example \(\Delta_{L,M}(0,0,0)\) basis functions (see also \hyperref[\detokenize{part1/theory_tensor_formalism_201122:tab-deltaterm000}]{Fig.\@ \ref{\detokenize{part1/theory_tensor_formalism_201122:tab-deltaterm000}}}). For illustration purposes, the plot only shows terms for \(R'=0\). See main text for discussion.}\label{\detokenize{part1/theory_tensor_formalism_201122:fig-deltaterm000}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart
\begin{equation*}
\begin{split}\begin{tabular}{lllllllllll}
\toprule
  & L &    0 & \multicolumn{3}{l}{1} & \multicolumn{5}{l}{2} \\
  & M &    0 &     -1 &      0 &      1 &   -2 &   -1 &    0 &    1 &    2 \\
P & R &      &        &        &        &      &      &      &      &      \\
\midrule
0 &  0 &  1.0 &        &        &        &      &      &      &      &      \\
1 & -1 &      &        &        & -0.333 &      &      &      &      &      \\
  &  0 &      &        &  0.333 &        &      &      &      &      &      \\
  &  1 &      & -0.333 &        &        &      &      &      &      &      \\
2 & -2 &      &        &        &        &      &      &      &      &  0.2 \\
  & -1 &      &        &        &        &      &      &      & -0.2 &      \\
  &  0 &      &        &        &        &      &      &  0.2 &      &      \\
  &  1 &      &        &        &        &      & -0.2 &      &      &      \\
  &  2 &      &        &        &        &  0.2 &      &      &      &      \\
\bottomrule
\end{tabular}\end{split}
\end{equation*}\caption{Example \(\Delta_{L,M}(0,0,0)\) basis functions (see also \hyperref[\detokenize{part1/theory_tensor_formalism_201122:fig-deltaterm000}]{Fig.\@ \ref{\detokenize{part1/theory_tensor_formalism_201122:fig-deltaterm000}}}). For illustration purposes, the table only shows terms for \(R'=0\). See main text for discussion.}\label{\detokenize{part1/theory_tensor_formalism_201122:tab-deltaterm000}}\end{figure}

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-output}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}*** Plot ADMs}
\PYG{n}{daPlot}\PYG{p}{,} \PYG{n}{daPlotpd}\PYG{p}{,} \PYG{n}{legendList}\PYG{p}{,} \PYG{n}{ADMFig} \PYG{o}{=} \PYG{n}{ep}\PYG{o}{.}\PYG{n}{lmPlot}\PYG{p}{(}\PYG{n}{AKQS}\PYG{p}{,} \PYG{n}{xDim} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pType} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{squeeze} \PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{vlag}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Note squeeze = False required for 1D case (should add this to code!)}
\PYG{c+c1}{\PYGZsh{} daPlotpd}

\PYG{c+c1}{\PYGZsh{}*** Plot subsection}
\PYG{n}{daPlot}\PYG{p}{,} \PYG{n}{daPlotpd}\PYG{p}{,} \PYG{n}{legendList}\PYG{p}{,} \PYG{n}{AFFig} \PYG{o}{=} \PYG{n}{ep}\PYG{o}{.}\PYG{n}{lmPlot}\PYG{p}{(}\PYG{n}{AFterm}\PYG{o}{.}\PYG{n}{sel}\PYG{p}{(}\PYG{n}{R}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sel}\PYG{p}{(}\PYG{n}{Rp}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sel}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{S\PYGZhy{}Rp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{,} 
                                               \PYG{n}{xDim} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pType} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{squeeze} \PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{vlag}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Note squeeze = False required for 1D case (should add this to code!)}

\PYG{c+c1}{\PYGZsh{} Glue versions for JupyterBook output}
\PYG{n}{glue}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ADMs\PYGZhy{}linearRamp\PYGZhy{}lmPlot}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ADMFig}\PYG{o}{.}\PYG{n}{fig}\PYG{p}{,} \PYG{n}{display}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\PYG{n}{glue}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{AFterm\PYGZhy{}linearRamp\PYGZhy{}lmPlot}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{AFFig}\PYG{o}{.}\PYG{n}{fig}\PYG{p}{,} \PYG{n}{display}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{6faa50b16e6c32dde498027193ccd0837c9680ab0622719792c4b605de89a33f}.png}
\caption{Example ADMs used for {\hyperref[\detokenize{backmatter/glossary:term-AF}]{\sphinxtermref{\DUrole{xref,std,std-term}{AF}}}} basis function example (see \hyperref[\detokenize{part1/theory_tensor_formalism_201122:fig-afterm-linearramp}]{Fig.\@ \ref{\detokenize{part1/theory_tensor_formalism_201122:fig-afterm-linearramp}}}). These ADMs essentially show an increasing degree of alignment with the \(t\) parameter, with high\sphinxhyphen{}order terms increasing at later \(t\).}\label{\detokenize{part1/theory_tensor_formalism_201122:fig-adms-linearramp}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{30dc5e8238a6787facf4cafdeffa6288715d26263b400cc240eafc4559e23a3d}.png}
\caption{Example of \(\tilde{\Delta}_{L,M}(t)\) basis values for various choices of alignment (as per \hyperref[\detokenize{part1/theory_tensor_formalism_201122:fig-adms-linearramp}]{Fig.\@ \ref{\detokenize{part1/theory_tensor_formalism_201122:fig-adms-linearramp}}}). The ADMs essentially show an increasing degree of alignment with the \(t\) parameter, with high\sphinxhyphen{}order terms increasing at later \(t\), and this is reflected in the \(\tilde{\Delta}_{L,M}(t)\) terms with higher\sphinxhyphen{}order \(L\) appearing at later \(t\).}\label{\detokenize{part1/theory_tensor_formalism_201122:fig-afterm-linearramp}}\end{figure}

\sphinxAtStartPar
For cases with aligned molecular ensembles, additional terms can similarly appear depending on the alignment as well as the properties of the ionizing radiation. Again, the types of terms follow some typical patterns dependent on the symmetry of the ensemble, as well as the order of the terms allowed. For instance, \(L_{max}=P_{max}+K_{max}=2+K_{max}\), and \(K_{max}\) represents the overall degree of alignment of the ensemble; hence an aligned ensemble may be signified by higher\sphinxhyphen{}order terms in the observable (if allowed by other terms in the overall expansion) or, equivalently, aligning an ensemble prior to ionization can be used as a way to control which terms contribute to the alignment tensor.

\sphinxAtStartPar
Since this is a coherent averaging, additional interferences can also appear in the {\hyperref[\detokenize{backmatter/glossary:term-AF}]{\sphinxtermref{\DUrole{xref,std,std-term}{AF}}}} \sphinxhyphen{} or be restricted in the {\hyperref[\detokenize{backmatter/glossary:term-AF}]{\sphinxtermref{\DUrole{xref,std,std-term}{AF}}}} \sphinxhyphen{} depending on these geometric parameters and the contributing matrix elements. Additionally, any effects modulating these terms, for instance a time\sphinxhyphen{}dependent alignment (rotational wavepacket), vibronic dynamics (vibrational and/or electronic wavepacket), time\sphinxhyphen{}dependent laser field (control field) may be anticipted to lead to both changes in these terms and, potentially, interesting effects in the observable. Such effects have been discussed in more detail in \sphinxstyleemphasis{Quantum Metrology} Vol. 2 {[}\hyperlink{cite.backmatter/bibliography:id570}{2}{]}, and in the current case the focus is purely on rotational wavepackets.

\sphinxAtStartPar
\hyperref[\detokenize{part1/theory_tensor_formalism_201122:fig-afterm-linearramp}]{Fig.\@ \ref{\detokenize{part1/theory_tensor_formalism_201122:fig-afterm-linearramp}}} shows \(\tilde{\Delta}_{L,M}(t)\) for various choices of alignment (as per the {\hyperref[\detokenize{backmatter/glossary:term-ADMs}]{\sphinxtermref{\DUrole{xref,std,std-term}{ADMs}}}} shown in \hyperref[\detokenize{part1/theory_tensor_formalism_201122:fig-adms-linearramp}]{Fig.\@ \ref{\detokenize{part1/theory_tensor_formalism_201122:fig-adms-linearramp}}}), and illustrates some of the general features discussed. Note, for example:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(L_{max}\) varies with alignment; in the demonstration case \(K_{max}=8\) at later times, resulting in \(L_{max}=10\), whilst at \(t=0\) \(K_{max}=0\), thus restricting terms to \(L_{max}=2\).

\item {} 
\sphinxAtStartPar
Odd\sphinxhyphen{}\(L\) values are correlated with \(P=1\) terms.

\item {} 
\sphinxAtStartPar
Only \(M=0\) terms are allowed in this case (\(Q=S=0\)).

\end{itemize}


\subsubsection{3D alignments and symmetry breaking}
\label{\detokenize{part1/theory_tensor_formalism_201122:d-alignments-and-symmetry-breaking}}\label{\detokenize{part1/theory_tensor_formalism_201122:sec-theory-af-alignment-term-3d}}
\sphinxAtStartPar
As discussed above, for the case where \(Q\neq0\) and/or \(S\neq0\) additional symmetry breaking can occur. It is simple to examine these effects numerically via changing the trial {\hyperref[\detokenize{backmatter/glossary:term-ADMs}]{\sphinxtermref{\DUrole{xref,std,std-term}{ADMs}}}} used to determine \(\tilde{\Delta}_{L,M}(t)\) (Eq. \eqref{equation:part1/theory_tensor_formalism_201122:eq:basis-aligmentTerm-defn}).

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-output}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}*** Neater version}
\PYG{c+c1}{\PYGZsh{} Set ADMs for increasing alignment...}
\PYG{n}{tPoints} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{inputADMs3D} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{n}{tPoints}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}     \PYG{c+c1}{\PYGZsh{} * np.sqrt(4*np.pi)],  \PYGZsh{} Optional multiplier for normalisation}
             \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{tPoints}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} 
             \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{n}{tPoints}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}
             \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{n}{tPoints}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}
             \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mf}{0.8}\PYG{p}{,}\PYG{n}{tPoints}\PYG{p}{)}\PYG{p}{]}\PYG{p}{]}

\PYG{n}{AKQS} \PYG{o}{=} \PYG{n}{ep}\PYG{o}{.}\PYG{n}{setADMs}\PYG{p}{(}\PYG{n}{ADMs} \PYG{o}{=} \PYG{n}{inputADMs3D}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} TODO WRAP TO CLASS (IF NOT ALREADY!)}

\PYG{c+c1}{\PYGZsh{} Compute alignment terms}
\PYG{n}{AFterm}\PYG{p}{,} \PYG{n}{DeltaTerm} \PYG{o}{=} \PYG{n}{ep}\PYG{o}{.}\PYG{n}{geomCalc}\PYG{o}{.}\PYG{n}{deltaLMKQS}\PYG{p}{(}\PYG{n}{EPR}\PYG{p}{,} \PYG{n}{AKQS}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}*** Plot all}
\PYG{c+c1}{\PYGZsh{} daPlot, daPlotpd, legendList, gFig = ep.lmPlot(AFterm,    \PYGZsh{}.sel(R=0).sel(Rp=0), }
\PYG{c+c1}{\PYGZsh{}                                                xDim = \PYGZsq{}t\PYGZsq{}, pType = \PYGZsq{}r\PYGZsq{}, squeeze = False, cmap=\PYGZsq{}vlag\PYGZsq{})  \PYGZsh{} Note squeeze = False required for 1D case (should add this to code!)}


\PYG{c+c1}{\PYGZsh{}*** Plot subsection, L\PYGZlt{}=2}
\PYG{c+c1}{\PYGZsh{} .sel(R=0).sel(Rp=0) gives M=0 terms only for R=Rp=0}
\PYG{c+c1}{\PYGZsh{} .sel(R=0) gives M=0 terms only}
\PYG{c+c1}{\PYGZsh{} .sel(Rp=0) gives M!=0 terms, S\PYGZhy{}Rp=0 terms only}

\PYG{n}{daPlot}\PYG{p}{,} \PYG{n}{daPlotpd}\PYG{p}{,} \PYG{n}{legendList}\PYG{p}{,} \PYG{n}{gFig} \PYG{o}{=} \PYG{n}{ep}\PYG{o}{.}\PYG{n}{lmPlot}\PYG{p}{(}\PYG{n}{AFterm}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{AFterm}\PYG{o}{.}\PYG{n}{L}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sel}\PYG{p}{(}\PYG{n}{Rp}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}    \PYG{c+c1}{\PYGZsh{} .sel(R=0).sel(Rp=0), \PYGZsh{}M=0 for R=Rp=0}
                                               \PYG{n}{xDim} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pType} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{squeeze} \PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{vlag}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Note squeeze = False required for 1D case (should add this to code!)}

\PYG{c+c1}{\PYGZsh{} Glue versions for JupyterBook output}
\PYG{n}{glue}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ADMs\PYGZhy{}3DlinearRamp\PYGZhy{}lmPlot}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ADMFig}\PYG{o}{.}\PYG{n}{fig}\PYG{p}{,} \PYG{n}{display}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{6faa50b16e6c32dde498027193ccd0837c9680ab0622719792c4b605de89a33f}.png}
\caption{Example \(\tilde{\Delta}_{L,M}(t)\) basis values for various choices of “3D” alignment, i.e. including some \(K\neq0\) and \(S\neq0\) terms. Note, in particular, the presence of \(M\neq0\) terms in general, and a complicated dependence of the allowed terms on the alignment ({\hyperref[\detokenize{backmatter/glossary:term-ADMs}]{\sphinxtermref{\DUrole{xref,std,std-term}{ADMs}}}}), which may increase, decrease, or even change sign for a given \(L,M\).}\label{\detokenize{part1/theory_tensor_formalism_201122:fig-adms-3dlinearramp}}\end{figure}

\sphinxAtStartPar
For illustration purposes, \hyperref[\detokenize{part1/theory_tensor_formalism_201122:fig-adms-3dlinearramp}]{Fig.\@ \ref{\detokenize{part1/theory_tensor_formalism_201122:fig-adms-3dlinearramp}}} shows a subselection of the \(\tilde{\Delta}_{L,M}(t)\) basis values, indicating some of the key features in the full 3D case, subselected for \(L\leq2\) and \(R'=0\) terms only.

\sphinxAtStartPar
Note, in particular, the presence of \(M\neq0\) terms in general, and a complicated dependence of the allowed terms on the alignment, which may increase, decrease, or even change sign. \% TODO: give more explict examples here, may want to also reduce and consolidate illustrations further?
As previously, these behaviours are generally useful for understanding specific cases or planning experiments for specific systems; this is explored further in Part II which focuses on the results for particular molecules (hence symmetries and sets of matrix elements).


\subsection{Tensor product terms}
\label{\detokenize{part1/theory_tensor_formalism_201122:tensor-product-terms}}\label{\detokenize{part1/theory_tensor_formalism_201122:sec-theory-tensor-products}}
\sphinxAtStartPar
Following the above, further resultant terms can also be examined, up to and including the full channel functions \(\varUpsilon_{L,M}^{u,\zeta\zeta'}\) (see \eqref{equation:part1/theory_tensor_formalism_201122:eqn:channel-fns}) for a given case. Numerically these are all implemented in the main \sphinxhref{https://epsproc.readthedocs.io}{ePSproc codebase} {[}\hyperlink{cite.backmatter/bibliography:id561}{12}, \hyperlink{cite.backmatter/bibliography:id508}{13}, \hyperlink{cite.backmatter/bibliography:id506}{14}{]}, and can be returned by these functions for inspection \sphinxhyphen{} the full basis set already defined includes some of these product. Custom tensor product terms are also readily computed with the codebase, with tensor multiplications handled natively by the Xarray data objects.

\sphinxAtStartPar
Polarisation \& ADM product term: the main product basis returned, \sphinxcode{\sphinxupquote{polProd}}, contains the tensor product \(\Lambda_{R}\otimes E_{PR}(\hat{e})\otimes \Delta_{L,M}(K,Q,S)\otimes A^{K}_{Q,S}(t)\), expanded over all quantum numbers (see \sphinxhref{https://epsproc.readthedocs.io/en/dev/methods/geometric\_method\_dev\_pt3\_AFBLM\_090620\_010920\_dev\_bk100920.html\#\%5Cbeta\_\%7BL,M\%7D\%5E\%7BAF\%7D-rewrite}{full definition here}). This term, therefore, incorporates all of the dependence (or response) of the AF\sphinxhyphen{}\(\beta_{LM}\)s on the polarisation state, and the axis distribution. Example results, making use of the linear\sphinxhyphen{}ramp {\hyperref[\detokenize{backmatter/glossary:term-ADMs}]{\sphinxtermref{\DUrole{xref,std,std-term}{ADMs}}}} of \hyperref[\detokenize{part1/theory_tensor_formalism_201122:sec-theory-af-alignment-term-basic}]{Sect.\@ \ref{\detokenize{part1/theory_tensor_formalism_201122:sec-theory-af-alignment-term-basic}}} are illustrated in \hyperref[\detokenize{part1/theory_tensor_formalism_201122:fig-polprod-linearramp}]{Fig.\@ \ref{\detokenize{part1/theory_tensor_formalism_201122:fig-polprod-linearramp}}}.

\sphinxAtStartPar
The full channel (response) functions \(\varUpsilon_{L,M}^{u,\zeta\zeta'}\) as defined in \eqref{equation:part1/theory_tensor_formalism_201122:eq:channelFunc-MF-defn} and \eqref{equation:part1/theory_tensor_formalism_201122:eq:channelFunc-AF-defn} can be determined by the product of this term with the \(B_{L,M}\) tensor. This is essentially the complete geometric basis set,

\sphinxAtStartPar
hence equivalent to the AF\sphinxhyphen{}\(\beta_{LM}\) if the ionization matrix elements were set to unity. This illustrates not only the coupling of the geometric terms into the observable \(L,M\), but also how the partial wave \(|l,m\rangle\) terms map to the observables, and hence the sensitivity of the observables to given partial wave properties. Example results, making use of the linear\sphinxhyphen{}ramp {\hyperref[\detokenize{backmatter/glossary:term-ADMs}]{\sphinxtermref{\DUrole{xref,std,std-term}{ADMs}}}} of \hyperref[\detokenize{part1/theory_tensor_formalism_201122:sec-theory-af-alignment-term-basic}]{Sect.\@ \ref{\detokenize{part1/theory_tensor_formalism_201122:sec-theory-af-alignment-term-basic}}} are illustrated in \hyperref[\detokenize{part1/theory_tensor_formalism_201122:fig-channelfunc-linearramp}]{Fig.\@ \ref{\detokenize{part1/theory_tensor_formalism_201122:fig-channelfunc-linearramp}}}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Set data \PYGZhy{} set example ADMs to data structure \PYGZam{} subset for calculation}
\PYG{n}{data}\PYG{o}{.}\PYG{n}{setADMs}\PYG{p}{(}\PYG{n}{ADMs} \PYG{o}{=} \PYG{n}{inputADMs}\PYG{p}{)}
\PYG{n}{data}\PYG{o}{.}\PYG{n}{setSubset}\PYG{p}{(}\PYG{n}{dataKey} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ADM}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{dataType} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ADM}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Using PEMtk \PYGZhy{} this only returns the product basis set as used for fitting}
\PYG{n}{BetaNormX}\PYG{p}{,} \PYG{n}{basisProduct} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{afblmMatEfit}\PYG{p}{(}\PYG{n}{selDims}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{sqThres}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Subselected from dataset \PYGZsq{}ADM\PYGZsq{}, dataType \PYGZsq{}ADM\PYGZsq{}: 50 from 50 points (100.00\PYGZpc{})
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-output}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{basisKey} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{polProd}\PYG{l+s+s1}{\PYGZsq{}}  \PYG{c+c1}{\PYGZsh{} Key for BLM basis set}

\PYG{c+c1}{\PYGZsh{} Reformat basis for display (optional)}
\PYG{c+c1}{\PYGZsh{} stackDims = \PYGZob{}\PYGZsq{}LM\PYGZsq{}:[\PYGZsq{}L\PYGZsq{},\PYGZsq{}M\PYGZsq{}]\PYGZcb{}}
\PYG{c+c1}{\PYGZsh{} basisPlot = basis[basisKey].rename(\PYGZob{}\PYGZsq{}S\PYGZhy{}Rp\PYGZsq{}:\PYGZsq{}M\PYGZsq{}\PYGZcb{}).stack(stackDims)}

\PYG{c+c1}{\PYGZsh{} Convert to Pandas}
\PYG{c+c1}{\PYGZsh{} pd, \PYGZus{} = ep.multiDimXrToPD(basisPlot, colDims=stackDims)}

\PYG{c+c1}{\PYGZsh{} Subselect on pol state}
\PYG{n}{daPlot}\PYG{p}{,} \PYG{n}{daPlotpd}\PYG{p}{,} \PYG{n}{legendList}\PYG{p}{,} \PYG{n}{gFig} \PYG{o}{=} \PYG{n}{ep}\PYG{o}{.}\PYG{n}{lmPlot}\PYG{p}{(}\PYG{n}{basisProduct}\PYG{p}{[}\PYG{n}{basisKey}\PYG{p}{]}\PYG{o}{.}\PYG{n}{sel}\PYG{p}{(}\PYG{n}{Labels}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{xDim}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{cmap} \PYG{o}{=} \PYG{n}{cmap}\PYG{p}{,} \PYG{n}{mDimLabel}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mu}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{\PYGZsh{} , cmap=\PYGZsq{}vlag\PYGZsq{});  \PYGZsh{} Subselect on pol state}
\PYG{c+c1}{\PYGZsh{} ep.lmPlot(basisProduct[basisKey], xDim=\PYGZsq{}t\PYGZsq{}, cmap = cmap); \PYGZsh{} , cmap=\PYGZsq{}vlag\PYGZsq{});  \PYGZsh{} Subselect on pol state}

\PYG{c+c1}{\PYGZsh{} Glue versions for JupyterBook output}
\PYG{n}{glue}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{polProd\PYGZhy{}linearRamp\PYGZhy{}lmPlot}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{gFig}\PYG{o}{.}\PYG{n}{fig}\PYG{p}{,} \PYG{n}{display}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-output}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Channel functions}
\PYG{n}{daPlot}\PYG{p}{,} \PYG{n}{daPlotpd}\PYG{p}{,} \PYG{n}{legendList}\PYG{p}{,} \PYG{n}{gFig} \PYG{o}{=}  \PYG{n}{ep}\PYG{o}{.}\PYG{n}{lmPlot}\PYG{p}{(}\PYG{p}{(}\PYG{n}{basisProduct}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{BLMtableResort}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{*} \PYG{n}{basisProduct}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{polProd}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sel}\PYG{p}{(}\PYG{n}{Labels}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sel}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{S\PYGZhy{}Rp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sel}\PYG{p}{(}\PYG{n}{L}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{xDim}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{,} \PYG{n}{mDimLabel}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{m}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{\PYGZsh{} Basic case}
\PYG{c+c1}{\PYGZsh{} ep.lmPlot((basis[\PYGZsq{}BLMtableResort\PYGZsq{}] * basis[\PYGZsq{}polProd\PYGZsq{}]), xDim=\PYGZsq{}t\PYGZsq{}, cmap=\PYGZsq{}vlag\PYGZsq{});}

\PYG{c+c1}{\PYGZsh{} Glue versions for JupyterBook output}
\PYG{n}{glue}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{channelFunc\PYGZhy{}linearRamp\PYGZhy{}lmPlot}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{gFig}\PYG{o}{.}\PYG{n}{fig}\PYG{p}{,} \PYG{n}{display}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{dc52eda4839ef92e0bd42e710dcebaf1753faa2a7063a7fd4a2c99b8666b4d0b}.png}
\caption{Example product basis function for the polarisation and ADM terms.}\label{\detokenize{part1/theory_tensor_formalism_201122:fig-polprod-linearramp}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{33f17b18ddf9e22605b75c34c5a55ab35e721af79ecca54469259b5c1e0a4945}.png}
\caption{Example of \(\bar{\varUpsilon_{}}_{L,M}^{u,\zeta\zeta'}\) basis values for various choices of alignment (as per \hyperref[\detokenize{part1/theory_tensor_formalism_201122:fig-adms-linearramp}]{Fig.\@ \ref{\detokenize{part1/theory_tensor_formalism_201122:fig-adms-linearramp}}}), shown for \(L=2\) only. The basis essentially shows the obsevable terms if the ionization matrix elements are neglected, hence the sensitivity of the configuration to each pair of partial wave terms. Note, in general, that the sensitivity to any given pair \$\(\langle l',m'|l,m\rangle\), increases with alignment (hence with \(t\) in this example) for the linear polarisation case (\(\mu=\mu'=0\)), but typically decreases with alignment for cross\sphinxhyphen{}polarised terms.}\label{\detokenize{part1/theory_tensor_formalism_201122:fig-channelfunc-linearramp}}\end{figure}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{!}date
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Wed 29 Mar 2023 02:05:22 PM EDT
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\section{Density matrix representation}
\label{\detokenize{part1/theory_density_matrices_310123:density-matrix-representation}}\label{\detokenize{part1/theory_density_matrices_310123:sec-density-mat-basic}}\label{\detokenize{part1/theory_density_matrices_310123::doc}}

\subsection{General introduction}
\label{\detokenize{part1/theory_density_matrices_310123:general-introduction}}\label{\detokenize{part1/theory_density_matrices_310123:sec-density-mat-intro}}
\sphinxAtStartPar
For a general introduction, and discussion of density matrix techniques and applications in AMO physics, see Blum’s textbook \sphinxstyleemphasis{Density Matrix Theory and Applications} {[}\hyperlink{cite.backmatter/bibliography:id444}{52}{]}, which is referred to extensively herein. The general density operator, for a mixture of independent states \(|\psi_{n}\rangle\), can be defined as per Eqn. 2.8 in Blum {[}\hyperlink{cite.backmatter/bibliography:id444}{52}{]}:
\begin{equation*}
\begin{split}
\hat{\rho}=\sum_{n}W_{n}|\psi_{n}\rangle\langle\psi_{n}|
\end{split}
\end{equation*}
\sphinxAtStartPar
Where \(W_{n}\) defines the (statistical) weighting of each state \(\psi_{n}\) in the mixture.

\sphinxAtStartPar
For a given basis set, \(|\phi_{m}\rangle\), the states can be expanded and the matrix elements of \(\rho\) defined as per Eqns. 2.9 \sphinxhyphen{} 2.11 in Blum {[}\hyperlink{cite.backmatter/bibliography:id444}{52}{]}:
\begin{equation*}
\begin{split}
| \psi_{n} \rangle = \sum_{m'} a_{m'}^{(n)}| \phi_{m'}\rangle
\end{split}
\end{equation*}\begin{equation}\label{equation:part1/theory_density_matrices_310123:eqn:density-mat-outer-prod}
\begin{split}
\hat{\rho}=\sum_{n}\sum_{mm'}W_{n}a_{m'}^{(n)}a_{m}^{(n)*}|\phi_{m'}\rangle\langle\phi_{m}|
\end{split}
\end{equation}
\sphinxAtStartPar
And the matrix elements \sphinxhyphen{} \sphinxstyleemphasis{the density matrix} \sphinxhyphen{} given explicitly as:
\begin{equation}\label{equation:part1/theory_density_matrices_310123:eqn:density-mat-generic}
\begin{split}
\rho_{i,j}=\langle\phi_{i}|\hat{\rho}|\phi_{j}\rangle=\sum_{n}W_{n}a_{i}^{(n)}a_{j}^{(n)*}
\end{split}
\end{equation}
\sphinxAtStartPar
For all pairs of basis states \((i,j)\). This defines the density matrix in the \(\{|\phi_n\rangle\}\) \sphinxstyleemphasis{representation} (basis space). Of particular note here is that the mixed states are assumed to be incoherent (independent), whilst the basis expansion is coherent.


\subsection{Continuum density matrices}
\label{\detokenize{part1/theory_density_matrices_310123:continuum-density-matrices}}\label{\detokenize{part1/theory_density_matrices_310123:id4}}
\sphinxAtStartPar
In general, the discussion herein will focus on the photoelectron properties and generally assume a single final ion, and associated free\sphinxhyphen{}electron state of interest, hence the final state (Eq. \eqref{equation:part1/theory_photoionization_dynamics_191122:eq:continuum-state-vec}) can be simplified to \(|\Psi_f\rangle\equiv|\mathbf{k}\rangle\). This is equivalent to a “pure state” in density matrix terminology, which can then expanded (coherently) in an appropriate representation (basis). Following this, the density operator associated with the continuum state can be written as \(\hat{\rho}=|\Psi_f\rangle\langle\Psi_f|\equiv|\mathbf{k}\rangle\langle\mathbf{k}|\). Making use of the tensor notation introduced in \hyperref[\detokenize{part1/theory_tensor_formalism_201122:sec-tensor-formulation}]{Sect.\@ \ref{\detokenize{part1/theory_tensor_formalism_201122:sec-tensor-formulation}}}, the final continuum state can then be expanded as a density matrix in the \(\zeta\zeta'\) representation (with the observable dimensions \(\{L,M\}\) explicitly included in the density matrix), which will also be dependent on the choice of channel functions (\(u\)); the density matrix can then be given as:
\begin{equation}\label{equation:part1/theory_density_matrices_310123:eqn:full-density-mat}
\begin{split}
{\rho}_{L,M}^{u,\zeta\zeta'}=\varUpsilon_{L,M}^{u,\zeta\zeta'}\mathbb{I}^{\zeta,\zeta'}
\end{split}
\end{equation}
\sphinxAtStartPar
Here the density matrix can be interpreted as the final, LF/AF or MF density matrix (depending on the channel functions used), incorporating both the intrinsic and extrinsic effects (i.e. all channel couplings and radial matrix elements for the given measurement), with dimensions dependent on the unique sets of quantum numbers required \sphinxhyphen{} in the simplest case, this will just be a set of partial waves \(\zeta = \{l,m\}\).

\sphinxAtStartPar
In the channel function basis, a radial, or reduced, form of the density matrix can also be constructed, and is given by the coherent product of the radial matrix elements (as defined in Eq. \eqref{equation:part1/theory_tensor_formalism_201122:eqn:I-zeta}):
\begin{equation}\label{equation:part1/theory_density_matrices_310123:eqn:radial-density-mat}
\begin{split}
\rho^{\zeta\zeta'} = \mathbb{I}^{\zeta,\zeta'}
\end{split}
\end{equation}
\sphinxAtStartPar
This form encodes purely intrinsic (molecular scattering) photoionization dynamics (thus characterises the scattering event), whilst the full form \({\rho}_{L,M}^{u,\zeta\zeta'}\) of Eq. \eqref{equation:part1/theory_density_matrices_310123:eqn:full-density-mat} includes any additional effects incorporated via the channel functions. For reconstruction problems, it is usually the reduced form of Eq. \eqref{equation:part1/theory_density_matrices_310123:eqn:radial-density-mat} that is of interest, since the remainder of the problem is already described analytically by the channel functions \(\varUpsilon_{L,M}^{u,\zeta\zeta'}\). In other words, the retrieval of the radial matrix elements \(\mathbb{I}^{\zeta,\zeta'}\) and the radial density matrix \(\rho^{\zeta\zeta'}\) are equivalent, and both can be viewed as completely describing the photoionization dynamics.

\sphinxAtStartPar
The \(L,M\) notation for the full density matrix \({\rho}_{L,M}^{u,\zeta\zeta'}\) (Eq. \eqref{equation:part1/theory_density_matrices_310123:eqn:full-density-mat}) indicates here that these dimensions should not be summed over, hence the tensor coupling into the \(\beta_{L,M}^{u}\) parameters can also be written directly in terms of the density matrix (cf. Eq. \eqref{equation:part1/theory_tensor_formalism_201122:eqn:channel-fns}):
\begin{equation}\label{equation:part1/theory_density_matrices_310123:eqn:beta-density-mat}
\begin{split}
\beta_{L,M}^{u}=\sum_{\zeta,\zeta'}{\rho}_{L,M}^{u,\zeta\zeta'}
\end{split}
\end{equation}
\sphinxAtStartPar
In fact, this form arises naturally since the \(\beta_{L,M}^{u}\) terms are the state multipoles (geometric tensors) defining the system, which can be thought of as a coupled basis equivalent of the density matrix representations (see, e.g., Ref. {[}\hyperlink{cite.backmatter/bibliography:id444}{52}{]}, Chpt. 4.).

\sphinxAtStartPar
In a more traditional notation (following Eq. \eqref{equation:part1/theory_photoionization_dynamics_191122:eq:continuum-state-vec}, see also Ref. {[}\hyperlink{cite.backmatter/bibliography:id536}{54}{]}), the density operator can be expressed as:
\begin{equation}\label{equation:part1/theory_density_matrices_310123:eqn:full-density-mat-traditional}
\begin{split}
\rho(t) =\sum_{LM}\sum_{KQS}A^{K}_{QS}(t)\sum_{\zeta\zeta^{\prime}}\varUpsilon_{L,M}^{u,\zeta\zeta'}|\zeta,\Psi_+\rangle\langle\zeta,\Psi_+|\mu_q\rho_i\mu_{q\prime}^{*}|\zeta^{\prime},\Psi_+\rangle\langle\zeta^{\prime},\Psi_+|
\end{split}
\end{equation}
\sphinxAtStartPar
This is, effectively, equivalent to an expansion in the various tensor operators defined in the channel function notation above (Eq. \eqref{equation:part1/theory_density_matrices_310123:eqn:full-density-mat}), but in a standard state\sphinxhyphen{}vector notation. Note, also, that this form explicitly defines the initial state of the system as a density matrix \(\rho_i = |\Psi_i\rangle\langle\Psi_i|\), and explicitly allows for time\sphinxhyphen{}dependence via the \(A_{Q,S}^{K}(t)\) term. (For further discussion of the use of density matrices in other specific cases, see \sphinxstyleemphasis{Quantum Metrology} Vol. 1 {[}\hyperlink{cite.backmatter/bibliography:id569}{1}{]}, particularly Chpts. 2 \& 3, and refs. therein.)

\sphinxAtStartPar
The main benefit of a (continuum) density matrix representation in the current work is as a rapid way to visualize the phase relations between the photoionization matrix elements (the off\sphinxhyphen{}diagonal density matrix elements), and the ability to quickly check the overall pattern of the elements, hence confirm that no phase\sphinxhyphen{}relations are missing and orthogonality relations are fulfilled \sphinxhyphen{} some numerical examples are given below. Since the method for computing the density matrices is also numerically equivalent to a tensor outer\sphinxhyphen{}product, density matrices and visualizations can also be rapidly composed for other properties of interest, e.g. the various channel functions defined herein, providing another complementary methodology and tool for investigation. (Further examples can be found in the \sphinxhref{https://epsproc.readthedocs.io}{ePSproc documentation} {[}\hyperlink{cite.backmatter/bibliography:id506}{14}{]}, as well as in the literature, see, e.g., Ref. {[}\hyperlink{cite.backmatter/bibliography:id444}{52}{]} for general discussion, Ref. {[}\hyperlink{cite.backmatter/bibliography:id694}{45}{]} for application in pump\sphinxhyphen{}probe schemes.)

\sphinxAtStartPar
Furthermore, as noted above, the density matrix elements provide a complete description of the photoionization event, and hence make clear the equivalence of the “complete” photoionization experiments (and associated continuum reconstruction methods) discussed herein, with general quantum tomography schemes {[}\hyperlink{cite.backmatter/bibliography:id654}{55}{]}. The density matrix can also be used as the starting point for further analysis based on standard density matrix techniques \sphinxhyphen{} this is discussed, for instance, in Ref. {[}\hyperlink{cite.backmatter/bibliography:id444}{52}{]}, and can also be viewed as a bridge between traditional methods in spectroscopy and AMO physics, and more recent concepts in the quantum information sciences (see, e.g., Refs. {[}\hyperlink{cite.backmatter/bibliography:id770}{56}, \hyperlink{cite.backmatter/bibliography:id820}{57}{]} for recent discussions in this context).


\subsection{Numerical setup}
\label{\detokenize{part1/theory_density_matrices_310123:numerical-setup}}
\sphinxAtStartPar
This follows the setup in \hyperref[\detokenize{part1/theory_tensor_formalism_201122:sec-tensor-formulation}]{Sect.\@ \ref{\detokenize{part1/theory_tensor_formalism_201122:sec-tensor-formulation}}} {\hyperref[\detokenize{part1/theory_tensor_formalism_201122:sec-tensor-formulation}]{\sphinxcrossref{\DUrole{std,std-ref}{Tensor formulation of photoionization}}}}, using a symmetry\sphinxhyphen{}based set of basis functions for demonstration purposes. (Repeated code is hidden in PDF version.)


\subsection{Compute a density matrix}
\label{\detokenize{part1/theory_density_matrices_310123:compute-a-density-matrix}}
\sphinxAtStartPar
A basic density matrix computation routine is implemented in the \sphinxhref{https://epsproc.readthedocs.io}{ePSproc codebase} {[}\hyperlink{cite.backmatter/bibliography:id561}{12}, \hyperlink{cite.backmatter/bibliography:id508}{13}, \hyperlink{cite.backmatter/bibliography:id506}{14}{]}. This makes use of input tensor arrays, and computes the density matrix as an outer\sphinxhyphen{}product of the defined dimension(s). The numerics essentially compute the outer product from the specified dimensions, which can be written generally as per Eqns. \eqref{equation:part1/theory_density_matrices_310123:eqn:density-mat-outer-prod}, \eqref{equation:part1/theory_density_matrices_310123:eqn:density-mat-generic}, where \(a_{i}^{(n)}a_{j}^{(n)*}\) are the values along the specified dimensions/state vector/representation. These dimensions must be in input arrays, but will be restacked as necessary to define the effective basis space, and all coherent pairs will be computed.

\sphinxAtStartPar
For instance, considering the ionization matrix elements demonstrated herein, setting indexes (quantum numbers) as \sphinxcode{\sphinxupquote{{[}l,m{]}}} will select the \(|\zeta\rangle = |l,m\rangle\) basis,

\sphinxAtStartPar
hence define the density operator as \(\hat{\rho} = |\zeta\rangle \langle\zeta'| = |l,m\rangle\langle l',m'|\) and the corresponding density matrix elements \(\rho^{\zeta,\zeta'}=\langle\zeta|\hat{\rho}|\zeta'\rangle=a_{l,m}a_{l',m'}^{*}\). Similarly, setting \sphinxcode{\sphinxupquote{{[}'l','m','mu'{]}}} will set the \(|\zeta\rangle = |l,m,\mu\rangle\) as the basis vector and so forth, where \(|\zeta\rangle\) is used as a generic state vector denoting all required quantum numbers. Additionally, other quantum numbers/dimensions can be kept, summed or selected from the input tensors prior to computation, thus density matrices can be readily computed as a function of other parameters, or averaged, according to the properties of interest, experimental parameters and observables.

\sphinxAtStartPar
Note, however, that this selection is purely based on the numerics, which compute the outer product along the defined dimensions \(|\zeta\rangle\langle\zeta'|\) to form the density matrix, hence does not guarantee a well\sphinxhyphen{}formed density matrix in the strictest sense (depending on the basis set), although will always present a basis state correlation matrix of sorts. A brief example, for the  defined matrix element is given below; for more examples see the \sphinxhref{https://epsproc.readthedocs.io}{ePSproc documentation} {[}\hyperlink{cite.backmatter/bibliography:id506}{14}{]}.

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-output}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} See the docs for more, https://epsproc.readthedocs.io/en/dev/methods/density\PYGZus{}mat\PYGZus{}notes\PYGZus{}demo\PYGZus{}300821.html}

\PYG{c+c1}{\PYGZsh{} Import routines for density calculation and plotting}
\PYG{k+kn}{from} \PYG{n+nn}{epsproc}\PYG{n+nn}{.}\PYG{n+nn}{calc} \PYG{k+kn}{import} \PYG{n}{density}

\PYG{c+c1}{\PYGZsh{}*** Compose density matrix}

\PYG{c+c1}{\PYGZsh{} Set dimensions/state vector/representation}
\PYG{c+c1}{\PYGZsh{} These must be in original data, but will be restacked as necessary to define the effective basis space.}
\PYG{n}{denDims} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LM}\PYG{l+s+s1}{\PYGZsq{}}  \PYG{c+c1}{\PYGZsh{} Set dimensions for density matrix. Note stacked dims are OK, in this case LM = \PYGZob{}l,m\PYGZcb{}}
\PYG{n}{selDims} \PYG{o}{=} \PYG{k+kc}{None}  \PYG{c+c1}{\PYGZsh{} Select on any other dimensions?}
\PYG{n}{sumDims} \PYG{o}{=} \PYG{k+kc}{None}  \PYG{c+c1}{\PYGZsh{} Sum over any other dimensions? (Set sumDims=True to sum over all dims except denDims.)}
\PYG{n}{pTypes}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{i}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} Plotting types \PYGZsq{}r\PYGZsq{}=real, \PYGZsq{}i\PYGZsq{}=imaginary}
\PYG{n}{thres} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}4}    \PYG{c+c1}{\PYGZsh{} Threshold for outputs (otherwise set to zero and/or dropped from result)}
\PYG{n}{normME} \PYG{o}{=} \PYG{k+kc}{False}  \PYG{c+c1}{\PYGZsh{} Normalise matrix elements before computing?}
\PYG{n}{normDen} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{max}\PYG{l+s+s1}{\PYGZsq{}} \PYG{c+c1}{\PYGZsh{} Method to normalise density matrix}

\PYG{c+c1}{\PYGZsh{} Calculate \PYGZhy{} Ref case}
\PYG{n}{k} \PYG{o}{=} \PYG{n}{sym}
\PYG{n}{matE} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{matE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Set data from main class instance by key}

\PYG{c+c1}{\PYGZsh{} Normalise input matrix elements?}
\PYG{k}{if} \PYG{n}{normME}\PYG{p}{:}
    \PYG{n}{matE} \PYG{o}{=} \PYG{n}{matE}\PYG{o}{/}\PYG{n}{matE}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}*** Compute density matrix for given parameters}
\PYG{c+c1}{\PYGZsh{} See demo at https://epsproc.readthedocs.io/en/latest/methods/density\PYGZus{}mat\PYGZus{}notes\PYGZus{}demo\PYGZus{}300821.html}
\PYG{c+c1}{\PYGZsh{} API docs https://epsproc.readthedocs.io/en/latest/modules/epsproc.calc.density.html\PYGZsh{}epsproc.calc.density.densityCalc}
\PYG{n}{daOut}\PYG{p}{,} \PYG{o}{*}\PYG{n}{\PYGZus{}} \PYG{o}{=} \PYG{n}{density}\PYG{o}{.}\PYG{n}{densityCalc}\PYG{p}{(}\PYG{n}{matE}\PYG{p}{,} \PYG{n}{denDims} \PYG{o}{=} \PYG{n}{denDims}\PYG{p}{,} \PYG{n}{selDims} \PYG{o}{=} \PYG{n}{selDims}\PYG{p}{,} \PYG{n}{thres} \PYG{o}{=} \PYG{n}{thres}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Renormlise output?}
\PYG{k}{if} \PYG{n}{normDen}\PYG{o}{==}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{max}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
    \PYG{n}{daOut} \PYG{o}{=} \PYG{n}{daOut}\PYG{o}{/}\PYG{n}{daOut}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{elif} \PYG{n}{normDen}\PYG{o}{==}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{trace}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
    \PYG{n}{daOut} \PYG{o}{=} \PYG{n}{daOut}\PYG{o}{/}\PYG{p}{(}\PYG{n}{daOut}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Sym}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{pipe}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{trace}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Need sym sum here to get 2D trace}

\PYG{c+c1}{\PYGZsh{} Plot density matrix with Holoviews}
\PYG{c+c1}{\PYGZsh{} Note sum over \PYGZsq{}Sym\PYGZsq{} dimension to flatten plot to (l,m) dims only.}
\PYG{n}{daPlot} \PYG{o}{=} \PYG{n}{density}\PYG{o}{.}\PYG{n}{matPlot}\PYG{p}{(}\PYG{n}{daOut}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Sym}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{pTypes}\PYG{o}{=}\PYG{n}{pTypes}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{deedb9a45fe875bec49734526ce33cb6ac456fc23a2a0727178716b8d49a2984}.png}
\caption{Example density matrix, computed from matrix elements defined purely by  symmetry. Note in this case only the real part is non\sphinxhyphen{}zero. Axes labels give terms \(\{L,M\}\) and \(\{L',M'\}\).}\label{\detokenize{part1/theory_density_matrices_310123:fig-denmatd2hrealonly}}\end{figure}


\subsection{Visualising matrix element reconstruction fidelity with density matrices}
\label{\detokenize{part1/theory_density_matrices_310123:visualising-matrix-element-reconstruction-fidelity-with-density-matrices}}
\sphinxAtStartPar
To demonstrate the use of the density matrix representation as a means to test similarity or fidelity between two sets of matrix elements, a trial set of matrix elements can be derived from the original set used above, plus random noise, and the differences in the density matrices directly computed. An example is shown in \hyperref[\detokenize{part1/theory_density_matrices_310123:fig-denmatd2hcompexample}]{Fig.\@ \ref{\detokenize{part1/theory_density_matrices_310123:fig-denmatd2hcompexample}}}; in this example up to 10\% random noise has been added to the original (input) matrix elements, and the resultant density matrix computed. The difference matrix (\hyperref[\detokenize{part1/theory_density_matrices_310123:fig-denmatd2hcompexample}]{Fig.\@ \ref{\detokenize{part1/theory_density_matrices_310123:fig-denmatd2hcompexample}}}(c)) then provides the fidelity between the original and noisy case. In testing retrieval methodologies, this type of analysis thus provides a quick means to test reconstruction results vs. known inputs. Although this case is only illustrated for real density matrices, a similar analysis can be used for the imaginary (or phase) components, thus coherences can also be quickly visualised in this manner.

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-output}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}*** Set trial matrix element for comparison with the original case computed above}
\PYG{n}{matE} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{matE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{if} \PYG{n}{normME}\PYG{p}{:}
    \PYG{n}{matE} \PYG{o}{=} \PYG{n}{matE}\PYG{o}{/}\PYG{n}{matE}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}
    
\PYG{c+c1}{\PYGZsh{} Add random noise, +/\PYGZhy{} 10\PYGZpc{}}
\PYG{c+c1}{\PYGZsh{} Note this is applied to normalised matE}
\PYG{c+c1}{\PYGZsh{} For the normalised case this results in a standard deviation in the difference density matrix elements of \PYGZti{}sqrt(2*(0.1\PYGZca{}2) + 2*0.1) = 0.2}
\PYG{c+c1}{\PYGZsh{} (Derived from basic error propagation, ignoring the actual values \PYGZhy{} see https://en.wikipedia.org/wiki/Propagation\PYGZus{}of\PYGZus{}uncertainty\PYGZsh{}Example\PYGZus{}formulae.)}
\PYG{n}{noise} \PYG{o}{=} \PYG{l+m+mf}{0.1}
\PYG{n}{SD} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{o}{*}\PYG{p}{(}\PYG{n}{noise}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{matE\PYGZus{}noise} \PYG{o}{=} \PYG{n}{matE} \PYG{o}{+} \PYG{n}{matE}\PYG{o}{*}\PYG{p}{(}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{o}{*}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{matE}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{noise}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Set range to random values +/\PYGZhy{}1 * noise}

\PYG{c+c1}{\PYGZsh{} Compute density matrix}
\PYG{n}{daOut\PYGZus{}noise}\PYG{p}{,} \PYG{o}{*}\PYG{n}{\PYGZus{}} \PYG{o}{=} \PYG{n}{density}\PYG{o}{.}\PYG{n}{densityCalc}\PYG{p}{(}\PYG{n}{matE\PYGZus{}noise}\PYG{p}{,} \PYG{n}{denDims} \PYG{o}{=} \PYG{n}{denDims}\PYG{p}{,} \PYG{n}{selDims} \PYG{o}{=} \PYG{n}{selDims}\PYG{p}{,} \PYG{n}{thres} \PYG{o}{=} \PYG{n}{thres}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Renormlise output?}
\PYG{k}{if} \PYG{n}{normDen}\PYG{o}{==}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{max}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
    \PYG{n}{daOut\PYGZus{}noise} \PYG{o}{=} \PYG{n}{daOut\PYGZus{}noise}\PYG{o}{/}\PYG{n}{daOut\PYGZus{}noise}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{elif} \PYG{n}{normDen}\PYG{o}{==}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{trace}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
    \PYG{n}{daOut\PYGZus{}noise} \PYG{o}{=} \PYG{n}{daOut\PYGZus{}noise}\PYG{o}{/}\PYG{p}{(}\PYG{n}{daOut\PYGZus{}noise}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Sym}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{pipe}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{trace}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}
    
\PYG{n}{daPlot\PYGZus{}noise} \PYG{o}{=} \PYG{n}{density}\PYG{o}{.}\PYG{n}{matPlot}\PYG{p}{(}\PYG{n}{daOut\PYGZus{}noise}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Sym}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{pTypes}\PYG{o}{=}\PYG{n}{pTypes}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Compute differences}
\PYG{n}{daDiff} \PYG{o}{=} \PYG{n}{daOut}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Sym}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{daOut\PYGZus{}noise}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Sym}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{daDiff}\PYG{o}{.}\PYG{n}{name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Difference}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{daPlotDiff} \PYG{o}{=} \PYG{n}{density}\PYG{o}{.}\PYG{n}{matPlot}\PYG{p}{(}\PYG{n}{daDiff}\PYG{p}{,} \PYG{n}{pTypes}\PYG{o}{=}\PYG{n}{pTypes}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Noise = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{noise}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{, SD (approx) = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{SD}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{maxDiff} \PYG{o}{=} \PYG{n}{daDiff}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{values}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Max difference = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{maxDiff}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}*** Layout plot from Holoviews objects for real parts, with custom titles.}
\PYG{n}{daLayout} \PYG{o}{=} \PYG{p}{(}\PYG{n}{daPlot}\PYG{o}{.}\PYG{n}{select}\PYG{p}{(}\PYG{n}{pType}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Real}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{opts}\PYG{p}{(}\PYG{n}{title}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{(a) Original}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{L,M}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{L}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{,M}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} 
            \PYG{o}{+} \PYG{n}{daPlot\PYGZus{}noise}\PYG{o}{.}\PYG{n}{select}\PYG{p}{(}\PYG{n}{pType}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Real}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{opts}\PYG{p}{(}\PYG{n}{title}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{(b) With noise}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{L,M}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{L}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{,M}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} 
            \PYG{o}{+} \PYG{n}{daPlotDiff}\PYG{o}{.}\PYG{n}{select}\PYG{p}{(}\PYG{n}{pType}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Real}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{opts}\PYG{p}{(}\PYG{n}{title}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{(c) Difference (fidelity)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{L,M}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{L}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{,M}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{feb707e8defecf2586216958b5b8894b088f9f1167a88818b222160b50f15008}.png}
\caption{Example density matrices, computed from matrix elements defined purely by  symmetry. Here the panels show (a) the original density matrix, (b) density matrix computed with +/\sphinxhyphen{} 10\% random noise added to the original matrix elements, (c) the difference matrix, which indicates the fidelity of the noisy case relative to the original case. For normalised density matrices the 10\% noise case translates to a standard deviation \(\sigma\approx\)\DUrole{pasted-text}{0.2} on the differences; the maximum error in the test case as illustrated =\DUrole{pasted-text}{0.3}.}\label{\detokenize{part1/theory_density_matrices_310123:fig-denmatd2hcompexample}}\end{figure}


\subsection{Working with density matrices with QuTiP library functions}
\label{\detokenize{part1/theory_density_matrices_310123:working-with-density-matrices-with-qutip-library-functions}}
\sphinxAtStartPar
From the numerical density matrix, a range of other standard properties can be computed; of particular interest are likely to be various standard quantities such as the trace, Von Neuman entropy and so forth. Naturally these can be computed numerically directly from the relevant formal definitions; however many of the fundamentals are already implemented in other libraries, and numerical representations can be passed directly to such libraries. In particular, \sphinxhref{https://qutip.org/}{the QuTiP (\sphinxstyleemphasis{Quantum Toolkbox in Python}) library} {[}{]} implements a range of standard functions, metrics, transforms and utility functions for working with state vectors and density matrices. A brief numerical example is given below, see \sphinxhref{https://qutip.org/}{the QuTiP documentation} {[}{]} for more possibilities.


\subsubsection{Convert numerical arrays to QuTiP objects}
\label{\detokenize{part1/theory_density_matrices_310123:convert-numerical-arrays-to-qutip-objects}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Import QuTip}
\PYG{k+kn}{from} \PYG{n+nn}{qutip} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{c+c1}{\PYGZsh{} Wrap density matrices to QuTip objects}
\PYG{c+c1}{\PYGZsh{} Note sum(\PYGZsq{}Sym\PYGZsq{}) to ensure 2D matrix, and .data to pass Numpy data array only}
\PYG{n}{pa} \PYG{o}{=} \PYG{n}{Qobj}\PYG{p}{(}\PYG{n}{daOut}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Sym}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)}    \PYG{c+c1}{\PYGZsh{} Reference continuum density matrix}
\PYG{n}{pb} \PYG{o}{=} \PYG{n}{Qobj}\PYG{p}{(}\PYG{n}{daOut\PYGZus{}noise}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Sym}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Noisy case}

\PYG{c+c1}{\PYGZsh{} QuTip objects have data as Numpy arrays, and render as typeset matrices in a notebook}
\PYG{n}{pa}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}Quantum object: dims = [[25], [25]], shape = (25, 25), type = oper, isherm = True $ \\ \left(\begin{matrix}1.0 & 0.0 & 0.0 & 0.0 & 0.707 & \cdots & 1.0 & 0.0 & 0.707 & 0.0 & 0.707\\0.0 & 1.000 & 0.0 & 0.0 & 0.0 & \cdots & 0.0 & 0.0 & 0.0 & 0.0 & 0.0\\0.0 & 0.0 & 1.0 & 0.0 & 0.0 & \cdots & 0.0 & 0.0 & 0.0 & 0.0 & 0.0\\0.0 & 0.0 & 0.0 & 1.000 & 0.0 & \cdots & 0.0 & 0.0 & 0.0 & 0.0 & 0.0\\0.707 & 0.0 & 0.0 & 0.0 & 1.000 & \cdots & 0.707 & 0.0 & 0.0 & 0.0 & 0.0\\\vdots & \vdots & \vdots & \vdots & \vdots & \ddots & \vdots & \vdots & \vdots & \vdots & \vdots\\1.0 & 0.0 & 0.0 & 0.0 & 0.707 & \cdots & 1.0 & 0.0 & 0.707 & 0.0 & 0.707\\0.0 & 0.0 & 0.0 & 0.0 & 0.0 & \cdots & 0.0 & 1.000 & 0.0 & 1.000 & 0.0\\0.707 & 0.0 & 0.0 & 0.0 & 0.0 & \cdots & 0.707 & 0.0 & 1.000 & 0.0 & 1.000\\0.0 & 0.0 & 0.0 & 0.0 & 0.0 & \cdots & 0.0 & 1.000 & 0.0 & 1.000 & 0.0\\0.707 & 0.0 & 0.0 & 0.0 & 0.0 & \cdots & 0.707 & 0.0 & 1.000 & 0.0 & 1.000\\\end{matrix}\right)$\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{Fidelity metric}
\label{\detokenize{part1/theory_density_matrices_310123:fidelity-metric}}
\sphinxAtStartPar
Fidelity between two density matrices \(\rho_{a},\rho_{b}\) can be defined as per Refs. {[}{]}:

\sphinxAtStartPar
\(F(\rho_{a},\rho_{b})=\operatorname{Tr} {\sqrt {{\sqrt {\rho_{a}}}\rho_{b} {\sqrt {\rho_{a}}}}}\)

\sphinxAtStartPar
This is implemented by the \sphinxcode{\sphinxupquote{fidelity}} function in QuTip. Of note in this case is the close to limiting case value of \(F(\rho_{a},\rho_{b})=1\) for the test case herein, despite the added noise and some per\sphinxhyphen{}element disparities as shown in   \hyperref[\detokenize{part1/theory_density_matrices_310123:fig-denmatd2hcompexample}]{Fig.\@ \ref{\detokenize{part1/theory_density_matrices_310123:fig-denmatd2hcompexample}}}(c). This reflects the conceptual difference between an element\sphinxhyphen{}wise evaluation of the differences, vs. a formal scalar metric.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Test fidelity, =1 if trace\PYGZhy{}normalised}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Fidelity (a,a) = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{fidelity}\PYG{p}{(}\PYG{n}{pa}\PYG{p}{,}\PYG{n}{pa}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Trace = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{pa}\PYG{o}{.}\PYG{n}{tr}\PYG{p}{(}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Trace\PYGZhy{}normed fidelity = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{fidelity}\PYG{p}{(}\PYG{n}{pa}\PYG{p}{,}\PYG{n}{pa}\PYG{p}{)}\PYG{o}{/}\PYG{n}{pa}\PYG{o}{.}\PYG{n}{tr}\PYG{p}{(}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Fidelity (a,a) = 25.00000031332397
Trace = 25.0
Trace\PYGZhy{}normed fidelity = 1.0000000125329587
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Test fidelity vs noisy case}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Fidelity (a,b) = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{fidelity}\PYG{p}{(}\PYG{n}{pa}\PYG{p}{,}\PYG{n}{pb}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Trace a = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{pa}\PYG{o}{.}\PYG{n}{tr}\PYG{p}{(}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{, Trace b = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{pb}\PYG{o}{.}\PYG{n}{tr}\PYG{p}{(}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Trace\PYGZhy{}normed fidelity = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{fidelity}\PYG{p}{(}\PYG{n}{pa}\PYG{o}{/}\PYG{n}{pa}\PYG{o}{.}\PYG{n}{tr}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{pb}\PYG{o}{/}\PYG{n}{pb}\PYG{o}{.}\PYG{n}{tr}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Fidelity (a,b) = 22.97696895871
Trace a = 25.0, Trace b = 21.191266275131078
Trace\PYGZhy{}normed fidelity = 0.99826862071642
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} This can also be computed rapidly with lower\PYGZhy{}level QuTip functionality...}

\PYG{c+c1}{\PYGZsh{} Compute inner term, note .sqrtm() for square root.}
\PYG{n}{inner} \PYG{o}{=} \PYG{n}{pa}\PYG{o}{.}\PYG{n}{sqrtm}\PYG{p}{(}\PYG{p}{)} \PYG{o}{*} \PYG{n}{pa} \PYG{o}{*} \PYG{n}{pa}\PYG{o}{.}\PYG{n}{sqrtm}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Compute fidelity}
\PYG{n}{inner}\PYG{o}{.}\PYG{n}{sqrtm}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{tr}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(25.00000059788841+8.879641550582872e\PYGZhy{}08j)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\section{Information content \& sensitivity}
\label{\detokenize{part1/theory_info_content_221122:information-content-sensitivity}}\label{\detokenize{part1/theory_info_content_221122:sec-info-content}}\label{\detokenize{part1/theory_info_content_221122::doc}}
\sphinxAtStartPar
A useful tool in considering the possibility of matrix element retrieval is the response, or sensitivity, of the experimental observables to the matrix elements of interest. Aspects of this have already been explored in \hyperref[\detokenize{part1/theory_tensor_formalism_201122:sec-tensor-formulation}]{Sect.\@ \ref{\detokenize{part1/theory_tensor_formalism_201122:sec-tensor-formulation}}}, where consideration of the various geometric tensors (or geometric basis set) provided a route to investigating the coupling \sphinxhyphen{} hence sensitivity \sphinxhyphen{} of various parameters into product terms. In particular the tensor products discussed in \hyperref[\detokenize{part1/theory_tensor_formalism_201122:sec-theory-tensor-products}]{Sect.\@ \ref{\detokenize{part1/theory_tensor_formalism_201122:sec-theory-tensor-products}}}, including the full channel (response) functions \(\varUpsilon_{L,M}^{u,\zeta\zeta'}\) (\eqref{equation:part1/theory_tensor_formalism_201122:eq:channelFunc-MF-defn} and \eqref{equation:part1/theory_tensor_formalism_201122:eq:channelFunc-AF-defn}), can be used to examine the overall sensitivity of a given measurement to the underlying observables. By careful consideration of the problem at hand, experiments may then be tailored for particular cases based on these sensitivities. A related question, is how a given experimental sensitivity might be more readily quantified, and interpreted, for reconstruction problems, in a simpler manner. In general, this can be termed as the \sphinxstyleemphasis{information content} of the measurement(s); an important aspect of such a metric is that it should be readily interpretable and, ideally, related to whether a reconstruction will be possible in a given case (this has, for example, been considered by other authors for specific cases, e.g. Refs. {[}\hyperlink{cite.backmatter/bibliography:id726}{58}, \hyperlink{cite.backmatter/bibliography:id692}{59}{]}).

\sphinxAtStartPar
Work in this direction is ongoing, and some thoughts are given below. In particular, the use of the observable \(\beta_{L,M}\) presents an experimental route to (roughly) define a form of information content, whilst metrics derived from channel functions or density matrices may present a more rigorous theoretical route to a useful parameterization of information content.


\subsection{Numerical setup}
\label{\detokenize{part1/theory_info_content_221122:numerical-setup}}
\sphinxAtStartPar
This follows the setup in \hyperref[\detokenize{part1/theory_tensor_formalism_201122:sec-tensor-formulation}]{Sect.\@ \ref{\detokenize{part1/theory_tensor_formalism_201122:sec-tensor-formulation}}} {\hyperref[\detokenize{part1/theory_tensor_formalism_201122:sec-tensor-formulation}]{\sphinxcrossref{\DUrole{std,std-ref}{Tensor formulation of photoionization}}}}, using a symmetry\sphinxhyphen{}based set of basis functions for demonstration purposes. (Repeated code is hidden in PDF version.)


\subsection{Experimental information content}
\label{\detokenize{part1/theory_info_content_221122:experimental-information-content}}\label{\detokenize{part1/theory_info_content_221122:sec-expt-info-content}}
\sphinxAtStartPar
As discussed in \sphinxstyleemphasis{Quantum Metrology} Vol. 2 {[}\hyperlink{cite.backmatter/bibliography:id570}{2}{]}, the information content of a single observable might be regarded as simply the number of contributing \(\beta_{L,M}\) parameters. In set notation:
\begin{equation}\label{equation:part1/theory_info_content_221122:eq:BLM-set}
\begin{split}M=\mathrm{n}\{\beta_{L,M}\}\end{split}
\end{equation}
\sphinxAtStartPar
where \(M\) is the information content of the measurement, defined as
\(\mathrm{n}\{...\}\) the cardinality (number of elements) of the set of
contributing parameters. A set of measurements, made for some
experimental variable \(u\), will then have a total information content:
\begin{equation*}
\begin{split}M_{u}=\sum_{u}\mathrm{n}\{\beta_{L,M}^{u}\}\end{split}
\end{equation*}
\sphinxAtStartPar
In the case where a single measurement contains multiple \(\beta_{L,M}\),
e.g. as a function of energy \(\epsilon\) or time \(t\), the information
content will naturally be larger:
\begin{equation*}
\begin{split}\begin{aligned}
M_{u,\epsilon,t} & = & \sum_{u,\epsilon,t}\mathrm{n}\{\beta_{L,M}^{u}(\epsilon,t)\}\\
 & = & M_{u}\times M_{\epsilon,t}\end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
where the second line pertains if each measurement has the same native
information content, independent of \(u\). It may be that the variable \(k\)
is continuous (e.g. photoelectron energy), but in practice it will
usually be discretized in some fashion by the measurement.

\sphinxAtStartPar
In terms of purely experimental methodologies, a larger \(M_{u}\) clearly
defines a richer experimental measurement which explores more of the
total measurement space spanned by the full set of
\(\{\beta_{L,M}^{u}(k,t)\}\). However, in this basic definition a larger
\(M_{u}\) does not necessarily indicate a higher information content for
quantum retrieval applications. The reason for this is simply down to
the complexity of the problem (cf. Eq. \eqref{equation:part1/theory_tensor_formalism_201122:eqn:channel-fns}), in which many couplings define the sensitivity of the observable to the underlying system properties of
interest. In this sense, more measurements, and larger \(M\), may only add
redundancy, rather than new information.

\sphinxAtStartPar
From a set of numerical results, it is relatively trivial to investigate some of these properties as a function of various constraints, using standard Python functionality, as shown in the code blocks below. For example, \(M\) can be determined numerically as the number of elements in the dataset, the number of \sphinxstyleemphasis{unique} elements, the number of elements within a certain range or above a threshold, and so on.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} For the basic case, the data (Xarray object) can be queried, and relevant dimensions investigated}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Available dimensions: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{BetaNorm}\PYG{o}{.}\PYG{n}{dims}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Show BLM dimension details from Xarray dataset}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{BetaNorm}\PYG{o}{.}\PYG{n}{BLM}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Available dimensions: (\PYGZsq{}Labels\PYGZsq{}, \PYGZsq{}t\PYGZsq{}, \PYGZsq{}Type\PYGZsq{}, \PYGZsq{}it\PYGZsq{}, \PYGZsq{}Eke\PYGZsq{}, \PYGZsq{}BLM\PYGZsq{})
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}xarray.DataArray \PYGZsq{}BLM\PYGZsq{} (BLM: 9)\PYGZgt{}
array([(0, \PYGZhy{}1), (0, 0), (0, 1), (1, \PYGZhy{}1), (1, 0), (1, 1), (2, \PYGZhy{}1), (2, 0),
       (2, 1)], dtype=object)
Coordinates:
  * BLM      (BLM) MultiIndex
  \PYGZhy{} l        (BLM) int64 0 0 0 1 1 1 2 2 2
  \PYGZhy{} m        (BLM) int64 \PYGZhy{}1 0 1 \PYGZhy{}1 0 1 \PYGZhy{}1 0 1
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Note, however, that the indexes may not always be physical, depending on how the data has been composed and cleaned up.}
\PYG{c+c1}{\PYGZsh{} For example, the above has l=0, m=+/\PYGZhy{}1 cases, which are non\PYGZhy{}physical.}

\PYG{c+c1}{\PYGZsh{} Clean array to remove terms |m|\PYGZgt{}l, and display}
\PYG{c+c1}{\PYGZsh{} BetaNorm.BLM.where(np.abs(BetaNorm.BLM.m)\PYGZlt{}=BetaNorm.BLM.l,drop=True)}
\PYG{c+c1}{\PYGZsh{} BetaNorm.where(np.abs(BetaNorm.m)\PYGZlt{}=BetaNorm.l,drop=True)}

\PYG{n}{cleanBLMs}\PYG{p}{(}\PYG{n}{BetaNorm}\PYG{p}{)}\PYG{o}{.}\PYG{n}{BLM}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}xarray.DataArray \PYGZsq{}BLM\PYGZsq{} (BLM: 7)\PYGZgt{}
array([(0, 0), (1, \PYGZhy{}1), (1, 0), (1, 1), (2, \PYGZhy{}1), (2, 0), (2, 1)], dtype=object)
Coordinates:
  * BLM      (BLM) MultiIndex
  \PYGZhy{} l        (BLM) int64 0 1 1 1 2 2 2
  \PYGZhy{} m        (BLM) int64 0 \PYGZhy{}1 0 1 \PYGZhy{}1 0 1
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Thresholding can also be used to reduce the results}
\PYG{n}{ep}\PYG{o}{.}\PYG{n}{matEleSelector}\PYG{p}{(}\PYG{n}{BetaNorm}\PYG{p}{,} \PYG{n}{thres}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}4}\PYG{p}{)}\PYG{o}{.}\PYG{n}{BLM}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}xarray.DataArray \PYGZsq{}BLM\PYGZsq{} (BLM: 2)\PYGZgt{}
array([(0, 0), (2, 0)], dtype=object)
Coordinates:
  * BLM      (BLM) MultiIndex
  \PYGZhy{} l        (BLM) int64 0 2
  \PYGZhy{} m        (BLM) int64 0 0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} The index can be returned as a Pandas object, and statistical routines applied...}
\PYG{c+c1}{\PYGZsh{} For example, nunique() will provide the number of unique values.}

\PYG{n}{thres}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}4}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Original array M=}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{BetaNorm}\PYG{o}{.}\PYG{n}{BLM}\PYG{o}{.}\PYG{n}{indexes}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{BLM}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{nunique}\PYG{p}{(}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} print(f\PYGZdq{}Cleaned array M=\PYGZob{}BetaNorm.BLM.where(np.abs(BetaNorm.BLM.m)\PYGZlt{}=BetaNorm.BLM.l,drop=True).size\PYGZcb{}\PYGZdq{})}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Cleaned array M=}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{cleanBLMs}\PYG{p}{(}\PYG{n}{BetaNorm}\PYG{p}{)}\PYG{o}{.}\PYG{n}{BLM}\PYG{o}{.}\PYG{n}{size}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Thresholded array (thres=}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{thres}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{), M=}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{ep}\PYG{o}{.}\PYG{n}{matEleSelector}\PYG{p}{(}\PYG{n}{BetaNorm}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{thres}\PYG{o}{=}\PYG{n}{thres}\PYG{p}{)}\PYG{o}{.}\PYG{n}{BLM}\PYG{o}{.}\PYG{n}{indexes}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{BLM}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{nunique}\PYG{p}{(}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Original array M=9
Cleaned array M=7
Thresholded array (thres=0.0001), M=2
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
For more complicated cases, with \(u>1\), e.g. time\sphinxhyphen{}dependent measurements, interrogating the statistics of the observables may also be an interesting avenue to explore. The examples below investigate this for the example “linear ramp” {\hyperref[\detokenize{backmatter/glossary:term-ADMs}]{\sphinxtermref{\DUrole{xref,std,std-term}{ADMs}}}} case. Here the statistical analysis is, potentially, a measure of the useful/non\sphinxhyphen{}redundant information content, for instance the range or variance in a particular observable can be analysed, as can the number of unique values and so forth.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Convert to PD and tabulate with epsproc functionality}
\PYG{c+c1}{\PYGZsh{} Note restack along \PYGZsq{}t\PYGZsq{} dimension}
\PYG{n}{BetaNormLinearADMsPD}\PYG{p}{,} \PYG{n}{\PYGZus{}} \PYG{o}{=} \PYG{n}{ep}\PYG{o}{.}\PYG{n}{util}\PYG{o}{.}\PYG{n}{multiDimXrToPD}\PYG{p}{(}\PYG{n}{BetaNormLinearADMs}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{real}\PYG{p}{,} \PYG{n}{thres}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}4}\PYG{p}{,} \PYG{n}{colDims}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Basic describe with Pandas, see https://pandas.pydata.org/docs/user\PYGZus{}guide/basics.html\PYGZsh{}summarizing\PYGZhy{}data\PYGZhy{}describe}
\PYG{c+c1}{\PYGZsh{} This will give properties per t}
\PYG{n}{BetaNormLinearADMsPD}\PYG{o}{.}\PYG{n}{describe}\PYG{p}{(}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{}([pd.unique])   \PYGZsh{}([\PYGZsq{}nunique\PYGZsq{}])}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\begin{tabular}{lrrrrrrrrrr}
\toprule
t &      0 &      1 &      2 &      3 &      4 &      5 &      6 &      7 &      8 &      9 \\
\midrule
count &  2.000 &  5.000 &  5.000 &  5.000 &  5.000 &  5.000 &  5.000 &  5.000 &  5.000 &  5.000 \\
mean  &  0.389 &  0.190 &  0.225 &  0.259 &  0.294 &  0.328 &  0.363 &  0.397 &  0.432 &  0.466 \\
std   &  0.115 &  0.242 &  0.265 &  0.290 &  0.315 &  0.341 &  0.368 &  0.395 &  0.423 &  0.451 \\
min   &  0.308 &  0.001 &  0.002 &  0.003 &  0.004 &  0.006 &  0.007 &  0.008 &  0.009 &  0.010 \\
25\%   &  0.348 &  0.009 &  0.017 &  0.026 &  0.035 &  0.043 &  0.052 &  0.060 &  0.069 &  0.078 \\
50\%   &  0.389 &  0.041 &  0.083 &  0.124 &  0.166 &  0.207 &  0.249 &  0.290 &  0.332 &  0.373 \\
75\%   &  0.430 &  0.382 &  0.457 &  0.532 &  0.607 &  0.681 &  0.751 &  0.797 &  0.844 &  0.891 \\
max   &  0.470 &  0.517 &  0.564 &  0.610 &  0.657 &  0.704 &  0.756 &  0.831 &  0.906 &  0.980 \\
\bottomrule
\end{tabular}\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Basic describe with Pandas, see https://pandas.pydata.org/docs/user\PYGZus{}guide/basics.html\PYGZsh{}summarizing\PYGZhy{}data\PYGZhy{}describe}
\PYG{c+c1}{\PYGZsh{} By transposing the input array, this will give properties per BLM}
\PYG{n}{BetaNormLinearADMsPD}\PYG{o}{.}\PYG{n}{T}\PYG{o}{.}\PYG{n}{describe}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\begin{tabular}{lrrrrr}
\toprule
l &       0 &       2 &      4 &      6 &      8 \\
m &       0 &       0 &      0 &      0 &      0 \\
\midrule
count &  10.000 &  10.000 &  9.000 &  9.000 &  9.000 \\
mean  &   0.680 &   0.644 &  0.207 &  0.043 &  0.006 \\
std   &   0.141 &   0.226 &  0.114 &  0.024 &  0.003 \\
min   &   0.470 &   0.308 &  0.041 &  0.009 &  0.001 \\
25\%   &   0.575 &   0.476 &  0.124 &  0.026 &  0.003 \\
50\%   &   0.680 &   0.644 &  0.207 &  0.043 &  0.006 \\
75\%   &   0.786 &   0.812 &  0.290 &  0.060 &  0.008 \\
max   &   0.891 &   0.980 &  0.373 &  0.078 &  0.010 \\
\bottomrule
\end{tabular}\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
For further insight and control, specific aggregation functions and criteria can be specified. For instance, it may be interesting to look at the number of unique values to a certain precision (e.g. depending on experimental uncertainties), or consider deviation of values from the mean.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Round values to 1 d.p., then apply statistical methods}
\PYG{n}{BetaNormLinearADMsPD}\PYG{o}{.}\PYG{n}{round}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{.}\PYG{n}{agg}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{min}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{max}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{var}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{count}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nunique}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\begin{tabular}{lrrrrrrrrrr}
\toprule
t &     0 &      1 &      2 &      3 &     4 &      5 &      6 &      7 &      8 &      9 \\
\midrule
min     &  0.30 &  0.000 &  0.000 &  0.000 &  0.00 &  0.000 &  0.000 &  0.000 &  0.000 &  0.000 \\
max     &  0.50 &  0.500 &  0.600 &  0.600 &  0.70 &  0.700 &  0.800 &  0.800 &  0.900 &  1.000 \\
var     &  0.02 &  0.062 &  0.083 &  0.083 &  0.11 &  0.127 &  0.152 &  0.145 &  0.167 &  0.207 \\
count   &  2.00 &  5.000 &  5.000 &  5.000 &  5.00 &  5.000 &  5.000 &  5.000 &  5.000 &  5.000 \\
nunique &  2.00 &  3.000 &  4.000 &  4.000 &  4.00 &  3.000 &  4.000 &  4.000 &  5.000 &  5.000 \\
\bottomrule
\end{tabular}\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Define demean function and apply (from https://stackoverflow.com/a/26110278)}
\PYG{n}{demean} \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Compute differences from mean}
\PYG{n}{BetaNormLinearADMsPD}\PYG{o}{.}\PYG{n}{transform}\PYG{p}{(}\PYG{n}{demean}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{columns}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{}.round(1).agg([\PYGZsq{}min\PYGZsq{},\PYGZsq{}max\PYGZsq{},\PYGZsq{}var\PYGZsq{},\PYGZsq{}count\PYGZsq{},\PYGZsq{}nunique\PYGZsq{}])   \PYGZsh{} OK, matches above case.}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\begin{tabular}{llrrrrrrrrrr}
\toprule
  & t &      0 &      1 &      2 &      3 &      4 &          5 &      6 &      7 &      8 &      9 \\
l & m &        &        &        &        &        &            &        &        &        &        \\
\midrule
0 & 0 & -0.210 & -0.164 & -0.117 & -0.070 & -0.023 &  2.336e-02 &  0.070 &  0.117 &  0.164 &  0.210 \\
2 & 0 & -0.336 & -0.262 & -0.187 & -0.112 & -0.037 &  3.736e-02 &  0.112 &  0.187 &  0.262 &  0.336 \\
4 & 0 &    NaN & -0.166 & -0.124 & -0.083 & -0.041 &  0.000e+00 &  0.041 &  0.083 &  0.124 &  0.166 \\
6 & 0 &    NaN & -0.035 & -0.026 & -0.017 & -0.009 &  0.000e+00 &  0.009 &  0.017 &  0.026 &  0.035 \\
8 & 0 &    NaN & -0.004 & -0.003 & -0.002 & -0.001 & -8.674e-19 &  0.001 &  0.002 &  0.003 &  0.004 \\
\bottomrule
\end{tabular}\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Apply statistical functions to differences from mean.}
\PYG{n}{BetaNormLinearADMsPD}\PYG{o}{.}\PYG{n}{transform}\PYG{p}{(}\PYG{n}{demean}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{columns}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{round}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{.}\PYG{n}{agg}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{min}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{max}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{var}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{count}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nunique}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\begin{tabular}{lrrrrrrrrrr}
\toprule
t &      0 &      1 &      2 &      3 &    4 &    5 &      6 &      7 &      8 &      9 \\
\midrule
min     & -0.300 & -0.300 & -0.200 & -0.100 & -0.0 & -0.0 &  0.000 &  0.000 &  0.000 &  0.000 \\
max     & -0.200 & -0.000 & -0.000 & -0.000 & -0.0 & -0.0 &  0.100 &  0.200 &  0.300 &  0.300 \\
var     &  0.005 &  0.018 &  0.007 &  0.003 &  0.0 &  0.0 &  0.003 &  0.007 &  0.017 &  0.018 \\
count   &  2.000 &  5.000 &  5.000 &  5.000 &  5.0 &  5.0 &  5.000 &  5.000 &  5.000 &  5.000 \\
nunique &  2.000 &  3.000 &  3.000 &  2.000 &  1.0 &  1.0 &  2.000 &  3.000 &  4.000 &  3.000 \\
\bottomrule
\end{tabular}\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
In this case the analysis suggests that \(t=4,5\) contain minimal, and redundant, information, whilst \(t=0,3,6\) are also of low total information content. However, this analysis is not necessarily absolutely definitive, since some nuances may be lost in this basic statistical analysis, particularly for weaker channels.

\sphinxAtStartPar
For a more detailed analysis, other standard analysis tools can be deployed. For instance, the covariance matrix can be investigated, given by \(K_{i,j}=\textrm{cov}[X_{i},X_{j}]=\langle(X_{i}-\langle X_{i}\rangle)(X_{j}-\langle X_{j}\rangle)\rangle\). For the linear ramp case this analysis is not particularly useful, but will become more informative for more complicated cases.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} import pandas as pd}
\PYG{c+c1}{\PYGZsh{} import holoviews as hv}
\PYG{c+c1}{\PYGZsh{} import hvplot.pandas}
\PYG{c+c1}{\PYGZsh{} hv.extension(\PYGZsq{}bokeh\PYGZsq{})}

\PYG{c+c1}{\PYGZsh{} Compute covariance matrix with Pandas}
\PYG{c+c1}{\PYGZsh{} Note this is the pairwise covariance of the columns, }
\PYG{c+c1}{\PYGZsh{} see https://pandas.pydata.org/pandas\PYGZhy{}docs/stable/reference/api/pandas.DataFrame.cov.html}
\PYG{n}{covMat} \PYG{o}{=} \PYG{n}{BetaNormLinearADMsPD}\PYG{o}{.}\PYG{n}{cov}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} covMat.name = \PYGZdq{}Covariance\PYGZdq{}}
\PYG{c+c1}{\PYGZsh{} Plot with holoviews}
\PYG{c+c1}{\PYGZsh{} hv.HeatMap(covMat, kdims=\PYGZsq{}t\PYGZsq{})}
\PYG{c+c1}{\PYGZsh{} import hvplot.pandas}
\PYG{n}{figObj} \PYG{o}{=} \PYG{n}{covMat}\PYG{o}{.}\PYG{n}{hvplot}\PYG{o}{.}\PYG{n}{heatmap}\PYG{p}{(}\PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{viridis}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} hvds = hv.Dataset(daPlot)}
\PYG{c+c1}{\PYGZsh{} hvmap = hvds.to(hv.HeatMap, kdims=kdims)}

\PYG{c+c1}{\PYGZsh{} Import routines for density calculation and plotting \PYGZhy{} FAILS, needs da with specific props}
\PYG{c+c1}{\PYGZsh{} from epsproc.calc import density}
\PYG{c+c1}{\PYGZsh{} density.matPlot(covMat)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{4806928bdbc767ebe92b209c0cbed114ab0e4ab97120ee6db56392abbbaa2829}.png}
\caption{Example \(\beta_\{L,M\}(t)\) covariance matrix, see text for details.}\label{\detokenize{part1/theory_info_content_221122:fig-covmatblmexample}}\end{figure}


\subsection{Information content from channel functions}
\label{\detokenize{part1/theory_info_content_221122:information-content-from-channel-functions}}
\sphinxAtStartPar
A more complete accounting of information content would, therefore, also
include the channel couplings, i.e. sensitivity/dependence of the
observable to a given system property, in some manner. For the case of a
time\sphinxhyphen{}dependent measurement, arising from a rotational wavepacket, this
can be written as:
\begin{equation*}
\begin{split}M_{u}=\mathrm{n}\{\varUpsilon_{L,M}^{u}(\epsilon,t)\}\end{split}
\end{equation*}
\sphinxAtStartPar
In this case, each \((\epsilon,t)\) is treated as an independent
measurement with unique information content, although there may be
redundancy as a function of \(t\) depending on the nature of the
rotational wavepacket and channel functions.

\sphinxAtStartPar
(Note this is in
distinction to previously demonstrated cases where the time\sphinxhyphen{}dependence
was created from a shaped laser\sphinxhyphen{}field, and was integrated over in the
measurements, which provided a coherently\sphinxhyphen{}multiplexed case, see refs.
{[}\hyperlink{cite.backmatter/bibliography:id556}{60}, \hyperlink{cite.backmatter/bibliography:id558}{61}, \hyperlink{cite.backmatter/bibliography:id557}{62}{]} for details.)

\sphinxAtStartPar
In the numerical examples below, this is considered in terms of the full channel (response) functions \(\varUpsilon_{L,M}^{u,\zeta\zeta'}\) as defined in \eqref{equation:part1/theory_tensor_formalism_201122:eq:channelFunc-MF-defn} and \eqref{equation:part1/theory_tensor_formalism_201122:eq:channelFunc-AF-defn} (see \hyperref[\detokenize{part1/theory_tensor_formalism_201122:sec-theory-tensor-products}]{Sect.\@ \ref{\detokenize{part1/theory_tensor_formalism_201122:sec-theory-tensor-products}}}). Numerically, the routines follow from those already introduced above for exploring the information content of \(\beta_{L,M}\) terms, with the caveat that there are more dimensions to handle in the channel functions, indexed by the relevant set of quantum numbers \(\{\zeta,\zeta'\}\) \sphinxhyphen{} these can be included in the criteria for determination of \(M\), or selected or summed over as desired.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Define a set of channel functions to test}
\PYG{n}{channelFuncs} \PYG{o}{=} \PYG{p}{(}\PYG{n}{basisProductLinearADMs}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{BLMtableResort}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{*} \PYG{n}{basisProductLinearADMs}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{polProd}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} For illustrative purposes, define a subset to use for analysis}
\PYG{n}{channelFuncsSubset} \PYG{o}{=} \PYG{n}{channelFuncs}\PYG{o}{.}\PYG{n}{sel}\PYG{p}{(}\PYG{n}{Labels}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sel}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{S\PYGZhy{}Rp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mu}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mup}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{}.sel(L=2)}

\PYG{c+c1}{\PYGZsh{} Check dimensions}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Available dimensions: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{channelFuncs}\PYG{o}{.}\PYG{n}{dims}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Subset dimensions: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{channelFuncsSubset}\PYG{o}{.}\PYG{n}{dims}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Available dimensions: (\PYGZsq{}m\PYGZsq{}, \PYGZsq{}mp\PYGZsq{}, \PYGZsq{}S\PYGZhy{}Rp\PYGZsq{}, \PYGZsq{}l\PYGZsq{}, \PYGZsq{}lp\PYGZsq{}, \PYGZsq{}L\PYGZsq{}, \PYGZsq{}mu\PYGZsq{}, \PYGZsq{}mup\PYGZsq{}, \PYGZsq{}Labels\PYGZsq{}, \PYGZsq{}M\PYGZsq{}, \PYGZsq{}t\PYGZsq{})
Subset dimensions: (\PYGZsq{}m\PYGZsq{}, \PYGZsq{}mp\PYGZsq{}, \PYGZsq{}l\PYGZsq{}, \PYGZsq{}lp\PYGZsq{}, \PYGZsq{}L\PYGZsq{}, \PYGZsq{}M\PYGZsq{}, \PYGZsq{}t\PYGZsq{})
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxShadowBox}
\sphinxstylesidebartitle{}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Full tabulations of the parameters available in HTML or notebook formats only.
\end{sphinxadmonition}
\end{sphinxShadowBox}

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-output}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Convert to PD and tabulate with epsproc functionality}
\PYG{c+c1}{\PYGZsh{} Note restack along \PYGZsq{}t\PYGZsq{} dimension}
\PYG{n}{channelFuncsSubsetPD}\PYG{p}{,} \PYG{n}{\PYGZus{}} \PYG{o}{=} \PYG{n}{ep}\PYG{o}{.}\PYG{n}{util}\PYG{o}{.}\PYG{n}{multiDimXrToPD}\PYG{p}{(}\PYG{n}{channelFuncsSubset}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{real}\PYG{p}{,} \PYG{n}{thres}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}4}\PYG{p}{,} \PYG{n}{colDims}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Basic describe with Pandas, see https://pandas.pydata.org/docs/user\PYGZus{}guide/basics.html\PYGZsh{}summarizing\PYGZhy{}data\PYGZhy{}describe}
\PYG{c+c1}{\PYGZsh{} This will give properties per t}
\PYG{c+c1}{\PYGZsh{} channelFuncsSubsetPD.describe()   \PYGZsh{}([pd.unique])   \PYGZsh{}([\PYGZsq{}nunique\PYGZsq{}])}

\PYG{c+c1}{\PYGZsh{} Round values to 1 d.p., then apply statistical methods}
\PYG{c+c1}{\PYGZsh{} channelFuncsSubsetPD.round(1).agg([\PYGZsq{}min\PYGZsq{},\PYGZsq{}max\PYGZsq{},\PYGZsq{}var\PYGZsq{},\PYGZsq{}count\PYGZsq{},\PYGZsq{}nunique\PYGZsq{}])  \PYGZsh{} Compute per t}

\PYG{n}{channelFuncsSubsetPD}\PYG{o}{.}\PYG{n}{T}\PYG{o}{.}\PYG{n}{round}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{.}\PYG{n}{agg}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{min}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{max}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{var}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{count}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nunique}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}  \PYG{c+c1}{\PYGZsh{}[0:100]  \PYGZsh{} Compute per basis index and display}


\PYG{c+c1}{\PYGZsh{} Plotting tests with hvplot wrapper \PYGZhy{} interesting, but lacking fine control so far...}
\PYG{c+c1}{\PYGZsh{} channelFuncsSubsetPD.T.round(1).agg([\PYGZsq{}min\PYGZsq{},\PYGZsq{}max\PYGZsq{},\PYGZsq{}var\PYGZsq{},\PYGZsq{}count\PYGZsq{},\PYGZsq{}nunique\PYGZsq{}]).T.hvplot.hist(\PYGZsq{}nunique\PYGZsq{}, by=[\PYGZsq{}L\PYGZsq{},\PYGZsq{}M\PYGZsq{}], subplots=True).cols(1)}
\PYG{c+c1}{\PYGZsh{} channelFuncsSubsetPD.T.round(3).agg([\PYGZsq{}min\PYGZsq{},\PYGZsq{}max\PYGZsq{},\PYGZsq{}var\PYGZsq{},\PYGZsq{}count\PYGZsq{},\PYGZsq{}nunique\PYGZsq{}]).T.hvplot.hist(\PYGZsq{}nunique\PYGZsq{}, by=[\PYGZsq{}l\PYGZsq{},\PYGZsq{}lp\PYGZsq{}])}
\PYG{c+c1}{\PYGZsh{} channelFuncsSubsetPD.T.round(3).agg([\PYGZsq{}min\PYGZsq{},\PYGZsq{}max\PYGZsq{},\PYGZsq{}var\PYGZsq{},\PYGZsq{}count\PYGZsq{},\PYGZsq{}nunique\PYGZsq{}]).T.hvplot.hist(\PYGZsq{}nunique\PYGZsq{}, by=[\PYGZsq{}l\PYGZsq{},\PYGZsq{}lp\PYGZsq{}], subplots=True).cols(2)}
\PYG{c+c1}{\PYGZsh{} channelFuncsSubsetPD.T.round(2).agg([\PYGZsq{}min\PYGZsq{},\PYGZsq{}max\PYGZsq{},\PYGZsq{}var\PYGZsq{},\PYGZsq{}count\PYGZsq{},\PYGZsq{}nunique\PYGZsq{}]).T.hvplot.hist(\PYGZsq{}nunique\PYGZsq{}, by=[\PYGZsq{}L\PYGZsq{},\PYGZsq{}l\PYGZsq{},\PYGZsq{}lp\PYGZsq{}], subplots=True)}
\PYG{c+c1}{\PYGZsh{} channelFuncsSubsetPD.T.round(2).agg([\PYGZsq{}min\PYGZsq{},\PYGZsq{}max\PYGZsq{},\PYGZsq{}var\PYGZsq{},\PYGZsq{}count\PYGZsq{},\PYGZsq{}nunique\PYGZsq{}]).T.hvplot.heatmap(x=\PYGZsq{}nunique\PYGZsq{},y=\PYGZsq{}L\PYGZsq{}, by=[\PYGZsq{}L\PYGZsq{},\PYGZsq{}l\PYGZsq{},\PYGZsq{}lp\PYGZsq{}], subplots=True)}

\PYG{c+c1}{\PYGZsh{} Holomap version \PYGZhy{} not working in notebook currently? Gives controls, but plot not responding...}
\PYG{c+c1}{\PYGZsh{} channelFuncsSubsetPD.T.round(2).agg([\PYGZsq{}min\PYGZsq{},\PYGZsq{}max\PYGZsq{},\PYGZsq{}var\PYGZsq{},\PYGZsq{}count\PYGZsq{},\PYGZsq{}nunique\PYGZsq{}]).T.hvplot.hist(\PYGZsq{}nunique\PYGZsq{}, by=[\PYGZsq{}L\PYGZsq{},\PYGZsq{}l\PYGZsq{},\PYGZsq{}lp\PYGZsq{}], groupby=[\PYGZsq{}L\PYGZsq{},\PYGZsq{}l\PYGZsq{},\PYGZsq{}lp\PYGZsq{}])}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
For the higher\sphinxhyphen{}dimensional case, it is useful to plot terms relative to all quantum numbers. For example, in a similar manner to the basis set explorations of \hyperref[\detokenize{part1/theory_tensor_formalism_201122:sec-theory-tensor-products}]{Sect.\@ \ref{\detokenize{part1/theory_tensor_formalism_201122:sec-theory-tensor-products}}}, related properties such as the distance from the mean can be examined with \sphinxcode{\sphinxupquote{lmPlot()}}. And, as previously demonstrated, other properties, such as the covariance, may be examined and plotted.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} channelFuncsSubsetPD.transform(demean,axis=\PYGZsq{}columns\PYGZsq{}) }
\PYG{c+c1}{\PYGZsh{} cmap=None   \PYGZsh{} cmap = None for default. \PYGZsq{}vlag\PYGZsq{} good?}
\PYG{c+c1}{\PYGZsh{} cmap = \PYGZsq{}vlag\PYGZsq{}}

\PYG{c+c1}{\PYGZsh{} De\PYGZhy{}meaned channel functions}
\PYG{n}{channelFuncsDemean} \PYG{o}{=} \PYG{n}{channelFuncsSubsetPD}\PYG{o}{.}\PYG{n}{transform}\PYG{p}{(}\PYG{n}{demean}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{columns}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot using lmPlot routine \PYGZhy{} note this requires conversion to Xarray data type first.}
\PYG{n}{daPlot}\PYG{p}{,} \PYG{n}{daPlotpd}\PYG{p}{,} \PYG{n}{legendList}\PYG{p}{,} \PYG{n}{gFig} \PYG{o}{=}  \PYG{n}{ep}\PYG{o}{.}\PYG{n}{lmPlot}\PYG{p}{(}\PYG{n}{channelFuncsDemean}\PYG{o}{.}\PYG{n}{to\PYGZus{}xarray}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{to\PYGZus{}array}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
                                                \PYG{p}{,} \PYG{n}{xDim}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{,} \PYG{n}{mDimLabel}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{m}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Set dataType (No dataType)
Plotting data (No filename), pType=a, thres=0.01, with Seaborn
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
No handles with labels found to put in legend.
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{131bbdf66b99623335bab92ea234aec14708cf41f88cc27b210cc0cbb9d9665d}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Full covariance mapping along all dims}
\PYG{n}{sns}\PYG{o}{.}\PYG{n}{clustermap}\PYG{p}{(}\PYG{n}{channelFuncsSubsetPD}\PYG{o}{.}\PYG{n}{T}\PYG{o}{.}\PYG{n}{cov}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{fillna}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}seaborn.matrix.ClusterGrid at 0x7f5e813b4d30\PYGZgt{}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{3a8ceaccd805aba1c4135c196f2d6221f41e5a8d4fa5952dfb0eada3df792a36}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Information content from density matrices}
\label{\detokenize{part1/theory_info_content_221122:information-content-from-density-matrices}}
\sphinxstepscope


\chapter{Numerical implementation}
\label{\detokenize{part1/numerics_231122:numerical-implementation}}\label{\detokenize{part1/numerics_231122:sec-numerical-details}}\label{\detokenize{part1/numerics_231122::doc}}
\sphinxAtStartPar
Further details of the numerical implementations \sphinxhyphen{} base packages, conventions and refs \sphinxhyphen{} to go here or in appendix?

\sphinxstepscope


\part{Backmatter}

\sphinxstepscope


\chapter{Bibliography}
\label{\detokenize{backmatter/bibliography:bibliography}}\label{\detokenize{backmatter/bibliography::doc}}\phantomsection\label{\detokenize{backmatter/bibliography:id1}}
\sphinxstepscope


\chapter{Glossary}
\label{\detokenize{backmatter/glossary:glossary}}\label{\detokenize{backmatter/glossary::doc}}\begin{description}
\sphinxlineitem{MF\index{MF@\spxentry{MF}|spxpagem}\phantomsection\label{\detokenize{backmatter/glossary:term-MF}}}
\sphinxAtStartPar
Molecular frame (MF) \sphinxhyphen{} coordinate system referenced to the molecule, usually with the z\sphinxhyphen{}axis corresponding to the highest symmetry axis.

\sphinxlineitem{LF\index{LF@\spxentry{LF}|spxpagem}\phantomsection\label{\detokenize{backmatter/glossary:term-LF}}}
\sphinxAtStartPar
Laboratory or lab frame (LF) \sphinxhyphen{} coordinate system referenced to the laboratory frame, usually with the z\sphinxhyphen{}axis corresponding to the laser field polarization. For circularly or elliptically polarized light the propagation direction is conventionally used for the z\sphinxhyphen{}axis. In some cases a different z\sphinxhyphen{}axis may be chosen, e.g. as defined by a detector.

\sphinxlineitem{AF\index{AF@\spxentry{AF}|spxpagem}\phantomsection\label{\detokenize{backmatter/glossary:term-AF}}}
\sphinxAtStartPar
Aligned frame (AF) \sphinxhyphen{} coordinate system referenced to molecular alignment axis or axes. For 1D alignment, the z\sphinxhyphen{}axis usually corresponds to the alignment field polarization, and hence may be identical to the standard {\hyperref[\detokenize{backmatter/glossary:term-LF}]{\sphinxtermref{\DUrole{xref,std,std-term}{LF}}}} definition. For high degrees of (3D) alignment the AF may approach the {\hyperref[\detokenize{backmatter/glossary:term-MF}]{\sphinxtermref{\DUrole{xref,std,std-term}{MF}}}} in the ideal case, although will usually be limited by the symmetry of the system.

\sphinxlineitem{PADs\index{PADs@\spxentry{PADs}|spxpagem}\phantomsection\label{\detokenize{backmatter/glossary:term-PADs}}}
\sphinxAtStartPar
Photoelectron angular distributions (PADs), often with a prefix denoting the reference frame, e.g. LFPADs, MFPADs (sometimes also hypenated, e.g. LF\sphinxhyphen{}PADs). Usage is often synonymous with the associated {\hyperref[\detokenize{backmatter/glossary:term-anisotropy-paramters}]{\sphinxtermref{\DUrole{xref,std,std-term}{anisotropy paramters}}}} (or “betas”).

\sphinxlineitem{anisotropy paramters\index{anisotropy paramters@\spxentry{anisotropy paramters}|spxpagem}\phantomsection\label{\detokenize{backmatter/glossary:term-anisotropy-paramters}}}
\sphinxAtStartPar
Expansion parameters \(\beta_{L,M}\) for an expansion in spherical harmonics (or similar basis sets of angular momentum functions in polar coordinates), e.g. Eq. \eqref{equation:part1/theory_observables_intro_211122:eq:AF-PAD-general}. Often referred to simply as “beta parameters”, and may be dependent on various properties, e.g. \(\beta_{L,M}(\epsilon,t...)\). Herein upper\sphinxhyphen{}case \(L,M\) usually refer to observables or the general case, whilst lower\sphinxhyphen{}case \((l,m)\) usually refer specifically to the photoelectron wavefunction partial waves, and \((l,\lambda)\) usually denote these terms referenced specifically to the molecular frame.

\sphinxlineitem{ADMs\index{ADMs@\spxentry{ADMs}|spxpagem}\phantomsection\label{\detokenize{backmatter/glossary:term-ADMs}}}
\sphinxAtStartPar
Expansion parameters \(A_{Q,S}^{K}(t)\) for describing a molecular ensemble alignment described as a set of axis distribution moments, usually expanded as Wigner rotation matrix element, spherical harmonics or Legendre polynomial functions.

\sphinxlineitem{Axis distribution moments\index{Axis distribution moments@\spxentry{Axis distribution moments}|spxpagem}\phantomsection\label{\detokenize{backmatter/glossary:term-Axis-distribution-moments}}}
\sphinxAtStartPar
See {\hyperref[\detokenize{backmatter/glossary:term-ADMs}]{\sphinxtermref{\DUrole{xref,std,std-term}{ADMs}}}}.

\end{description}

\sphinxstepscope


\part{Test pages}

\sphinxstepscope


\chapter{Build versions and config tests}
\label{\detokenize{tests/build_versions_checks:build-versions-and-config-tests}}\label{\detokenize{tests/build_versions_checks::doc}}

\section{Versions}
\label{\detokenize{tests/build_versions_checks:versions}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{scooby}
\PYG{n}{scooby}\PYG{o}{.}\PYG{n}{Report}\PYG{p}{(}\PYG{n}{additional}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pemtk}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{epsproc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{xarray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pandas}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{scipy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{matplotlib}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{jupyterlab}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{plotly}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{holoviews}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
* sparse not found, sparse matrix forms not available. 
* natsort not found, some sorting functions not available. 
* Setting plotter defaults with epsproc.basicPlotters.setPlotters(). Run directly to modify, or change options in local env.
* Set Holoviews with bokeh.
* pyevtk not found, VTK export not available. 
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
OMP: Info \PYGZsh{}271: omp\PYGZus{}set\PYGZus{}nested routine deprecated, please use omp\PYGZus{}set\PYGZus{}max\PYGZus{}active\PYGZus{}levels instead.
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
  Date: Wed Mar 29 14:05:31 2023 EDT

                OS : Linux
            CPU(s) : 64
           Machine : x86\PYGZus{}64
      Architecture : 64bit
               RAM : 62.8 GiB
       Environment : Jupyter
       File system : btrfs

  Python 3.9.7 | packaged by conda\PYGZhy{}forge | (default, Sep 29 2021, 19:20:46)
  [GCC 9.4.0]

             pemtk : 0.0.1
           epsproc : 1.3.2\PYGZhy{}dev
            xarray : 2022.3.0
            pandas : 1.3.4
             scipy : 1.7.1
        matplotlib : 3.4.3
        jupyterlab : 3.2.1
            plotly : 5.13.1
         holoviews : 1.15.4
             numpy : 1.20.3
           IPython : 7.28.0
            scooby : 0.7.1
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{!}jupyter\PYGZhy{}book\PYG{+w}{ }\PYGZhy{}\PYGZhy{}version
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Jupyter Book      : 0.15.1
External ToC      : 0.3.1
MyST\PYGZhy{}Parser       : 0.18.1
MyST\PYGZhy{}NB           : 0.17.1
Sphinx Book Theme : 1.0.0
Jupyter\PYGZhy{}Cache     : 0.5.0
NbClient          : 0.5.4
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Docker build env}
\label{\detokenize{tests/build_versions_checks:docker-build-env}}
\sphinxAtStartPar
To do


\section{Book versions}
\label{\detokenize{tests/build_versions_checks:book-versions}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{QMpath} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/home/jovyan/QM3}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{o}{!}git\PYG{+w}{ }\PYGZhy{}C\PYG{+w}{ }\PYG{o}{\PYGZob{}}QMpath\PYG{o}{\PYGZcb{}}\PYG{+w}{ }branch
\PYG{o}{!}git\PYG{+w}{ }\PYGZhy{}C\PYG{+w}{ }\PYG{o}{\PYGZob{}}QMpath\PYG{o}{\PYGZcb{}}\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}\PYGZhy{}format\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZpc{}H\PYGZdq{}}\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }\PYG{l+m}{1}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
  gh\PYGZhy{}pages
* \PYG{Color+ColorGreen}{main}
145b10a3aedee84915005e57840a4f271b64ad0a
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Check current remote commits}
\PYG{o}{!}git\PYG{+w}{ }ls\PYGZhy{}remote\PYG{+w}{ }\PYGZhy{}\PYGZhy{}heads\PYG{+w}{ }https://github.com/phockett/Quantum\PYGZhy{}Metrology\PYGZhy{}with\PYGZhy{}Photoelectrons\PYGZhy{}Vol3
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
4263720ddb7693f9a31bfb2d2d9f93f38d78c940	refs/heads/gh\PYGZhy{}pages
017025c5c83572dde75504fde177b3a34c432ed4	refs/heads/main
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Github pkg versions}
\label{\detokenize{tests/build_versions_checks:github-pkg-versions}}
\sphinxAtStartPar
Note \sphinxhyphen{} can’t get versions for local pip installs from repo(?).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{pathlib} \PYG{k+kn}{import} \PYG{n}{Path}
\PYG{k+kn}{import} \PYG{n+nn}{epsproc} \PYG{k}{as} \PYG{n+nn}{ep}
\PYG{n}{ep}\PYG{o}{.}\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}file\PYGZus{}\PYGZus{}}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}/opt/conda/lib/python3.9/site\PYGZhy{}packages/epsproc/\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}.py\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Check current Git commit for local ePSproc version \PYGZhy{} NOTE THIS ONLY WORKS FOR INSTALLED FROM GIT CLONES}
\PYG{c+c1}{\PYGZsh{} from pathlib import Path}
\PYG{c+c1}{\PYGZsh{} import epsproc as ep}
\PYG{o}{!}git\PYG{+w}{ }\PYGZhy{}C\PYG{+w}{ }\PYG{o}{\PYGZob{}}Path\PYG{o}{(}ep.\PYGZus{}\PYGZus{}file\PYGZus{}\PYGZus{}\PYG{o}{)}.parent\PYG{o}{\PYGZcb{}}\PYG{+w}{ }branch
\PYG{o}{!}git\PYG{+w}{ }\PYGZhy{}C\PYG{+w}{ }\PYG{o}{\PYGZob{}}Path\PYG{o}{(}ep.\PYGZus{}\PYGZus{}file\PYGZus{}\PYGZus{}\PYG{o}{)}.parent\PYG{o}{\PYGZcb{}}\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}\PYGZhy{}format\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZpc{}H\PYGZdq{}}\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }\PYG{l+m}{1}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
fatal: not a git repository (or any of the parent directories): .git
fatal: not a git repository (or any of the parent directories): .git
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Check current remote commits}
\PYG{o}{!}git\PYG{+w}{ }ls\PYGZhy{}remote\PYG{+w}{ }\PYGZhy{}\PYGZhy{}heads\PYG{+w}{ }https://github.com/phockett/ePSproc
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
897d73392a7b32ffba4ca6b6b4755c61e7c1c8d7	refs/heads/dependabot/pip/notes/envs/envs\PYGZhy{}versioned/certifi\PYGZhy{}2022.12.7
457f8cd85d89bd6474296b6c01e5165a4a7ce7fc	refs/heads/dependabot/pip/notes/envs/envs\PYGZhy{}versioned/cryptography\PYGZhy{}39.0.1
2855573d0f088b45d19acf2fd9a71eeb7af0a29b	refs/heads/dependabot/pip/notes/envs/envs\PYGZhy{}versioned/ipython\PYGZhy{}8.10.0
92c661789a7d2927f2b53d7266f57de70b3834fa	refs/heads/dependabot/pip/notes/envs/envs\PYGZhy{}versioned/mistune\PYGZhy{}2.0.3
fe1e9540c7b91fe571f60562acd31d8e489d491e	refs/heads/dependabot/pip/notes/envs/envs\PYGZhy{}versioned/nbconvert\PYGZhy{}6.5.1
70b80a1e3a54de91c2bfe3b6be82d611fcfd5f43	refs/heads/dependabot/pip/notes/envs/envs\PYGZhy{}versioned/pillow\PYGZhy{}9.3.0
92fc79b09aafedadcb645f88bb7ed771c96d5b52	refs/heads/dependabot/pip/notes/envs/envs\PYGZhy{}versioned/setuptools\PYGZhy{}65.5.1
fa33ed8d63a5c4a4043cc4c261059cc09e4c2bf7	refs/heads/dependabot/pip/notes/envs/envs\PYGZhy{}versioned/wheel\PYGZhy{}0.38.1
41cdfe43750e08c510f98b05e024a9c62da42771	refs/heads/dependabot/pip/setuptools\PYGZhy{}65.5.1
e1165bbb81743262984e5d79998b12f50b69f4f5	refs/heads/dev
1c0b8fd409648f07c85f4f20628b5ea7627e0c4e	refs/heads/master
69cd89ce5bc0ad6d465a4bd8df6fba15d3fd1aee	refs/heads/numba\PYGZhy{}tests
ea30878c842f09d525fbf39fa269fa2302a13b57	refs/heads/revert\PYGZhy{}9\PYGZhy{}master
baf0be0c962e8ab3c3df57c8f70f0e939f99cbd7	refs/heads/testDev
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Check current remote commits}
\PYG{o}{!}git\PYG{+w}{ }ls\PYGZhy{}remote\PYG{+w}{ }\PYGZhy{}\PYGZhy{}heads\PYG{+w}{ }https://github.com/phockett/PEMtk
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
7b3bcb92ce5262cfc46562366c2ce024dd4509d5	refs/heads/master
3f4686dffdbb310f15692f978ba36d6a3d15e8d3	refs/heads/mfFittingDev
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Full conda env}
\label{\detokenize{tests/build_versions_checks:full-conda-env}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{!}conda\PYG{+w}{ }list
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsh{} packages in environment at /opt/conda:
\PYGZsh{}
\PYGZsh{} Name                    Version                   Build  Channel
\PYGZus{}libgcc\PYGZus{}mutex             0.1                 conda\PYGZus{}forge    conda\PYGZhy{}forge
\PYGZus{}openmp\PYGZus{}mutex             4.5                      1\PYGZus{}llvm    conda\PYGZhy{}forge
accessible\PYGZhy{}pygments       0.0.3                    pypi\PYGZus{}0    pypi
alabaster                 0.7.13                   pypi\PYGZus{}0    pypi
alembic                   1.7.4              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
alsa\PYGZhy{}lib                  1.2.3.2              h166bdaf\PYGZus{}0    conda\PYGZhy{}forge
altair                    4.1.0                      py\PYGZus{}1    conda\PYGZhy{}forge
ansi2html                 1.8.0            py39hf3d152e\PYGZus{}1    conda\PYGZhy{}forge
anyio                     3.3.4            py39hf3d152e\PYGZus{}0    conda\PYGZhy{}forge
appdirs                   1.4.4              pyh9f0ad1d\PYGZus{}0    conda\PYGZhy{}forge
argon2\PYGZhy{}cffi               21.1.0           py39h3811e60\PYGZus{}0    conda\PYGZhy{}forge
asteval                   0.9.29             pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
astropy                   5.0.4            py39hd257fcd\PYGZus{}0    conda\PYGZhy{}forge
async\PYGZus{}generator           1.10                       py\PYGZus{}0    conda\PYGZhy{}forge
atk\PYGZhy{}1.0                   2.36.0               h3371d22\PYGZus{}4    conda\PYGZhy{}forge
attrs                     21.2.0             pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
babel                     2.9.1              pyh44b312d\PYGZus{}0    conda\PYGZhy{}forge
backcall                  0.2.0              pyh9f0ad1d\PYGZus{}0    conda\PYGZhy{}forge
backports                 1.0                        py\PYGZus{}2    conda\PYGZhy{}forge
backports.functools\PYGZus{}lru\PYGZus{}cache 1.6.4              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
beautifulsoup4            4.10.0             pyha770c72\PYGZus{}0    conda\PYGZhy{}forge
blas                      2.112                  openblas    conda\PYGZhy{}forge
blas\PYGZhy{}devel                3.9.0           12\PYGZus{}linux64\PYGZus{}openblas    conda\PYGZhy{}forge
bleach                    4.1.0              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
blinker                   1.4                        py\PYGZus{}1    conda\PYGZhy{}forge
blosc                     1.21.0               h9c3ff4c\PYGZus{}0    conda\PYGZhy{}forge
bokeh                     2.4.1            py39hf3d152e\PYGZus{}1    conda\PYGZhy{}forge
boost\PYGZhy{}cpp                 1.74.0               h312852a\PYGZus{}4    conda\PYGZhy{}forge
bottleneck                1.3.2            py39hce5d2b2\PYGZus{}4    conda\PYGZhy{}forge
brotli                    1.0.9                h7f98852\PYGZus{}5    conda\PYGZhy{}forge
brotli\PYGZhy{}bin                1.0.9                h7f98852\PYGZus{}5    conda\PYGZhy{}forge
brotli\PYGZhy{}python             1.0.9            py39h5a03fae\PYGZus{}7    conda\PYGZhy{}forge
brotlipy                  0.7.0           py39h3811e60\PYGZus{}1001    conda\PYGZhy{}forge
brunsli                   0.1                  h9c3ff4c\PYGZus{}0    conda\PYGZhy{}forge
bzip2                     1.0.8                h7f98852\PYGZus{}4    conda\PYGZhy{}forge
c\PYGZhy{}ares                    1.18.1               h7f98852\PYGZus{}0    conda\PYGZhy{}forge
c\PYGZhy{}blosc2                  2.0.4                h5f21a17\PYGZus{}1    conda\PYGZhy{}forge
ca\PYGZhy{}certificates           2022.12.7            ha878542\PYGZus{}0    conda\PYGZhy{}forge
cached\PYGZhy{}property           1.5.2                hd8ed1ab\PYGZus{}1    conda\PYGZhy{}forge
cached\PYGZus{}property           1.5.2              pyha770c72\PYGZus{}1    conda\PYGZhy{}forge
cairo                     1.16.0            h6cf1ce9\PYGZus{}1008    conda\PYGZhy{}forge
cartopy                   0.20.1           py39he7aa91e\PYGZus{}2    conda\PYGZhy{}forge
certifi                   2022.12.7          pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
certipy                   0.1.3                      py\PYGZus{}0    conda\PYGZhy{}forge
cffi                      1.14.6           py39h4bc2ebd\PYGZus{}1    conda\PYGZhy{}forge
cfitsio                   4.0.0                h9a35b8e\PYGZus{}0    conda\PYGZhy{}forge
cftime                    1.6.0            py39hd257fcd\PYGZus{}1    conda\PYGZhy{}forge
chardet                   4.0.0            py39hf3d152e\PYGZus{}1    conda\PYGZhy{}forge
charls                    2.2.0                h9c3ff4c\PYGZus{}0    conda\PYGZhy{}forge
charset\PYGZhy{}normalizer        2.0.0              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
chrpath                   0.16              h7f98852\PYGZus{}1002    conda\PYGZhy{}forge
click                     8.0.3            py39hf3d152e\PYGZus{}0    conda\PYGZhy{}forge
cloudpickle               2.0.0              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
colorama                  0.4.4              pyh9f0ad1d\PYGZus{}0    conda\PYGZhy{}forge
colorcet                  3.0.1              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
conda                     4.10.3           py39hf3d152e\PYGZus{}2    conda\PYGZhy{}forge
conda\PYGZhy{}package\PYGZhy{}handling    1.7.3            py39h3811e60\PYGZus{}0    conda\PYGZhy{}forge
configurable\PYGZhy{}http\PYGZhy{}proxy   4.5.0           node15\PYGZus{}he6ea98c\PYGZus{}0    conda\PYGZhy{}forge
cryptography              35.0.0           py39h95dcef6\PYGZus{}1    conda\PYGZhy{}forge
curl                      7.79.1               h2574ce0\PYGZus{}1    conda\PYGZhy{}forge
cycler                    0.10.0                     py\PYGZus{}2    conda\PYGZhy{}forge
cython                    0.29.24          py39he80948d\PYGZus{}0    conda\PYGZhy{}forge
cytoolz                   0.11.0           py39h3811e60\PYGZus{}3    conda\PYGZhy{}forge
dash                      2.9.1              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
dask                      2021.10.0          pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
dask\PYGZhy{}core                 2021.10.0          pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
dbus                      1.13.6               h5008d03\PYGZus{}3    conda\PYGZhy{}forge
dcw\PYGZhy{}gmt                   2.1.1                ha770c72\PYGZus{}0    conda\PYGZhy{}forge
debugpy                   1.4.1            py39he80948d\PYGZus{}0    conda\PYGZhy{}forge
decorator                 5.1.0              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
defusedxml                0.7.1              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
dill                      0.3.4              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
distributed               2021.10.0        py39hf3d152e\PYGZus{}0    conda\PYGZhy{}forge
docutils                  0.18.1                   pypi\PYGZus{}0    pypi
ducc0                     0.23.0           py39h5a03fae\PYGZus{}0    conda\PYGZhy{}forge
entrypoints               0.3             py39hde42818\PYGZus{}1002    conda\PYGZhy{}forge
epsproc                   1.3.2.dev0               pypi\PYGZus{}0    pypi
exceptiongroup            1.1.1              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
expat                     2.4.8                h27087fc\PYGZus{}0    conda\PYGZhy{}forge
ffmpeg                    4.4.0                h6987444\PYGZus{}4    conda\PYGZhy{}forge
fftw                      3.3.10          nompi\PYGZus{}h77c792f\PYGZus{}102    conda\PYGZhy{}forge
firefox                   100.0                h27087fc\PYGZus{}0    conda\PYGZhy{}forge
flask                     2.1.3              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
flask\PYGZhy{}compress            1.13               pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
font\PYGZhy{}ttf\PYGZhy{}dejavu\PYGZhy{}sans\PYGZhy{}mono 2.37                 hab24e00\PYGZus{}0    conda\PYGZhy{}forge
font\PYGZhy{}ttf\PYGZhy{}inconsolata      3.000                h77eed37\PYGZus{}0    conda\PYGZhy{}forge
font\PYGZhy{}ttf\PYGZhy{}source\PYGZhy{}code\PYGZhy{}pro  2.038                h77eed37\PYGZus{}0    conda\PYGZhy{}forge
font\PYGZhy{}ttf\PYGZhy{}ubuntu           0.83                 hab24e00\PYGZus{}0    conda\PYGZhy{}forge
fontconfig                2.14.0               h8e229c2\PYGZus{}0    conda\PYGZhy{}forge
fonts\PYGZhy{}conda\PYGZhy{}ecosystem     1                             0    conda\PYGZhy{}forge
fonts\PYGZhy{}conda\PYGZhy{}forge         1                             0    conda\PYGZhy{}forge
freetype                  2.10.4               h0708190\PYGZus{}1    conda\PYGZhy{}forge
freexl                    1.0.6                h7f98852\PYGZus{}0    conda\PYGZhy{}forge
fribidi                   1.0.10               h36c2ea0\PYGZus{}0    conda\PYGZhy{}forge
fsspec                    2021.10.1          pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
future                    0.18.3             pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
gdal                      3.3.3            py39h0494519\PYGZus{}2    conda\PYGZhy{}forge
gdk\PYGZhy{}pixbuf                2.42.6               h04a7f16\PYGZus{}0    conda\PYGZhy{}forge
geckodriver               0.30.0               h3146498\PYGZus{}0    conda\PYGZhy{}forge
geos                      3.10.0               h9c3ff4c\PYGZus{}0    conda\PYGZhy{}forge
geotiff                   1.7.0                hcfb7246\PYGZus{}3    conda\PYGZhy{}forge
gettext                   0.19.8.1          h73d1719\PYGZus{}1008    conda\PYGZhy{}forge
ghostscript               9.54.0               h27087fc\PYGZus{}2    conda\PYGZhy{}forge
ghp\PYGZhy{}import                2.1.0                    pypi\PYGZus{}0    pypi
giflib                    5.2.1                h36c2ea0\PYGZus{}2    conda\PYGZhy{}forge
glib                      2.70.2               h780b84a\PYGZus{}4    conda\PYGZhy{}forge
glib\PYGZhy{}tools                2.70.2               h780b84a\PYGZus{}4    conda\PYGZhy{}forge
gmp                       6.2.1                h58526e2\PYGZus{}0    conda\PYGZhy{}forge
gmpy2                     2.1.0b5          py39h78fa15d\PYGZus{}0    conda\PYGZhy{}forge
gmt                       6.2.0                h7e416ca\PYGZus{}3    conda\PYGZhy{}forge
gnuplot                   5.4.3                hedd7fda\PYGZus{}0    conda\PYGZhy{}forge
gnutls                    3.6.13               h85f3911\PYGZus{}1    conda\PYGZhy{}forge
graphicsmagick            1.3.37               hdc87540\PYGZus{}0    conda\PYGZhy{}forge
graphite2                 1.3.13            h58526e2\PYGZus{}1001    conda\PYGZhy{}forge
greenlet                  1.1.2            py39he80948d\PYGZus{}0    conda\PYGZhy{}forge
gshhg\PYGZhy{}gmt                 2.3.7             ha770c72\PYGZus{}1003    conda\PYGZhy{}forge
gst\PYGZhy{}plugins\PYGZhy{}base          1.18.5               hf529b03\PYGZus{}3    conda\PYGZhy{}forge
gstreamer                 1.18.5               h9f60fe5\PYGZus{}3    conda\PYGZhy{}forge
gtk2                      2.24.33              h539f30e\PYGZus{}1    conda\PYGZhy{}forge
h11                       0.14.0             pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
h5netcdf                  1.1.0              pyhd8ed1ab\PYGZus{}1    conda\PYGZhy{}forge
h5py                      3.4.0           nompi\PYGZus{}py39h7e08c79\PYGZus{}101    conda\PYGZhy{}forge
harfbuzz                  3.1.1                h83ec7ef\PYGZus{}0    conda\PYGZhy{}forge
hdf4                      4.2.15               h10796ff\PYGZus{}3    conda\PYGZhy{}forge
hdf5                      1.12.1          nompi\PYGZus{}h2750804\PYGZus{}101    conda\PYGZhy{}forge
heapdict                  1.0.1                      py\PYGZus{}0    conda\PYGZhy{}forge
holoviews                 1.15.4             pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
hvplot                    0.8.3                      py\PYGZus{}0    pyviz
icu                       68.2                 h9c3ff4c\PYGZus{}0    conda\PYGZhy{}forge
idna                      3.1                pyhd3deb0d\PYGZus{}0    conda\PYGZhy{}forge
imagecodecs               2021.8.26        py39h571908b\PYGZus{}2    conda\PYGZhy{}forge
imageio                   2.9.0                      py\PYGZus{}0    conda\PYGZhy{}forge
imagesize                 1.4.1                    pypi\PYGZus{}0    pypi
importlib\PYGZhy{}metadata        4.8.1            py39hf3d152e\PYGZus{}0    conda\PYGZhy{}forge
importlib\PYGZus{}metadata        4.8.1                hd8ed1ab\PYGZus{}1    conda\PYGZhy{}forge
importlib\PYGZus{}resources       5.3.0              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
ipykernel                 6.4.2            py39hef51801\PYGZus{}0    conda\PYGZhy{}forge
ipympl                    0.8.2              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
ipython                   7.28.0           py39hef51801\PYGZus{}0    conda\PYGZhy{}forge
ipython\PYGZus{}genutils          0.2.0                      py\PYGZus{}1    conda\PYGZhy{}forge
ipywidgets                7.6.5              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
itsdangerous              2.1.2              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
jbig                      2.1               h7f98852\PYGZus{}2003    conda\PYGZhy{}forge
jedi                      0.18.0           py39hf3d152e\PYGZus{}2    conda\PYGZhy{}forge
jinja2                    3.0.2              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
joblib                    1.1.0              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
jpeg                      9d                   h36c2ea0\PYGZus{}0    conda\PYGZhy{}forge
json\PYGZhy{}c                    0.15                 h98cffda\PYGZus{}0    conda\PYGZhy{}forge
json5                     0.9.5              pyh9f0ad1d\PYGZus{}0    conda\PYGZhy{}forge
jsonschema                4.1.2              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
jupyter\PYGZhy{}book              0.15.1                   pypi\PYGZus{}0    pypi
jupyter\PYGZhy{}cache             0.5.0                    pypi\PYGZus{}0    pypi
jupyter\PYGZhy{}dash              0.4.2              pyhd8ed1ab\PYGZus{}1    conda\PYGZhy{}forge
jupyter\PYGZus{}client            7.0.6              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
jupyter\PYGZus{}core              4.9.1            py39hf3d152e\PYGZus{}0    conda\PYGZhy{}forge
jupyter\PYGZus{}server            1.11.1             pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
jupyter\PYGZus{}telemetry         0.1.0              pyhd8ed1ab\PYGZus{}1    conda\PYGZhy{}forge
jupyterhub                1.4.2            py39hf3d152e\PYGZus{}0    conda\PYGZhy{}forge
jupyterhub\PYGZhy{}base           1.4.2            py39hf3d152e\PYGZus{}0    conda\PYGZhy{}forge
jupyterlab                3.2.1              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
jupyterlab\PYGZhy{}spellchecker   0.7.3                    pypi\PYGZus{}0    pypi
jupyterlab\PYGZus{}pygments       0.1.2              pyh9f0ad1d\PYGZus{}0    conda\PYGZhy{}forge
jupyterlab\PYGZus{}server         2.8.2              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
jupyterlab\PYGZus{}widgets        1.0.2              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
jupytext                  1.14.5             pyhcff175f\PYGZus{}0    conda\PYGZhy{}forge
jxrlib                    1.1                  h7f98852\PYGZus{}2    conda\PYGZhy{}forge
kaleido\PYGZhy{}core              0.2.1                h3644ca4\PYGZus{}0    conda\PYGZhy{}forge
kealib                    1.4.14               h87e4c3c\PYGZus{}3    conda\PYGZhy{}forge
kiwisolver                1.3.2            py39h1a9c180\PYGZus{}0    conda\PYGZhy{}forge
krb5                      1.19.2               hcc1bbae\PYGZus{}2    conda\PYGZhy{}forge
lame                      3.100             h7f98852\PYGZus{}1001    conda\PYGZhy{}forge
latexcodec                2.0.1                    pypi\PYGZus{}0    pypi
lcms2                     2.12                 hddcbb42\PYGZus{}0    conda\PYGZhy{}forge
ld\PYGZus{}impl\PYGZus{}linux\PYGZhy{}64          2.36.1               hea4e1c9\PYGZus{}2    conda\PYGZhy{}forge
lerc                      3.0                  h9c3ff4c\PYGZus{}0    conda\PYGZhy{}forge
libaec                    1.0.6                h9c3ff4c\PYGZus{}0    conda\PYGZhy{}forge
libarchive                3.5.2                hccf745f\PYGZus{}1    conda\PYGZhy{}forge
libblas                   3.9.0           12\PYGZus{}linux64\PYGZus{}openblas    conda\PYGZhy{}forge
libbrotlicommon           1.0.9                h7f98852\PYGZus{}5    conda\PYGZhy{}forge
libbrotlidec              1.0.9                h7f98852\PYGZus{}5    conda\PYGZhy{}forge
libbrotlienc              1.0.9                h7f98852\PYGZus{}5    conda\PYGZhy{}forge
libcblas                  3.9.0           12\PYGZus{}linux64\PYGZus{}openblas    conda\PYGZhy{}forge
libclang                  11.1.0          default\PYGZus{}ha53f305\PYGZus{}1    conda\PYGZhy{}forge
libcurl                   7.79.1               h2574ce0\PYGZus{}1    conda\PYGZhy{}forge
libdap4                   3.20.6               hd7c4107\PYGZus{}2    conda\PYGZhy{}forge
libdeflate                1.8                  h7f98852\PYGZus{}0    conda\PYGZhy{}forge
libedit                   3.1.20191231         he28a2e2\PYGZus{}2    conda\PYGZhy{}forge
libev                     4.33                 h516909a\PYGZus{}1    conda\PYGZhy{}forge
libevent                  2.1.10               h9b69904\PYGZus{}4    conda\PYGZhy{}forge
libffi                    3.4.2                h9c3ff4c\PYGZus{}4    conda\PYGZhy{}forge
libgcc\PYGZhy{}ng                 11.2.0              h1d223b6\PYGZus{}11    conda\PYGZhy{}forge
libgd                     2.3.3                h6ad9fb6\PYGZus{}0    conda\PYGZhy{}forge
libgdal                   3.3.3                h18e3bf0\PYGZus{}2    conda\PYGZhy{}forge
libgfortran\PYGZhy{}ng            11.2.0              h69a702a\PYGZus{}11    conda\PYGZhy{}forge
libgfortran5              11.2.0              h5c6108e\PYGZus{}11    conda\PYGZhy{}forge
libglib                   2.70.2               h174f98d\PYGZus{}4    conda\PYGZhy{}forge
libgomp                   11.2.0              h1d223b6\PYGZus{}11    conda\PYGZhy{}forge
libiconv                  1.16                 h516909a\PYGZus{}0    conda\PYGZhy{}forge
libkml                    1.3.0             h238a007\PYGZus{}1014    conda\PYGZhy{}forge
liblapack                 3.9.0           12\PYGZus{}linux64\PYGZus{}openblas    conda\PYGZhy{}forge
liblapacke                3.9.0           12\PYGZus{}linux64\PYGZus{}openblas    conda\PYGZhy{}forge
libllvm11                 11.1.0               hf817b99\PYGZus{}2    conda\PYGZhy{}forge
libmsym                   0.2.4                    pypi\PYGZus{}0    pypi
libnetcdf                 4.8.1           nompi\PYGZus{}hb3fd0d9\PYGZus{}101    conda\PYGZhy{}forge
libnghttp2                1.43.0               h812cca2\PYGZus{}1    conda\PYGZhy{}forge
libnsl                    2.0.0                h7f98852\PYGZus{}0    conda\PYGZhy{}forge
libogg                    1.3.4                h7f98852\PYGZus{}1    conda\PYGZhy{}forge
libopenblas               0.3.18          pthreads\PYGZus{}h8fe5266\PYGZus{}0    conda\PYGZhy{}forge
libopus                   1.3.1                h7f98852\PYGZus{}1    conda\PYGZhy{}forge
libpng                    1.6.37               h21135ba\PYGZus{}2    conda\PYGZhy{}forge
libpq                     13.5                 hd57d9b9\PYGZus{}1    conda\PYGZhy{}forge
libprotobuf               3.18.1               h780b84a\PYGZus{}0    conda\PYGZhy{}forge
librttopo                 1.1.0                h0ad649c\PYGZus{}7    conda\PYGZhy{}forge
libsodium                 1.0.18               h36c2ea0\PYGZus{}1    conda\PYGZhy{}forge
libsolv                   0.7.19               h780b84a\PYGZus{}5    conda\PYGZhy{}forge
libspatialite             5.0.1               h1d9e4f1\PYGZus{}10    conda\PYGZhy{}forge
libssh2                   1.10.0               ha56f1ee\PYGZus{}2    conda\PYGZhy{}forge
libstdcxx\PYGZhy{}ng              11.2.0              he4da1e4\PYGZus{}11    conda\PYGZhy{}forge
libtiff                   4.3.0                h6f004c6\PYGZus{}2    conda\PYGZhy{}forge
libuuid                   2.32.1            h7f98852\PYGZus{}1000    conda\PYGZhy{}forge
libuv                     1.41.1               h7f98852\PYGZus{}0    conda\PYGZhy{}forge
libvorbis                 1.3.7                h9c3ff4c\PYGZus{}0    conda\PYGZhy{}forge
libvpx                    1.11.0               h9c3ff4c\PYGZus{}3    conda\PYGZhy{}forge
libwebp                   1.2.1                h3452ae3\PYGZus{}0    conda\PYGZhy{}forge
libwebp\PYGZhy{}base              1.2.1                h7f98852\PYGZus{}0    conda\PYGZhy{}forge
libxcb                    1.13              h7f98852\PYGZus{}1004    conda\PYGZhy{}forge
libxkbcommon              1.0.3                he3ba5ed\PYGZus{}0    conda\PYGZhy{}forge
libxml2                   2.9.12               h72842e0\PYGZus{}0    conda\PYGZhy{}forge
libzip                    1.8.0                h4de3113\PYGZus{}1    conda\PYGZhy{}forge
libzlib                   1.2.11            h36c2ea0\PYGZus{}1013    conda\PYGZhy{}forge
libzopfli                 1.0.3                h9c3ff4c\PYGZus{}0    conda\PYGZhy{}forge
linkify\PYGZhy{}it\PYGZhy{}py             2.0.0                    pypi\PYGZus{}0    pypi
llvm\PYGZhy{}openmp               12.0.1               h4bd325d\PYGZus{}1    conda\PYGZhy{}forge
llvmlite                  0.37.0           py39h1bbdace\PYGZus{}0    conda\PYGZhy{}forge
lmfit                     1.1.0              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
locket                    0.2.0                      py\PYGZus{}2    conda\PYGZhy{}forge
lz4\PYGZhy{}c                     1.9.3                h9c3ff4c\PYGZus{}1    conda\PYGZhy{}forge
lzo                       2.10              h516909a\PYGZus{}1000    conda\PYGZhy{}forge
mako                      1.1.5              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
mamba                     0.17.0           py39h951de11\PYGZus{}0    conda\PYGZhy{}forge
markdown                  3.4.1              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
markdown\PYGZhy{}it\PYGZhy{}py            2.2.0              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
markupsafe                2.0.1            py39h3811e60\PYGZus{}0    conda\PYGZhy{}forge
mathjax                   2.7.7                ha770c72\PYGZus{}3    conda\PYGZhy{}forge
matplotlib\PYGZhy{}base           3.4.3            py39h2fa2bec\PYGZus{}1    conda\PYGZhy{}forge
matplotlib\PYGZhy{}inline         0.1.3              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
mdit\PYGZhy{}py\PYGZhy{}plugins           0.3.5              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
mdurl                     0.1.0              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
mistune                   0.8.4           py39h3811e60\PYGZus{}1004    conda\PYGZhy{}forge
mock                      4.0.3            py39hf3d152e\PYGZus{}1    conda\PYGZhy{}forge
mpc                       1.2.1                h9f54685\PYGZus{}0    conda\PYGZhy{}forge
mpfr                      4.1.0                h9202a9a\PYGZus{}1    conda\PYGZhy{}forge
mpmath                    1.2.1              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
msgpack\PYGZhy{}python            1.0.2            py39h1a9c180\PYGZus{}1    conda\PYGZhy{}forge
mysql\PYGZhy{}common              8.0.27               ha770c72\PYGZus{}3    conda\PYGZhy{}forge
mysql\PYGZhy{}libs                8.0.27               hfa10184\PYGZus{}3    conda\PYGZhy{}forge
myst\PYGZhy{}nb                   0.17.1                   pypi\PYGZus{}0    pypi
myst\PYGZhy{}parser               0.18.1                   pypi\PYGZus{}0    pypi
nbclassic                 0.3.3              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
nbclient                  0.5.4              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
nbconvert                 6.2.0            py39hf3d152e\PYGZus{}0    conda\PYGZhy{}forge
nbformat                  5.1.3              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
ncurses                   6.2                  h58526e2\PYGZus{}4    conda\PYGZhy{}forge
nest\PYGZhy{}asyncio              1.5.1              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
netcdf4                   1.5.8           nompi\PYGZus{}py39h64b754b\PYGZus{}101    conda\PYGZhy{}forge
nettle                    3.6                  he412f7d\PYGZus{}0    conda\PYGZhy{}forge
networkx                  2.6.3              pyhd8ed1ab\PYGZus{}1    conda\PYGZhy{}forge
nodejs                    15.14.0              h92b4a50\PYGZus{}0    conda\PYGZhy{}forge
notebook                  6.4.5              pyha770c72\PYGZus{}0    conda\PYGZhy{}forge
nspr                      4.32                 h9c3ff4c\PYGZus{}1    conda\PYGZhy{}forge
nss                       3.72                 hb5efdd6\PYGZus{}0    conda\PYGZhy{}forge
numba                     0.54.1           py39h56b8d98\PYGZus{}0    conda\PYGZhy{}forge
numexpr                   2.7.3            py39hde0f152\PYGZus{}0    conda\PYGZhy{}forge
numpy                     1.20.3           py39hdbf815f\PYGZus{}1    conda\PYGZhy{}forge
oauthlib                  3.1.1              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
olefile                   0.46               pyh9f0ad1d\PYGZus{}1    conda\PYGZhy{}forge
openblas                  0.3.18          pthreads\PYGZus{}h4748800\PYGZus{}0    conda\PYGZhy{}forge
openh264                  2.1.1                h780b84a\PYGZus{}0    conda\PYGZhy{}forge
openjpeg                  2.4.0                hb52868f\PYGZus{}1    conda\PYGZhy{}forge
openssl                   1.1.1o               h166bdaf\PYGZus{}0    conda\PYGZhy{}forge
outcome                   1.2.0              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
packaging                 21.0               pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
pamela                    1.0.0                      py\PYGZus{}0    conda\PYGZhy{}forge
pandas                    1.3.4            py39hde0f152\PYGZus{}0    conda\PYGZhy{}forge
pandoc                    2.15                 h7f98852\PYGZus{}0    conda\PYGZhy{}forge
pandocfilters             1.5.0              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
panel                     0.14.4             pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
pango                     1.48.10              h54213e6\PYGZus{}2    conda\PYGZhy{}forge
param                     1.13.0             pyh1a96a4e\PYGZus{}0    conda\PYGZhy{}forge
parso                     0.8.2              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
partd                     1.2.0              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
patsy                     0.5.2              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
pcre                      8.45                 h9c3ff4c\PYGZus{}0    conda\PYGZhy{}forge
pemtk                     0.0.1                    pypi\PYGZus{}0    pypi
pexpect                   4.8.0              pyh9f0ad1d\PYGZus{}2    conda\PYGZhy{}forge
pickleshare               0.7.5           py39hde42818\PYGZus{}1002    conda\PYGZhy{}forge
pillow                    8.3.2            py39ha612740\PYGZus{}0    conda\PYGZhy{}forge
pip                       21.3.1             pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
pixman                    0.40.0               h36c2ea0\PYGZus{}0    conda\PYGZhy{}forge
plotly                    5.13.1             pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
pooch                     1.5.2              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
poppler                   21.09.0              ha39eefc\PYGZus{}3    conda\PYGZhy{}forge
poppler\PYGZhy{}data              0.4.12               hd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
postgresql                13.5                 h2510834\PYGZus{}1    conda\PYGZhy{}forge
proj                      8.1.1                h277dcde\PYGZus{}2    conda\PYGZhy{}forge
prometheus\PYGZus{}client         0.11.0             pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
prompt\PYGZhy{}toolkit            3.0.21             pyha770c72\PYGZus{}0    conda\PYGZhy{}forge
protobuf                  3.18.1           py39he80948d\PYGZus{}0    conda\PYGZhy{}forge
psutil                    5.8.0            py39h3811e60\PYGZus{}1    conda\PYGZhy{}forge
pthread\PYGZhy{}stubs             0.4               h36c2ea0\PYGZus{}1001    conda\PYGZhy{}forge
ptyprocess                0.7.0              pyhd3deb0d\PYGZus{}0    conda\PYGZhy{}forge
pybtex                    0.24.0                   pypi\PYGZus{}0    pypi
pybtex\PYGZhy{}docutils           1.0.2                    pypi\PYGZus{}0    pypi
pycosat                   0.6.3           py39h3811e60\PYGZus{}1006    conda\PYGZhy{}forge
pycparser                 2.20               pyh9f0ad1d\PYGZus{}2    conda\PYGZhy{}forge
pyct                      0.4.6                      py\PYGZus{}0    conda\PYGZhy{}forge
pyct\PYGZhy{}core                 0.4.6                      py\PYGZus{}0    conda\PYGZhy{}forge
pycurl                    7.44.1           py39h72e3413\PYGZus{}0    conda\PYGZhy{}forge
pydata\PYGZhy{}sphinx\PYGZhy{}theme       0.13.1                   pypi\PYGZus{}0    pypi
pyerfa                    2.0.0.1          py39hd257fcd\PYGZus{}2    conda\PYGZhy{}forge
pygments                  2.14.0                   pypi\PYGZus{}0    pypi
pygmt                     0.5.0              pyhd8ed1ab\PYGZus{}1    conda\PYGZhy{}forge
pyjwt                     2.3.0              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
pyopenssl                 21.0.0             pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
pyparsing                 3.0.3              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
pyproj                    3.2.1            py39ha81a305\PYGZus{}2    conda\PYGZhy{}forge
pyrsistent                0.17.3           py39h3811e60\PYGZus{}2    conda\PYGZhy{}forge
pyshp                     2.3.1              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
pyshtools                 4.10             py39hd777142\PYGZus{}0    conda\PYGZhy{}forge
pysocks                   1.7.1            py39hf3d152e\PYGZus{}3    conda\PYGZhy{}forge
pytables                  3.6.1            py39h2669a42\PYGZus{}4    conda\PYGZhy{}forge
python                    3.9.7           hb7a2778\PYGZus{}3\PYGZus{}cpython    conda\PYGZhy{}forge
python\PYGZhy{}dateutil           2.8.2              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
python\PYGZhy{}json\PYGZhy{}logger        2.0.1              pyh9f0ad1d\PYGZus{}0    conda\PYGZhy{}forge
python\PYGZhy{}kaleido            0.2.1              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
python\PYGZus{}abi                3.9                      2\PYGZus{}cp39    conda\PYGZhy{}forge
pytz                      2021.3             pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
pyviz\PYGZus{}comms               2.2.1              pyhd8ed1ab\PYGZus{}1    conda\PYGZhy{}forge
pywavelets                1.1.1            py39hce5d2b2\PYGZus{}3    conda\PYGZhy{}forge
pyyaml                    6.0              py39h3811e60\PYGZus{}0    conda\PYGZhy{}forge
pyzmq                     22.3.0           py39h37b5a0c\PYGZus{}0    conda\PYGZhy{}forge
qt                        5.12.9               hda022c4\PYGZus{}4    conda\PYGZhy{}forge
quaternion                2022.4.2         py39hd257fcd\PYGZus{}0    conda\PYGZhy{}forge
readline                  8.1                  h46c0cb4\PYGZus{}0    conda\PYGZhy{}forge
reproc                    14.2.3               h7f98852\PYGZus{}0    conda\PYGZhy{}forge
reproc\PYGZhy{}cpp                14.2.3               h9c3ff4c\PYGZus{}0    conda\PYGZhy{}forge
requests                  2.26.0             pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
requests\PYGZhy{}unixsocket       0.2.0                      py\PYGZus{}0    conda\PYGZhy{}forge
retrying                  1.3.3                      py\PYGZus{}2    conda\PYGZhy{}forge
ruamel.yaml               0.17.16          py39h3811e60\PYGZus{}0    conda\PYGZhy{}forge
ruamel.yaml.clib          0.2.2            py39h3811e60\PYGZus{}2    conda\PYGZhy{}forge
ruamel\PYGZus{}yaml               0.15.80         py39h3811e60\PYGZus{}1004    conda\PYGZhy{}forge
scikit\PYGZhy{}image              0.18.3           py39hde0f152\PYGZus{}0    conda\PYGZhy{}forge
scikit\PYGZhy{}learn              1.0.1            py39h7c5d8c9\PYGZus{}1    conda\PYGZhy{}forge
scipy                     1.7.1            py39hee8e79c\PYGZus{}0    conda\PYGZhy{}forge
scooby                    0.7.1              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
seaborn                   0.9.0                      py\PYGZus{}2    conda\PYGZhy{}forge
seaborn\PYGZhy{}base              0.11.2             pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
selenium                  4.8.2              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
send2trash                1.8.0              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
setuptools                58.2.0           py39hf3d152e\PYGZus{}0    conda\PYGZhy{}forge
setuptools\PYGZhy{}scm            6.4.2              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
shapely                   1.8.0            py39hc7dd4e9\PYGZus{}2    conda\PYGZhy{}forge
six                       1.16.0             pyh6c4a22f\PYGZus{}0    conda\PYGZhy{}forge
snappy                    1.1.8                he1b5a44\PYGZus{}3    conda\PYGZhy{}forge
sniffio                   1.2.0            py39hf3d152e\PYGZus{}1    conda\PYGZhy{}forge
snowballstemmer           2.2.0                    pypi\PYGZus{}0    pypi
sortedcontainers          2.4.0              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
soupsieve                 2.0.1                      py\PYGZus{}1    conda\PYGZhy{}forge
spherical\PYGZus{}functions       2022.4.1           pyhd8ed1ab\PYGZus{}1    conda\PYGZhy{}forge
sphinx                    5.0.2                    pypi\PYGZus{}0    pypi
sphinx\PYGZhy{}book\PYGZhy{}theme         1.0.0                    pypi\PYGZus{}0    pypi
sphinx\PYGZhy{}comments           0.0.3                    pypi\PYGZus{}0    pypi
sphinx\PYGZhy{}copybutton         0.5.1                    pypi\PYGZus{}0    pypi
sphinx\PYGZhy{}design             0.3.0                    pypi\PYGZus{}0    pypi
sphinx\PYGZhy{}external\PYGZhy{}toc       0.3.1                    pypi\PYGZus{}0    pypi
sphinx\PYGZhy{}jupyterbook\PYGZhy{}latex  0.5.2                    pypi\PYGZus{}0    pypi
sphinx\PYGZhy{}multitoc\PYGZhy{}numbering 0.1.3                    pypi\PYGZus{}0    pypi
sphinx\PYGZhy{}thebe              0.2.1                    pypi\PYGZus{}0    pypi
sphinx\PYGZhy{}togglebutton       0.3.2                    pypi\PYGZus{}0    pypi
sphinxcontrib\PYGZhy{}applehelp   1.0.4                    pypi\PYGZus{}0    pypi
sphinxcontrib\PYGZhy{}bibtex      2.5.0                    pypi\PYGZus{}0    pypi
sphinxcontrib\PYGZhy{}devhelp     1.0.2                    pypi\PYGZus{}0    pypi
sphinxcontrib\PYGZhy{}htmlhelp    2.0.1                    pypi\PYGZus{}0    pypi
sphinxcontrib\PYGZhy{}jsmath      1.0.1                    pypi\PYGZus{}0    pypi
sphinxcontrib\PYGZhy{}qthelp      1.0.3                    pypi\PYGZus{}0    pypi
sphinxcontrib\PYGZhy{}serializinghtml 1.1.5                    pypi\PYGZus{}0    pypi
spinsfast                 2022.4.1         py39hc8e5db4\PYGZus{}2    conda\PYGZhy{}forge
sqlalchemy                1.4.26           py39h3811e60\PYGZus{}0    conda\PYGZhy{}forge
sqlite                    3.36.0               h9cd32fc\PYGZus{}2    conda\PYGZhy{}forge
statsmodels               0.13.0           py39hce5d2b2\PYGZus{}0    conda\PYGZhy{}forge
sympy                     1.9              py39hf3d152e\PYGZus{}0    conda\PYGZhy{}forge
tabulate                  0.9.0                    pypi\PYGZus{}0    pypi
tblib                     1.7.0              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
tenacity                  8.2.2              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
terminado                 0.12.1           py39hf3d152e\PYGZus{}0    conda\PYGZhy{}forge
testpath                  0.5.0              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
threadpoolctl             3.0.0              pyh8a188c0\PYGZus{}0    conda\PYGZhy{}forge
tifffile                  2021.10.12         pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
tiledb                    2.3.4                he87e0bf\PYGZus{}0    conda\PYGZhy{}forge
tk                        8.6.11               h27826a3\PYGZus{}1    conda\PYGZhy{}forge
toml                      0.10.2             pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
tomli                     2.0.1              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
toolz                     0.11.1                     py\PYGZus{}0    conda\PYGZhy{}forge
tornado                   6.1              py39h3811e60\PYGZus{}1    conda\PYGZhy{}forge
tqdm                      4.62.3             pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
traitlets                 5.1.1              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
trio                      0.22.0           py39hf3d152e\PYGZus{}1    conda\PYGZhy{}forge
trio\PYGZhy{}websocket            0.10.2             pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
typing\PYGZus{}extensions         3.10.0.2           pyha770c72\PYGZus{}0    conda\PYGZhy{}forge
tzcode                    2022a                h166bdaf\PYGZus{}0    conda\PYGZhy{}forge
tzdata                    2021e                he74cb21\PYGZus{}0    conda\PYGZhy{}forge
uc\PYGZhy{}micro\PYGZhy{}py               1.0.1                    pypi\PYGZus{}0    pypi
uncertainties             3.1.7              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
urllib3                   1.26.7             pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
wcwidth                   0.2.5              pyh9f0ad1d\PYGZus{}2    conda\PYGZhy{}forge
webencodings              0.5.1                      py\PYGZus{}1    conda\PYGZhy{}forge
websocket\PYGZhy{}client          0.57.0           py39hf3d152e\PYGZus{}4    conda\PYGZhy{}forge
werkzeug                  2.1.2              pyhd8ed1ab\PYGZus{}1    conda\PYGZhy{}forge
wget                      3.2                      pypi\PYGZus{}0    pypi
wheel                     0.37.0             pyhd8ed1ab\PYGZus{}1    conda\PYGZhy{}forge
widgetsnbextension        3.5.1            py39hf3d152e\PYGZus{}4    conda\PYGZhy{}forge
wsproto                   1.2.0              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
x264                      1!161.3030           h7f98852\PYGZus{}1    conda\PYGZhy{}forge
x265                      3.5                  h924138e\PYGZus{}3    conda\PYGZhy{}forge
xarray                    2022.3.0           pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
xerces\PYGZhy{}c                  3.2.3                h9d8b166\PYGZus{}3    conda\PYGZhy{}forge
xlrd                      2.0.1              pyhd8ed1ab\PYGZus{}3    conda\PYGZhy{}forge
xorg\PYGZhy{}kbproto              1.0.7             h7f98852\PYGZus{}1002    conda\PYGZhy{}forge
xorg\PYGZhy{}libice               1.0.10               h7f98852\PYGZus{}0    conda\PYGZhy{}forge
xorg\PYGZhy{}libsm                1.2.3             hd9c2040\PYGZus{}1000    conda\PYGZhy{}forge
xorg\PYGZhy{}libx11               1.7.2                h7f98852\PYGZus{}0    conda\PYGZhy{}forge
xorg\PYGZhy{}libxau               1.0.9                h7f98852\PYGZus{}0    conda\PYGZhy{}forge
xorg\PYGZhy{}libxdmcp             1.1.3                h7f98852\PYGZus{}0    conda\PYGZhy{}forge
xorg\PYGZhy{}libxext              1.3.4                h7f98852\PYGZus{}1    conda\PYGZhy{}forge
xorg\PYGZhy{}libxrender           0.9.10            h7f98852\PYGZus{}1003    conda\PYGZhy{}forge
xorg\PYGZhy{}libxt                1.2.1                h7f98852\PYGZus{}2    conda\PYGZhy{}forge
xorg\PYGZhy{}renderproto          0.11.1            h7f98852\PYGZus{}1002    conda\PYGZhy{}forge
xorg\PYGZhy{}xextproto            7.3.0             h7f98852\PYGZus{}1002    conda\PYGZhy{}forge
xorg\PYGZhy{}xproto               7.0.31            h7f98852\PYGZus{}1007    conda\PYGZhy{}forge
xz                        5.2.5                h516909a\PYGZus{}1    conda\PYGZhy{}forge
yaml                      0.2.5                h516909a\PYGZus{}0    conda\PYGZhy{}forge
zeromq                    4.3.4                h9c3ff4c\PYGZus{}1    conda\PYGZhy{}forge
zfp                       0.5.5                h9c3ff4c\PYGZus{}7    conda\PYGZhy{}forge
zict                      2.0.0                      py\PYGZus{}0    conda\PYGZhy{}forge
zipp                      3.6.0              pyhd8ed1ab\PYGZus{}0    conda\PYGZhy{}forge
zlib                      1.2.11            h36c2ea0\PYGZus{}1013    conda\PYGZhy{}forge
zstd                      1.5.0                ha95c52a\PYGZus{}0    conda\PYGZhy{}forge
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxthebibliography}{10}
\bibitem[1]{backmatter/bibliography:id569}
\sphinxAtStartPar
Paul Hockett. \sphinxstyleemphasis{Quantum Metrology with Photoelectrons, Volume 1: Foundations}. IOP Publishing, 2018. ISBN 978\sphinxhyphen{}1\sphinxhyphen{}68174\sphinxhyphen{}684\sphinxhyphen{}5. \sphinxhref{https://doi.org/10.1088/978-1-6817-4684-5}{doi:10.1088/978\sphinxhyphen{}1\sphinxhyphen{}6817\sphinxhyphen{}4684\sphinxhyphen{}5}.
\bibitem[2]{backmatter/bibliography:id570}
\sphinxAtStartPar
Paul Hockett. \sphinxstyleemphasis{Quantum Metrology with Photoelectrons, Volume 2: Applications and Advances}. IOP Publishing, 2018. ISBN 978\sphinxhyphen{}1\sphinxhyphen{}68174\sphinxhyphen{}688\sphinxhyphen{}3. \sphinxhref{https://doi.org/10.1088/978-1-6817-4688-3}{doi:10.1088/978\sphinxhyphen{}1\sphinxhyphen{}6817\sphinxhyphen{}4688\sphinxhyphen{}3}.
\bibitem[3]{backmatter/bibliography:id649}
\sphinxAtStartPar
Claude Marceau, Varun Makhija, Dominique Platzer, A. Yu. Naumov, P. B. Corkum, Albert Stolow, D. M. Villeneuve, and Paul Hockett. Molecular Frame Reconstruction Using Time\sphinxhyphen{}Domain Photoionization Interferometry. \sphinxstyleemphasis{Physical Review Letters}, 119(8):083401, August 2017. \sphinxhref{https://doi.org/10.1103/PhysRevLett.119.083401}{doi:10.1103/PhysRevLett.119.083401}.
\bibitem[4]{backmatter/bibliography:id574}
\sphinxAtStartPar
Paul Hockett. Photoelectron Metrology Toolkit (PEMtk) Github repository. 2021. URL: \sphinxurl{https://github.com/phockett/PEMtk} (visited on 2022\sphinxhyphen{}02\sphinxhyphen{}18).
\bibitem[5]{backmatter/bibliography:id577}
\sphinxAtStartPar
Paul Hockett. Open Photoionization Docker Stacks. URL: \sphinxurl{https://github.com/phockett/open-photoionization-docker-stacks} (visited on 2022\sphinxhyphen{}08\sphinxhyphen{}04).
\bibitem[6]{backmatter/bibliography:id688}
\sphinxAtStartPar
Project Jupyter. URL: \sphinxurl{https://jupyter.org} (visited on 2023\sphinxhyphen{}01\sphinxhyphen{}16).
\bibitem[7]{backmatter/bibliography:id608}
\sphinxAtStartPar
Thomas Kluyver, Benjamin Ragan\sphinxhyphen{}Kelley, P\&\#233, Fernando Rez, Brian Granger, Matthias Bussonnier, Jonathan Frederic, Kyle Kelley, Jessica Hamrick, Jason Grout, Sylvain Corlay, Paul Ivanov, Dami\&\#225 Avila, n, Safia Abdalla, Carol Willing, and Jupyter Development Team. Jupyter Notebooks – a publishing format for reproducible computational workflows. \sphinxstyleemphasis{Positioning and Power in Academic Publishing: Players, Agents and Agendas}, pages 87–90, 2016. \sphinxhref{https://doi.org/10.3233/978-1-61499-649-1-87}{doi:10.3233/978\sphinxhyphen{}1\sphinxhyphen{}61499\sphinxhyphen{}649\sphinxhyphen{}1\sphinxhyphen{}87}.
\bibitem[8]{backmatter/bibliography:id533}
\sphinxAtStartPar
Brian E. Granger and Fernando Pérez. Jupyter: Thinking and Storytelling With Code and Data. \sphinxstyleemphasis{Computing in Science \& Engineering}, 23(2):7–14, March 2021. \sphinxhref{https://doi.org/10.1109/MCSE.2021.3059263}{doi:10.1109/MCSE.2021.3059263}.
\bibitem[9]{backmatter/bibliography:id596}
\sphinxAtStartPar
Jupyter Book Project. URL: \sphinxurl{https://jupyterbook.org}.
\bibitem[10]{backmatter/bibliography:id470}
\sphinxAtStartPar
Executable Books Community. Jupyter Book. Zenodo, February 2020. \sphinxhref{https://doi.org/10.5281/zenodo.4539666}{doi:10.5281/zenodo.4539666}.
\bibitem[11]{backmatter/bibliography:id573}
\sphinxAtStartPar
Paul Hockett. PEMtk \sphinxhyphen{} the Photoelectron Metrology Toolkit \sphinxhyphen{} documentation. 2021. URL: \sphinxurl{https://pemtk.readthedocs.io} (visited on 2022\sphinxhyphen{}02\sphinxhyphen{}18).
\bibitem[12]{backmatter/bibliography:id561}
\sphinxAtStartPar
Paul Hockett. ePSproc: Post\sphinxhyphen{}processing suite for ePolyScat electron\sphinxhyphen{}molecule scattering calculations. \sphinxstyleemphasis{Authorea}, 2016. \sphinxhref{https://doi.org/10.6084/m9.figshare.3545639}{doi:10.6084/m9.figshare.3545639}.
\bibitem[13]{backmatter/bibliography:id508}
\sphinxAtStartPar
Paul Hockett. ePSproc: Post\sphinxhyphen{}processing for ePolyScat (Github repository). Github, 2016. \sphinxhref{https://doi.org/10.6084/m9.figshare.3545639}{doi:10.6084/m9.figshare.3545639}.
\bibitem[14]{backmatter/bibliography:id506}
\sphinxAtStartPar
Paul Hockett. ePSproc: Post\sphinxhyphen{}processing for ePolyScat documentation. 2020. URL: \sphinxurl{https://epsproc.readthedocs.io} (visited on 2022\sphinxhyphen{}02\sphinxhyphen{}18).
\bibitem[15]{backmatter/bibliography:id640}
\sphinxAtStartPar
Robert R. Lucchese, Kazuo Takatsuka, and Vincent McKoy. Applications of the Schwinger variational principle to electron\sphinxhyphen{}molecule collisions and molecular photoionization. \sphinxstyleemphasis{Physics Reports}, 131(3):147–221, January 1986. \sphinxhref{https://doi.org/10.1016/0370-1573(86)90147-X}{doi:10.1016/0370\sphinxhyphen{}1573(86)90147\sphinxhyphen{}X}.
\bibitem[16]{backmatter/bibliography:id527}
\sphinxAtStartPar
F. A. Gianturco, R. R. Lucchese, and N. Sanna. Calculation of low\sphinxhyphen{}energy elastic cross sections for electron\sphinxhyphen{}CF4 scattering. \sphinxstyleemphasis{The Journal of Chemical Physics}, 100(9):6464, May 1994. \sphinxhref{https://doi.org/10.1063/1.467237}{doi:10.1063/1.467237}.
\bibitem[17]{backmatter/bibliography:id671}
\sphinxAtStartPar
Alexandra P P Natalense and Robert R Lucchese. Cross section and asymmetry parameter calculation for sulfur 1s photoionization of SF{[}sub 6{]}. \sphinxstyleemphasis{The Journal of Chemical Physics}, 111(12):5344, 1999. \sphinxhref{https://doi.org/10.1063/1.479794}{doi:10.1063/1.479794}.
\bibitem[18]{backmatter/bibliography:id643}
\sphinxAtStartPar
R R Lucchese. ePolyScat User's Manual. URL: \sphinxurl{https://epolyscat.droppages.com/} (visited on 2022\sphinxhyphen{}04\sphinxhyphen{}26).
\bibitem[19]{backmatter/bibliography:id450}
\sphinxAtStartPar
Andrew C. Brown, Gregory S. J. Armstrong, Jakub Benda, Daniel D. A. Clarke, Jack Wragg, Kathryn R. Hamilton, Zdeněk Mašín, Jimena D. Gorfinkiel, and Hugo W. van der Hart. RMT: R\sphinxhyphen{}matrix with time\sphinxhyphen{}dependence. Solving the semi\sphinxhyphen{}relativistic, time\sphinxhyphen{}dependent Schrödinger equation for general, multielectron atoms and molecules in intense, ultrashort, arbitrarily polarized laser pulses. \sphinxstyleemphasis{Computer Physics Communications}, 250:107062, May 2020. \sphinxhref{https://arxiv.org/abs/1905.06156}{arXiv:1905.06156}, \sphinxhref{https://doi.org/10.1016/j.cpc.2019.107062}{doi:10.1016/j.cpc.2019.107062}.
\bibitem[20]{backmatter/bibliography:id715}
\sphinxAtStartPar
Andrew C. Brown, Gregory S. J. Armstrong, Jakub Benda, Daniel D. A. Clarke, Jack Wragg, Kathryn R. Hamilton, Zdeněk Mašín, Jimena D. Gorfinkiel, and Hugo W. van der Hart. RMT: R\sphinxhyphen{}matrix with time\sphinxhyphen{}dependence (repository). May 2020. URL: \sphinxurl{https://gitlab.com/Uk-amor/RMT/rmt} (visited on 2022\sphinxhyphen{}11\sphinxhyphen{}09), \sphinxhref{https://arxiv.org/abs/1905.06156}{arXiv:1905.06156}.
\bibitem[21]{backmatter/bibliography:id522}
\sphinxAtStartPar
Michael W Schmidt, Kim K Baldridge, Jerry A Boatz, Steven T Elbert, Mark S Gordon, Jan H Jensen, Shiro Koseki, Nikita Matsunaga, Kiet A Nguyen, Shujun Su, Theresa L Windus, Michel Dupuis, and John A Montgomery. General atomic and molecular electronic structure system. \sphinxstyleemphasis{Journal of Computational Chemistry}, 14(11):1347–1363, 1993. \sphinxhref{https://doi.org/10.1002/jcc.540141112}{doi:10.1002/jcc.540141112}.
\bibitem[22]{backmatter/bibliography:id532}
\sphinxAtStartPar
Mark S. Gordon. Gamess website. URL: \sphinxurl{http://www.msg.ameslab.gov/gamess/}.
\bibitem[23]{backmatter/bibliography:id571}
\sphinxAtStartPar
Paul Hockett. ePS data: Photoionization calculations archive. 2019. URL: \sphinxurl{https://phockett.github.io/ePSdata/} (visited on 2022\sphinxhyphen{}02\sphinxhyphen{}16).
\bibitem[24]{backmatter/bibliography:id572}
\sphinxAtStartPar
Paul Hockett. ePSdata repositories on Zenodo. 2019. URL: \sphinxurl{https://zenodo.org/search?page=1\&size=20\&q=hockett\&keywords=Data}.
\bibitem[25]{backmatter/bibliography:id586}
\sphinxAtStartPar
Stephan Hoyer and Joe Hamman. Xarray: N\sphinxhyphen{}D labeled Arrays and Datasets in Python. \sphinxstyleemphasis{Journal of Open Research Software}, 5(1):10, April 2017. \sphinxhref{https://doi.org/10.5334/jors.148}{doi:10.5334/jors.148}.
\bibitem[26]{backmatter/bibliography:id810}
\sphinxAtStartPar
Xarray documentation. URL: \sphinxurl{https://docs.xarray.dev/en/latest/index.html} (visited on 2022\sphinxhyphen{}08\sphinxhyphen{}03).
\bibitem[27]{backmatter/bibliography:id448}
\sphinxAtStartPar
Mike Boyle. Spherical Functions. April 2022. URL: \sphinxurl{https://github.com/moble/spherical\_functions} (visited on 2022\sphinxhyphen{}08\sphinxhyphen{}03).
\bibitem[28]{backmatter/bibliography:id730}
\sphinxAtStartPar
SciPy documentation. URL: \sphinxurl{https://docs.scipy.org/doc/scipy/index.html} (visited on 2022\sphinxhyphen{}08\sphinxhyphen{}03).
\bibitem[29]{backmatter/bibliography:id800}
\sphinxAtStartPar
Mark A. Wieczorek and Matthias Meschede. SHTools: Tools for Working with Spherical Harmonics. \sphinxstyleemphasis{Geochemistry, Geophysics, Geosystems}, 19(8):2574–2592, August 2018. \sphinxhref{https://doi.org/10.1029/2018GC007529}{doi:10.1029/2018GC007529}.
\bibitem[30]{backmatter/bibliography:id740}
\sphinxAtStartPar
Mark A. Wieczorek and Matthias Meschede. SHtools Github. SHTOOLS, August 2022. URL: \sphinxurl{https://github.com/SHTOOLS/SHTOOLS} (visited on 2022\sphinxhyphen{}08\sphinxhyphen{}03).
\bibitem[31]{backmatter/bibliography:id635}
\sphinxAtStartPar
LMFIT documentation. URL: \sphinxurl{https://lmfit.github.io/lmfit-py/intro.html} (visited on 2022\sphinxhyphen{}08\sphinxhyphen{}03).
\bibitem[32]{backmatter/bibliography:id672}
\sphinxAtStartPar
Matthew Newville, Till Stensitzki, Daniel B. Allen, and Antonino Ingargiola. LMFIT: Non\sphinxhyphen{}Linear Least\sphinxhyphen{}Square Minimization and Curve\sphinxhyphen{}Fitting for Python. Zenodo, September 2014. \sphinxhref{https://doi.org/10.5281/zenodo.11813}{doi:10.5281/zenodo.11813}.
\bibitem[33]{backmatter/bibliography:id593}
\sphinxAtStartPar
Marcus Johansson and Valera Veryazov. Automatic procedure for generating symmetry adapted wavefunctions. \sphinxstyleemphasis{Journal of Cheminformatics}, 9(1):8, February 2017. \sphinxhref{https://doi.org/10.1186/s13321-017-0193-3}{doi:10.1186/s13321\sphinxhyphen{}017\sphinxhyphen{}0193\sphinxhyphen{}3}.
\bibitem[34]{backmatter/bibliography:id594}
\sphinxAtStartPar
Marcus Johansson. Libmsym Github. July 2022. URL: \sphinxurl{https://github.com/mcodev31/libmsym} (visited on 2022\sphinxhyphen{}08\sphinxhyphen{}03).
\bibitem[35]{backmatter/bibliography:id814}
\sphinxAtStartPar
C. Yang. On the Angular Distribution in Nuclear Reactions and Coincidence Measurements. \sphinxstyleemphasis{Physical Review}, 74(7):764–772, October 1948. \sphinxhref{https://doi.org/10.1103/PhysRev.74.764}{doi:10.1103/PhysRev.74.764}.
\bibitem[36]{backmatter/bibliography:id485}
\sphinxAtStartPar
D Dill. Fixed\sphinxhyphen{}molecule photoelectron angular distributions. \sphinxstyleemphasis{The Journal of Chemical Physics}, 65(3):1130–1133, 1976. \sphinxhref{https://doi.org/10.1063/1.433187}{doi:10.1063/1.433187}.
\bibitem[37]{backmatter/bibliography:id421}
\sphinxAtStartPar
S. L. Altmann and C. J. Bradley. On the Symmetries of Spherical Harmonics. \sphinxstyleemphasis{Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences}, 255(1054):199–215, January 1963. \sphinxhref{https://doi.org/10.1098/rsta.1963.0002}{doi:10.1098/rsta.1963.0002}.
\bibitem[38]{backmatter/bibliography:id422}
\sphinxAtStartPar
SL Altmann and AP Cracknell. Lattice harmonics I. Cubic groups. \sphinxstyleemphasis{Reviews of Modern Physics}, 37(1):19–32, 1965. URL: \sphinxurl{http://rmp.aps.org/abstract/RMP/v37/i1/p19\_1} (visited on 2013\sphinxhyphen{}06\sphinxhyphen{}12).
\bibitem[39]{backmatter/bibliography:id459}
\sphinxAtStartPar
N Chandra. Photoelectron spectroscopic studies of polyatomic molecules. I. Theory. \sphinxstyleemphasis{Journal of Physics B: Atomic and Molecular Physics}, 20(14):3405–3415, July 1987. \sphinxhref{https://doi.org/10.1088/0022-3700/20/14/013}{doi:10.1088/0022\sphinxhyphen{}3700/20/14/013}.
\bibitem[40]{backmatter/bibliography:id696}
\sphinxAtStartPar
Katharine L. Reid and Ivan Powis. Symmetry considerations in molecular photoionization: Fixed molecule photoelectron angular distributions in C3v molecules as observed in photoelectron–photoion coincidence experiments. \sphinxstyleemphasis{The Journal of Chemical Physics}, 100(2):1066, 1994. \sphinxhref{https://doi.org/10.1063/1.466638}{doi:10.1063/1.466638}.
\bibitem[41]{backmatter/bibliography:id736}
\sphinxAtStartPar
Tamar Seideman. Time\sphinxhyphen{}resolved photoelectron angular distributions: concepts, applications, and directions. \sphinxstyleemphasis{Annual review of physical chemistry}, 53:41–65, January 2002. \sphinxhref{https://doi.org/10.1146/annurev.physchem.53.082101.130051}{doi:10.1146/annurev.physchem.53.082101.130051}.
\bibitem[42]{backmatter/bibliography:id735}
\sphinxAtStartPar
Tamar Seideman. Time\sphinxhyphen{}resolved photoelectron angular distributions as a probe of coupled polyatomic dynamics. \sphinxstyleemphasis{Physical Review A}, 64(4):042504, September 2001. \sphinxhref{https://doi.org/10.1103/PhysRevA.64.042504}{doi:10.1103/PhysRevA.64.042504}.
\bibitem[43]{backmatter/bibliography:id690}
\sphinxAtStartPar
Christopher Gerry and Peter Knight. \sphinxstyleemphasis{Introductory Quantum Optics}. Cambridge University Press, 2005.
\bibitem[44]{backmatter/bibliography:id824}
\sphinxAtStartPar
Richard N Zare. \sphinxstyleemphasis{Angular Momentum: Understanding Spatial Aspects in Chemistry and Physics}. John Wiley \& Sons, 1988.
\bibitem[45]{backmatter/bibliography:id694}
\sphinxAtStartPar
Katharine L. Reid, David J. Leahy, and Richard N. Zare. Effect of breaking cylindrical symmetry on photoelectron angular distributions resulting from resonance\sphinxhyphen{}enhanced two\sphinxhyphen{}photon ionization. \sphinxstyleemphasis{The Journal of Chemical Physics}, 95(3):1746, 1991. \sphinxhref{https://doi.org/10.1063/1.461023}{doi:10.1063/1.461023}.
\bibitem[46]{backmatter/bibliography:id809}
\sphinxAtStartPar
Guorong Wu, Paul Hockett, and Albert Stolow. Time\sphinxhyphen{}resolved photoelectron spectroscopy: from wavepackets to observables. \sphinxstyleemphasis{Physical chemistry chemical physics : PCCP}, 13(41):18447–67, November 2011. \sphinxhref{https://doi.org/10.1039/c1cp22031d}{doi:10.1039/c1cp22031d}.
\bibitem[47]{backmatter/bibliography:id424}
\sphinxAtStartPar
Yasuki Arasaki, Kazuo Takatsuka, Kwanghsi Wang, and Vincent McKoy. Probing wavepacket dynamics with femtosecond energy\sphinxhyphen{} and angle\sphinxhyphen{}resolved photoelectron spectroscopy. \sphinxstyleemphasis{Journal of Electron Spectroscopy and Related Phenomena}, 108(1\sphinxhyphen{}3):89–98, 2000. \sphinxhref{https://doi.org/DOI: 10.1016/S0368-2048(00)00148-1}{doi:DOI: 10.1016/S0368\sphinxhyphen{}2048(00)00148\sphinxhyphen{}1}.
\bibitem[48]{backmatter/bibliography:id758}
\sphinxAtStartPar
Toshinori Suzuki and Benjamin J. Whitaker. Non\sphinxhyphen{}adiabatic effects in chemistry revealed by time\sphinxhyphen{}resolved charged\sphinxhyphen{}particle imaging. \sphinxstyleemphasis{International Reviews in Physical Chemistry}, 20(3):313–356, July 2001. \sphinxhref{https://doi.org/10.1080/01442350110045046}{doi:10.1080/01442350110045046}.
\bibitem[49]{backmatter/bibliography:id756}
\sphinxAtStartPar
Albert Stolow and Jonathan G. Underwood. Time\sphinxhyphen{}Resolved Photoelectron Spectroscopy of Non\sphinxhyphen{}Adiabatic Dynamics in Polyatomic Molecules. In Stuart A. Rice, editor, \sphinxstyleemphasis{Advances in Chemical Physics}, volume 139, pages 497–584. John Wiley \& Sons, Inc., Hoboken, NJ, USA, March 2008. \sphinxhref{https://doi.org/10.1002/9780470259498.ch6}{doi:10.1002/9780470259498.ch6}.
\bibitem[50]{backmatter/bibliography:id698}
\sphinxAtStartPar
Katharine L. Reid and Jonathan G. Underwood. Extracting molecular axis alignment from photoelectron angular distributions. \sphinxstyleemphasis{The Journal of Chemical Physics}, 112(8):3643, 2000. \sphinxhref{https://doi.org/10.1063/1.480517}{doi:10.1063/1.480517}.
\bibitem[51]{backmatter/bibliography:id785}
\sphinxAtStartPar
Jonathan G. Underwood and Katharine L. Reid. Time\sphinxhyphen{}resolved photoelectron angular distributions as a probe of intramolecular dynamics: Connecting the molecular frame and the laboratory frame. \sphinxstyleemphasis{The Journal of Chemical Physics}, 113(3):1067, 2000. \sphinxhref{https://doi.org/10.1063/1.481918}{doi:10.1063/1.481918}.
\bibitem[52]{backmatter/bibliography:id444}
\sphinxAtStartPar
Karl Blum. \sphinxstyleemphasis{Density Matrix Theory and Applications}. Volume 64. Springer Berlin Heidelberg, Berlin, Heidelberg, 3rd editio edition, 2012. ISBN 978\sphinxhyphen{}3\sphinxhyphen{}642\sphinxhyphen{}20560\sphinxhyphen{}6. \sphinxhref{https://doi.org/10.1007/978-3-642-20561-3}{doi:10.1007/978\sphinxhyphen{}3\sphinxhyphen{}642\sphinxhyphen{}20561\sphinxhyphen{}3}.
\bibitem[53]{backmatter/bibliography:id535}
\sphinxAtStartPar
Margaret Gregory, Paul Hockett, Albert Stolow, and Varun Makhija. Towards molecular frame photoelectron angular distributions in polyatomic molecules from lab frame coherent rotational wavepacket evolution. \sphinxstyleemphasis{Journal of Physics B: Atomic, Molecular and Optical Physics}, 54(14):145601, July 2021. \sphinxhref{https://arxiv.org/abs/2012.04561}{arXiv:2012.04561}, \sphinxhref{https://doi.org/10.1088/1361-6455/ac135f}{doi:10.1088/1361\sphinxhyphen{}6455/ac135f}.
\bibitem[54]{backmatter/bibliography:id536}
\sphinxAtStartPar
Margaret Gregory, Simon Neville, Michael Schuurman, and Varun Makhija. A laboratory frame density matrix for ultrafast quantum molecular dynamics. \sphinxstyleemphasis{The Journal of Chemical Physics}, 157(16):164301, October 2022. \sphinxhref{https://doi.org/10.1063/5.0109607}{doi:10.1063/5.0109607}.
\bibitem[55]{backmatter/bibliography:id654}
\sphinxAtStartPar
G. Mauro D'Ariano, Matteo G.A. Paris, and Massimiliano F. Sacchi. Quantum Tomography. In \sphinxstyleemphasis{Advances in Imaging and Electron Physics, Vol. 128}, pages 205–308. 2003. \sphinxhref{https://doi.org/10.1016/S1076-5670(03)80065-4}{doi:10.1016/S1076\sphinxhyphen{}5670(03)80065\sphinxhyphen{}4}.
\bibitem[56]{backmatter/bibliography:id770}
\sphinxAtStartPar
Malte C Tichy, Florian Mintert, and Andreas Buchleitner. Essential entanglement for atomic and molecular physics. \sphinxstyleemphasis{Journal of Physics B: Atomic, Molecular and Optical Physics}, 44(19):192001, October 2011. \sphinxhref{https://doi.org/10.1088/0953-4075/44/19/192001}{doi:10.1088/0953\sphinxhyphen{}4075/44/19/192001}.
\bibitem[57]{backmatter/bibliography:id820}
\sphinxAtStartPar
Joel Yuen\sphinxhyphen{}Zhou, Jacob J Krich, Ivan Kassal, Allan S Johnson, and Alán Aspuru\sphinxhyphen{}Guzik. \sphinxstyleemphasis{Ultrafast Spectroscopy: Quantum Information and Wavepackets}. IOP Publishing, 2014. ISBN 978\sphinxhyphen{}0\sphinxhyphen{}7503\sphinxhyphen{}1062\sphinxhyphen{}8. \sphinxhref{https://doi.org/10.1088/978-0-750-31062-8}{doi:10.1088/978\sphinxhyphen{}0\sphinxhyphen{}750\sphinxhyphen{}31062\sphinxhyphen{}8}.
\bibitem[58]{backmatter/bibliography:id726}
\sphinxAtStartPar
B Schmidtke, M Drescher, N a Cherepkov, and U Heinzmann. On the impossibility to perform a complete valence\sphinxhyphen{}shell photoionization experiment with closed\sphinxhyphen{}shell atoms. \sphinxstyleemphasis{Journal of Physics B: Atomic, Molecular and Optical Physics}, 33(13):2451–2465, July 2000. \sphinxhref{https://doi.org/10.1088/0953-4075/33/13/306}{doi:10.1088/0953\sphinxhyphen{}4075/33/13/306}.
\bibitem[59]{backmatter/bibliography:id692}
\sphinxAtStartPar
S Ramakrishna and Tamar Seideman. On the information content of time\sphinxhyphen{} and angle\sphinxhyphen{}resolved photoelectron spectroscopy. \sphinxstyleemphasis{Journal of Physics B: Atomic, Molecular and Optical Physics}, 45(19):194012, October 2012. \sphinxhref{https://doi.org/10.1088/0953-4075/45/19/194012}{doi:10.1088/0953\sphinxhyphen{}4075/45/19/194012}.
\bibitem[60]{backmatter/bibliography:id556}
\sphinxAtStartPar
P. Hockett, M. Wollenhaupt, C. Lux, and T. Baumert. Complete Photoionization Experiments via Ultrafast Coherent Control with Polarization Multiplexing. \sphinxstyleemphasis{Physical Review Letters}, 112(22):223001, June 2014. \sphinxhref{https://doi.org/10.1103/PhysRevLett.112.223001}{doi:10.1103/PhysRevLett.112.223001}.
\bibitem[61]{backmatter/bibliography:id558}
\sphinxAtStartPar
Paul Hockett, Matthias Wollenhaupt, Christian Lux, and Thomas Baumert. Complete photoionization experiments via ultrafast coherent control with polarization multiplexing. II. Numerics and analysis methodologies. \sphinxstyleemphasis{Physical Review A}, 92(1):013411, July 2015. \sphinxhref{https://doi.org/10.1103/PhysRevA.92.013411}{doi:10.1103/PhysRevA.92.013411}.
\bibitem[62]{backmatter/bibliography:id557}
\sphinxAtStartPar
P Hockett, M Wollenhaupt, and T Baumert. Coherent control of photoelectron wavepacket angular interferograms. \sphinxstyleemphasis{Journal of Physics B: Atomic, Molecular and Optical Physics}, 48(21):214004, November 2015. \sphinxhref{https://doi.org/10.1088/0953-4075/48/21/214004}{doi:10.1088/0953\sphinxhyphen{}4075/48/21/214004}.
\end{sphinxthebibliography}







\renewcommand{\indexname}{Index}
\printindex
\end{document}